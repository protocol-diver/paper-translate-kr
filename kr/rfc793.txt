RFC: 793
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                              전송 제어 프로토콜
                                    
                                    
                         DARPA INTERNET PROGRAM
                                    
                                프로토콜 사양
                                    
                                    
                                    
                             September 1981













                              prepared for
                                    
               Defense Advanced Research Projects Agency
                Information Processing Techniques Office
                         1400 Wilson Boulevard
                       Arlington, Virginia  22209







                                   by

                     Information Sciences Institute
                   University of Southern California
                           4676 Admiralty Way
                   Marina del Rey, California  90291
                   
                                  목차

    머리말

1.  INTRODUCTION (소개)

  1.1  Motivation (동기)
  1.2  Scope (범위)
  1.3  About This Document (문서 정보)
  1.4  Interfaces (인터페이스)
  1.5  Operation (작업)

2.  PHILOSOPHY (철학)

  2.1  Elements of the Internetwork System
       (인터네트워크 시스템 요소)
  2.2  Model of Operation
       (운영 모델)
  2.3  The Host Environment
       (호스트 환경)
  2.4  Interfaces
       (인터페이스)
  2.5  Relation to Other Protocols
       (다른 프로토콜과의 관계)
  2.6  Reliable Communication
       (신뢰할 수 있는 통신)
  2.7  Connection Establishment and Clearing
       (연결 설정 및 삭제)
  2.8  Data Communication
       (데이터 통신)
  2.9  Precedence and Security
       (우선 순위 및 보안)
  2.10 Robustness Principle
       (견고성 원칙)

3.  FUNCTIONAL SPECIFICATION (기능 명세)

  3.1  Header Format
       (헤더 형식)
  3.2  Terminology
       (용어)
  3.3  Sequence Numbers
       (시퀀스 번호)
  3.4  Establishing a connection
       (연결 설정)
  3.5  Closing a Connection
       (연결 종료)
  3.6  Precedence and Security
       (우선 순위 및 보안)
  3.7  Data Communication
       (데이터 통신)
  3.8  Interfaces
       (인터페이스)
  3.9  Event Processing
       (이벤트 처리)

용어 사전

참조

                                 머리말



이 문서는 DoD 표준 전송 제어 프로토콜(TCP)에 대해 설명합니다. 이 표준의 기반이 되는 ARPA
TCP 사양의 이전 버전은 9개였으며 현재 텍스트는 이들에서 많은 부분을 가져옵니다. 개념과 텍스트
측면 모두에서 이 작업에 많은 기여자가 있었습니다. 이 에디션은 몇 가지 세부 사항을 명확히 하고
문자 끝 버퍼 크기 조정을 제거하고 문자 메커니즘을 푸시 기능으로 다시 설명합니다.

                                                           Jon Postel

                                                           Editor

RFC:  793
Replaces: RFC 761
IENs:  129, 124, 112, 81,
55, 44, 40, 27, 21, 5

                             전송 제어 프로토콜

                         DARPA INTERNET PROGRAM
                               프로토콜 사양



                         1.  INTRODUCTION (소개)

전송 제어 프로토콜(TCP)은 패킷 교환 컴퓨터 통신 네트워크와 이러한 네트워크의 상호 연결된
시스템에서 호스트 간에 매우 안정적인 호스트 간 프로토콜로 사용하기 위한 것입니다.

이 문서는 전송 제어 프로토콜이 수행하는 기능, 이를 구현하는 프로그램, 서비스를 필요로 하는
프로그램 또는 사용자에 대한 인터페이스에 대해 설명합니다.

1.1.  Motivation (동기)

[번역자 주석]
  - (dbadoy) DoD: Department of Defense (국방부)

  컴퓨터 통신 시스템은 군대, 정부 및 민간 환경에서 점점 더 중요한 역할을 하고 있습니다. 이
  문서는 주로 군용 컴퓨터 통신 요구 사항, 특히 통신 불안정성이 있는 경우의 견고성과 혼잡이
  있는 경우의 가용성에 초점을 맞추고 있지만 이러한 문제 중 많은 부분이 민간 및 정부 부문에서도
  발견됩니다.

  전략적 및 전술적 컴퓨터 통신 네트워크가 개발되고 배치됨에 따라 이를 상호 연결하는 수단을
  제공하고 광범위한 응용 프로그램을 지원할 수 있는 표준 프로세스 간 통신 프로토콜을 제공하는
  것이 필수적입니다. 이러한 표준의 필요성을 예상하여 국방부 연구 및 엔지니어링 차관은 여기에
  설명된 전송 제어 프로토콜(TCP)이 DoD 전체 프로세스 간 통신 프로토콜 표준화의 기초가 될
  것이라고 선언했습니다.

  TCP는 다중 네트워크 응용 프로그램을 지원하는 계층화된 프로토콜 계층 구조에 적합하도록 설계된
  연결 지향 종단 간 신뢰할 수 있는 프로토콜입니다. TCP는 별개이지만 상호 연결된 컴퓨터 통신
  네트워크에 연결된 호스트 컴퓨터의 프로세스 쌍 간에 안정적인 프로세스 간 통신을 제공합니다.
  TCP 계층 아래의 통신 프로토콜의 신뢰성에 대한 가정은 거의 없습니다. TCP는 하위 수준
  프로토콜에서 간단하고 잠재적으로 신뢰할 수 없는 데이터그램 서비스를 얻을 수 있다고 가정합니다.
  원칙적으로 TCP는 유선 연결에서 패킷 교환 또는 회선 교환 네트워크에 이르는 광범위한 통신
  시스템에서 작동할 수 있어야 합니다.

  TCP는 [1]에서 Cerf와 Kahn이 처음 설명한 개념을 기반으로 합니다. TCP는 TCP가 인터넷
  데이터그램 "envelopes"에 포함된 정보의 가변 길이 세그먼트를 송수신하는 방법을 제공하는
  기본 인터넷 프로토콜[2] 바로 위의 계층화된 프로토콜 아키텍처에 적합합니다. 인터넷
  데이터그램은 서로 다른 네트워크에서 송신자 및 수신자 TCP의 주소를 지정하는 수단을 제공합니다.
  인터넷 프로토콜은 또한 여러 네트워크와 상호 연결 게이트웨이를 통해 전송 및 전달을 달성하는
  데 필요한 TCP 세그먼트의 조각화 또는 재조립을 처리합니다. 인터넷 프로토콜은 또한 TCP
  세그먼트의 우선 순위, 보안 분류 및 구획에 대한 정보를 전달하므로 이 정보는 여러 네트워크에서
  엔드 투 엔드로 전달될 수 있습니다.

                           Protocol Layering

                        +---------------------+
                        |     higher-level    |
                        +---------------------+
                        |        TCP          |
                        +---------------------+
                        |  internet protocol  |
                        +---------------------+
                        |communication network|
                        +---------------------+

                                그림 1

  이 문서의 대부분은 호스트 컴퓨터에서 더 높은 수준의 프로토콜과 함께 상주하는 TCP 구현의
  맥락에서 작성되었습니다. 일부 컴퓨터 시스템은 TCP 및 인터넷 프로토콜 계층과 네트워크별
  소프트웨어를 수용하는 프런트 엔드 컴퓨터를 통해 네트워크에 연결됩니다. TCP 사양은 적절한
  호스트-프론트 엔드 프로토콜이 구현되는 한 프런트 엔드 경우에도 구현 가능한 것으로 보이는 상위
  수준 프로토콜에 대한 인터페이스를 설명합니다.

1.2.  Scope (범위)

  TCP는 다중 네트워크 환경에서 안정적인 프로세스 간 통신 서비스를 제공하기 위한 것입니다.
  TCP는 여러 네트워크에서 일반적으로 사용되는 호스트 간 프로토콜입니다.

1.3.  About this Document (문서 정보)

  이 문서는 상위 수준 프로토콜과의 상호 작용 및 다른 TCP와의 상호 작용 모두에서 TCP 구현에
  필요한 동작 사양을 나타냅니다. 이 섹션의 나머지 부분에서는 프로토콜 인터페이스 및 작업에 대한
  매우 간략한 보기를 제공합니다. 섹션 2에서는 TCP 설계의 철학적 기반을 요약합니다. 섹션
  3에서는 다양한 이벤트(새 세그먼트 도착, 사용자 호출, 오류 등)가 발생할 때 TCP에 필요한
  조치에 대한 자세한 설명과 TCP 세그먼트의 형식에 대한 세부 정보를 모두 제공합니다.

1.4.  Interfaces (인터페이스)

  TCP는 한쪽에서 사용자 또는 응용 프로그램 프로세스에 연결하고 다른 쪽에서 인터넷 프로토콜과
  같은 하위 수준 프로토콜에 연결합니다.

  애플리케이션 프로세스와 TCP 사이의 인터페이스는 합리적으로 자세히 설명되어 있습니다. 이
  인터페이스는 운영 체제가 파일 조작을 위해 응용 프로그램 프로세스에 제공하는 호출과 매우 유사한
  일련의 호출로 구성됩니다. 예를 들어 연결을 열고 닫고 설정된 연결에서 데이터를 보내고 받는
  호출이 있습니다. 또한 TCP가 애플리케이션 프로그램과 비동기식으로 통신할 수 있을 것으로
  예상됩니다. 특정 운영 체제 환경에 적합한 인터페이스를 설계하기 위해 TCP 구현자에게 상당한
  자유가 허용되지만 유효한 구현을 위해 TCP/사용자 인터페이스에는 최소한의 기능이 필요합니다.

  TCP와 하위 수준 프로토콜 간의 인터페이스는 기본적으로 두 수준이 서로 정보를 비동기적으로
  전달할 수 있는 메커니즘이 있다고 가정하는 것을 제외하고는 지정되지 않습니다. 일반적으로 이
  인터페이스를 지정하는 하위 수준 프로토콜을 기대합니다. TCP는 상호 연결된 네트워크의 매우
  일반적인 환경에서 작동하도록 설계되었습니다. 이 문서 전체에서 가정되는 하위 수준 프로토콜은
  Internet Protocol[2]입니다.

1.5.  Operation (작업)

  위에서 언급한 바와 같이 TCP의 주요 목적은 신뢰할 수 있고 안전한 논리 회로 또는 프로세스 쌍
  간의 연결 서비스를 제공하는 것입니다. 신뢰성이 낮은 인터넷 통신 시스템 위에서 이 서비스를
  제공하려면 다음 영역의 시설이 필요합니다:

    Basic Data Transfer (기본 데이터 전송)
    Reliability (신뢰성)
    Flow Control (흐름 제어)
    Multiplexing (다중화)
    Connections (연결)
    Precedence and Security (우선 순위 및 보안)

  이러한 각 영역에서 TCP의 기본 작동은 다음 단락에 설명되어 있습니다.

  Basic Data Transfer (기본 데이터 전송):

    TCP는 인터넷 시스템을 통한 전송을 위해 몇 개의 옥텟을 세그먼트로 패키징하여 사용자 간에
    각 방향으로 연속적인 옥텟 스트림을 전송할 수 있습니다. 일반적으로 TCP는 자신의 편의에
    따라 데이터를 차단하고 전달할 시기를 결정합니다.

    때때로 사용자는 TCP에 제출한 모든 데이터가 전송되었는지 확인해야 합니다. 이를 위해 푸시
    기능이 정의됩니다. TCP에 제출된 데이터가 실제로 전송되도록 하기 위해 보내는 사용자는
    데이터를 받는 사용자에게 푸시해야 함을 나타냅니다. 푸시는 TCP가 해당 지점까지의 데이터를
    수신자에게 즉시 전달하고 전달하도록 합니다. 정확한 푸시 지점은 수신 사용자에게 표시되지
    않을 수 있으며 푸시 기능은 레코드 경계 마커를 제공하지 않습니다.

  Reliability (신뢰성):

    TCP는 인터넷 통신 시스템에 의해 손상, 손실, 복제 또는 순서 없이 전달된 데이터로부터
    복구해야 합니다. 이는 전송된 각 옥텟에 시퀀스 번호를 할당하고 수신 TCP에서 긍정적인
    승인(ACK)을 요구함으로써 달성됩니다. 시간 초과 간격 내에 ACK를 받지 못하면 데이터가
    다시 전송됩니다. 수신기에서 시퀀스 번호는 잘못된 순서로 수신될 수 있는 세그먼트를 올바르게
    정렬하고 중복을 제거하는 데 사용됩니다. 손상은 전송된 각 세그먼트에 체크섬을 추가하고
    수신자에서 확인하고 손상된 세그먼트를 버리는 방식으로 처리됩니다.

    TCP가 계속 제대로 작동하고 인터넷 시스템이 완전히 분할되지 않는 한 전송 오류는 올바른
    데이터 전달에 영향을 미치지 않습니다. TCP는 인터넷 통신 시스템 오류에서 복구합니다.

  Flow Control (흐름 제어):

    TCP는 수신자가 발신자가 보낸 데이터의 양을 제어할 수 있는 수단을 제공합니다. 이는
    성공적으로 수신된 마지막 세그먼트를 넘어 허용 가능한 시퀀스 번호의 범위를 나타내는 모든
    ACK와 함께 "window"를 반환함으로써 달성됩니다. window는 발신자가 추가 허가를 받기
    전에 전송할 수 있는 허용된 옥텟 수를 나타냅니다.

  Multiplexing (다중화):

    단일 호스트 내의 많은 프로세스가 동시에 TCP 통신 기능을 사용할 수 있도록 하기 위해
    TCP는 각 호스트 내에 일련의 주소 또는 포트를 제공합니다. 인터넷 통신 계층의 네트워크 및
    호스트 주소와 연결되어 소켓을 형성합니다. 소켓 쌍은 각 연결을 고유하게 식별합니다. 즉,
    하나의 소켓을 여러 연결에서 동시에 사용할 수 있습니다.

    프로세스에 대한 포트 바인딩은 각 호스트에서 독립적으로 처리됩니다. 그러나 대중에게 알려진
    고정 소켓에 자주 사용되는 프로세스(예: "logger" 또는 시분할 서비스)를 연결하는 것이
    유용합니다. 그런 다음 알려진 주소를 통해 이러한 서비스에 액세스할 수 있습니다. 다른
    프로세스의 포트 주소를 설정하고 학습하려면 보다 동적인 메커니즘이 필요할 수 있습니다.

  Connections (연결):

    위에서 설명한 안정성 및 흐름 제어 메커니즘은 TCP가 각 데이터 스트림에 대한 특정 상태
    정보를 초기화하고 유지 관리할 것을 요구합니다. 소켓, 시퀀스 번호 및 window 크기가
    포함된 이 정보의 조합을 연결(connection)이라고 합니다. 각 연결은 양쪽을 식별하는
    한 쌍의 소켓으로 고유하게 지정됩니다.

    두 프로세스가 통신하려면 TCP가 먼저 연결을 설정해야 합니다(양쪽에서 상태 정보 초기화).
    통신이 완료되면 연결이 종료되거나 종료되어 리소스를 다른 용도로 사용할 수 있습니다.

    신뢰할 수 없는 호스트 간에 그리고 신뢰할 수 없는 인터넷 통신 시스템을 통해 연결을
    설정해야 하므로 잘못된 연결 초기화를 방지하기 위해 시계-기반 시퀀스 번호가 있는
    핸드셰이크 메커니즘이 사용됩니다.

  Precedence and Security (우선 순위 및 보안):

    TCP 사용자는 통신의 보안 및 우선 순위를 나타낼 수 있습니다. 이러한 기능이 필요하지 않을
    때 사용할 기본값이 제공됩니다.

                             2.  PHILOSOPHY (철학)

2.1.  Elements of the Internetwork System (인터네트워크 시스템 요소)

  인터네트워크 환경은 게이트웨이를 통해 상호 연결된 네트워크에 연결된 호스트로 구성됩니다.
  여기서 네트워크는 로컬 네트워크(예: ETHERNET) 또는 대규모 네트워크(예: ARPANET)일 수
  있지만 어떤 경우든 패킷 교환 기술을 기반으로 한다고 가정합니다. 메시지를 생성하고 소비하는
  활성 에이전트는 프로세스입니다. 네트워크, 게이트웨이 및 호스트의 다양한 수준의 프로토콜은
  프로세스 포트 간의 논리적 연결에서 양방향 데이터 흐름을 제공하는 프로세스 간 통신 시스템을
  지원합니다.

  여기서 패킷이라는 용어는 일반적으로 호스트와 해당 네트워크 간의 하나의 트랜잭션 데이터를
  의미하는 데 사용됩니다. 네트워크 내에서 교환되는 데이터 블록의 형식은 일반적으로 우리에게
  중요하지 않습니다.

  호스트는 네트워크에 연결된 컴퓨터이며 통신 네트워크의 관점에서 보면 패킷의 송신지와
  목적지입니다. 프로세스는 호스트 컴퓨터에서 활성 요소로 간주됩니다(프로세스를 실행 중인
  프로그램으로 정의하는 일반적인 정의에 따름). 터미널과 파일 또는 기타 I/O 장치도 프로세스를
  사용하여 서로 통신하는 것으로 간주됩니다. 따라서 모든 통신은 프로세스 간 통신으로
  간주됩니다.

  프로세스는 자신과 다른 프로세스(또는 프로세스) 사이의 여러 통신 스트림을 구별해야 할 수
  있으므로 각 프로세스에는 다른 프로세스의 포트와 통신하는 데 사용되는 여러 포트가 있을 수
  있다고 가정합니다.

2.2.  Model of Operation (운영 모델)

  프로세스는 TCP를 호출하고 데이터 버퍼를 인수로 전달하여 데이터를 전송합니다. TCP는 이러한
  버퍼의 데이터를 세그먼트로 패키징하고 인터넷 모듈을 호출하여 각 세그먼트를 대상 TCP로
  전송합니다. 수신 TCP는 세그먼트의 데이터를 수신 사용자의 버퍼에 놓고 수신 사용자에게
  알립니다. TCP는 신뢰할 수 있는 주문 데이터 전송을 보장하기 위해 사용하는 세그먼트에 제어
  정보를 포함합니다.

  인터넷 통신 모델은 로컬 네트워크에 인터페이스를 제공하는 각 TCP와 연결된 인터넷 프로토콜
  모듈이 있다는 것입니다. 이 인터넷 모듈은 인터넷 데이터그램 내부의 TCP 세그먼트를 패키징하고
  이러한 데이터그램을 대상 인터넷 모듈 또는 중간 게이트웨이로 라우팅합니다. 로컬 네트워크를
  통해 데이터그램을 전송하기 위해 로컬 네트워크 패킷에 포함됩니다.

  패킷 스위치는 로컬 패킷을 목적지 인터넷 모듈로 전달하기 위해 추가 패키징, 단편화 또는 기타
  작업을 수행할 수 있습니다.

  네트워크 사이의 게이트웨이에서 인터넷 데이터그램은 로컬 패킷에서 "unwrapped"되고 인터넷
  데이터그램이 다음에 이동해야 하는 네트워크를 결정하기 위해 검사됩니다. 그런 다음 인터넷
  데이터그램은 다음 네트워크에 적합한 로컬 패킷으로 "wrapped"되어 다음 게이트웨이 또는 최종
  목적지로 라우팅됩니다.

  게이트웨이는 다음 네트워크를 통한 전송에 필요한 경우 인터넷 데이터그램을 더 작은 인터넷
  데이터그램 조각으로 분해할 수 있습니다. 이를 위해 게이트웨이는 일련의 인터넷 데이터그램을
  생성합니다; 각각 조각을 적재하고 있는. 조각은 후속 게이트웨이에서 더 작은 조각으로 더
  세분화될 수 있습니다. 인터넷 데이터그램 조각 형식은 대상 인터넷 모듈이 조각을 인터넷
  데이터그램으로 재조립할 수 있도록 설계되었습니다.

  대상 인터넷 모듈은 데이터그램에서 세그먼트를 풀고(필요한 경우 데이터그램을 재조립한 후)
  대상 TCP로 전달합니다.

  이 간단한 작업 모델은 많은 세부 사항을 얼버무립니다. 중요한 기능 중 하나는 서비스
  유형입니다. 이는 게이트웨이(또는 인터넷 모듈)에 정보를 제공하여 다음 네트워크 통과에 사용할
  서비스 매개변수를 선택하도록 안내합니다. 서비스 정보 유형에는 데이터그램의 우선 순위가
  포함됩니다. 데이터그램은 또한 보안 고려 사항과 데이터그램을 적절하게 분리하기 위해 다단계
  보안 환경에서 작동하는 호스트 및 게이트웨이를 허용하는 보안 정보를 전달할 수 있습니다.

2.3.  The Host Environment (호스트 환경)

  TCP는 운영 체제의 모듈로 간주됩니다. 사용자는 파일 시스템에 액세스하는 것처럼 TCP에
  액세스합니다. TCP는 예를 들어 데이터 구조를 관리하기 위해 다른 운영 체제 기능을 호출할 수
  있습니다. 네트워크에 대한 실제 인터페이스는 장치 드라이버 모듈에 의해 제어되는 것으로
  가정합니다. TCP는 네트워크 장치 드라이버를 직접 호출하지 않고 오히려 장치 드라이버를 호출할
  수 있는 인터넷 데이터그램 프로토콜 모듈을 호출합니다.

  TCP 메커니즘은 프런트 엔드 프로세서에서 TCP 구현을 배제하지 않습니다. 그러나 이러한
  구현에서 호스트-프론트 엔드 프로토콜은 이 문서에 설명된 TCP 사용자 인터페이스 유형을
  지원하는 기능을 제공해야 합니다.

2.4.  Interfaces (인터페이스)

  TCP/사용자 인터페이스는 연결을 열거나 닫거나, 데이터를 보내거나 받거나, 연결에 대한
  STATUS를 얻기 위해 TCP에서 사용자가 만든 호출을 제공합니다. 이러한 호출은 예를 들어 파일
  열기, 읽기 및 닫기 호출과 같이 운영 체제의 사용자 프로그램에서 발생하는 다른 호출과 같습니다.

  TCP/인터넷 인터페이스는 인터넷 시스템의 호스트에 있는 TCP 모듈로 지정된 데이터그램을
  송수신하기 위한 호출을 제공합니다. 이러한 호출에는 주소, 서비스 유형, 우선 순위, 보안 및
  기타 제어 정보를 전달하기 위한 매개 변수가 있습니다.

2.5.  Relation to Other Protocols (다른 프로토콜과의 관계)

  다음 다이어그램은 프로토콜 계층에서 TCP의 위치를 ​​보여줍니다:

                                    
       +------+ +-----+ +-----+       +-----+                    
       |Telnet| | FTP | |Voice|  ...  |     |  Application Level 
       +------+ +-----+ +-----+       +-----+                    
             |   |         |             |                       
            +-----+     +-----+       +-----+                    
            | TCP |     | RTP |  ...  |     |  Host Level        
            +-----+     +-----+       +-----+                    
               |           |             |                       
            +-------------------------------+                    
            |    Internet Protocol & ICMP   |  Gateway Level     
            +-------------------------------+                    
                           |                                     
              +---------------------------+                      
              |   Local Network Protocol  |    Network Level     
              +---------------------------+                      

                         Protocol Relationships

                                 그림 2.

  TCP가 더 높은 수준의 프로토콜을 효율적으로 지원할 수 있을 것으로 예상됩니다. ARPANET
  Telnet 또는 AUTODIN II THP와 같은 상위 수준 프로토콜을 TCP에 쉽게 인터페이스할 수
  있어야 합니다.

2.6.  Reliable Communication (신뢰할 수 있는 통신)

[번역자 주석]
  - (dbadoy) acknowledgment는 ack로 표현합니다.

  TCP 연결에서 전송된 데이터 스트림은 대상에서 순서대로 안정적으로 전달됩니다.

  전송은 시퀀스 번호와 ack(acknowledgments)를 사용하여 안정적으로 이루어집니다.
  개념적으로 데이터의 각 옥텟에는 시퀀스 번호가 할당됩니다. 세그먼트에 있는 데이터의 첫 번째
  옥텟의 시퀀스 번호는 해당 세그먼트와 함께 전송되며 세그먼트 시퀀스 번호라고 합니다.
  세그먼트는 또한 역방향 전송의 다음 예상 데이터 옥텟의 시퀀스 번호인 ack 번호를 전달합니다.
  TCP가 데이터가 포함된 세그먼트를 전송할 때 복사본을 재전송 대기열에 넣고 타이머를
  시작합니다. 해당 데이터에 대한 ack를 받으면 세그먼트가 대기열에서 삭제됩니다. 타이머가
  종료되기 전에 ack가 수신되지 않으면 세그먼트가 재전송됩니다.

  TCP의 ack는 데이터가 최종 사용자에게 전달되었음을 보장하지 않으며 수신 TCP가 이에 대한
  책임을 졌다는 것을 의미할 뿐입니다.

  TCP 사이의 데이터 흐름을 제어하기 위해 흐름 제어 메커니즘이 사용됩니다. 수신 TCP는 송신
  TCP에 "window"을 보고합니다. window는 ack 번호로 시작하여 수신 TCP가 현재 수신할
  준비가 된 옥텟 수를 지정합니다.

2.7.  Connection Establishment and Clearing (연결 설정 및 삭제)

  TCP가 처리할 수 있는 별도의 데이터 스트림을 식별하기 위해 TCP는 포트 식별자를 제공합니다.
  포트 식별자는 각 TCP에 의해 독립적으로 선택되므로 고유하지 않을 수 있습니다. 각 TCP
  내에서 고유한 주소를 제공하기 위해 TCP를 식별하는 인터넷 주소를 포트 식별자와 연결하여 함께
  연결된 모든 네트워크에서 고유한 소켓을 만듭니다.

  연결은 끝에 있는 한 쌍의 소켓으로 완전히 지정됩니다. 로컬 소켓은 다른 외부 소켓에 대한 많은
  연결에 참여할 수 있습니다. 연결은 양방향으로 데이터를 전달하는 데 사용할 수 있습니다. 즉,
  "전이중"입니다.

  TCP는 선택에 따라 포트를 프로세스와 자유롭게 연결할 수 있습니다. 그러나 모든 구현에는 몇
  가지 기본 개념이 필요합니다. TCP가 어떤 방식으로든 "적절한" 프로세스와만 연관시키는 잘
  알려진 소켓이 있어야 합니다. 우리는 프로세스가 포트를 "소유"할 수 있고 프로세스가 소유한
  포트에서만 연결을 시작할 수 있다고 생각합니다. (소유권을 구현하는 수단은 로컬 문제이지만
  요청 포트 사용자 명령 또는 주어진 프로세스에 포트 그룹을 고유하게 할당하는 방법(예: 포트
  이름의 상위 비트를 주어진 프로세스와 연결)을 구상합니다.)

  연결은 로컬 포트 및 외부 소켓 인수에 의해 OPEN 호출에서 지정됩니다. 그 대가로 TCP는
  사용자가 후속 호출에서 연결을 참조하는 (짧은) 로컬 연결 이름을 제공합니다. 연결에 대해
  기억해야 할 몇 가지 사항이 있습니다. 이 정보를 저장하기 위해 TCB(Transmission
  Control Block)라는 데이터 구조가 있다고 가정합니다. 구현 전략 중 하나는 로컬 연결
  이름이 이 연결에 대한 TCB에 대한 포인터가 되도록 하는 것입니다. OPEN 호출은 또한 연결
  설정을 능동적(Active)으로 추구할지 또는 수동적(Passive)으로 기다릴지 여부를 지정합니다.

  Passive OPEN 요청은 프로세스가 연결을 시작하려고 시도하는 대신 들어오는
  연결 요청을 수락하려고 함을 의미합니다. 종종 Passive OPEN을 요청하는 프로세스는 모든
  호출자의 연결 요청을 수락합니다. 이 경우 모두 0인 외부 소켓이 지정되지 않은 소켓을
  나타내는 데 사용됩니다. 지정되지 않은 외부 소켓은 Passive OPEN에서만 허용됩니다.

  알 수 없는 다른 프로세스에 서비스를 제공하려는 서비스 프로세스는 지정되지 않은 외부 소켓을
  사용하여 Passive OPEN 요청을 발행합니다. 그런 다음 이 로컬 소켓에 대한 연결을 요청한
  모든 프로세스와 연결할 수 있습니다. 이 로컬 소켓이 이 서비스와 연관되어 있는 것으로 알려져
  있다면 도움이 될 것입니다.

  Well-known 소켓은 소켓 주소를 표준 서비스와 연관시키는 선험적인 메커니즘입니다. 예를 들어,
  "Telnet-Server" 프로세스는 특정 소켓에 영구적으로 할당되고 다른 소켓은 파일 전송, 원격
  작업 항목, 텍스트 생성기, Echoer 및 싱크 프로세스(마지막 3개는 테스트용임)용으로
  예약됩니다. 새로 생성된 서비스가 제공될 특정 소켓을 반환하는 "Look-Up" 서비스에 대한
  액세스를 위해 소켓 주소를 예약할 수 있습니다. Well-known 소켓의 개념은 TCP 사양의
  일부이지만 서비스에 대한 소켓 할당은 이 사양의 범위를 벗어납니다. ([4] 참조.)

  프로세스는 Passive OPEN을 발행하고 다른 프로세스에서 일치하는 Active OPEN을 기다릴 수
  있으며 연결이 설정되면 TCP에서 알립니다. 동시에 서로에게 Active OPEN을 발행하는 두
  프로세스가 올바르게 연결됩니다. 이러한 유연성은 구성 요소가 서로에 대해 비동기적으로 작동하는
  분산 컴퓨팅 지원에 매우 중요합니다.

  로컬 Passive OPEN과 외부 Active OPEN의 소켓을 일치시키는 두 가지 주요 사례가
  있습니다. 첫 번째 경우 로컬 Passive OPEN이 외부 소켓을 완전히 지정했습니다. 이 경우 일치
  항목이 정확해야 합니다. 두 번째 경우에는 로컬 Passive OPEN이 외부 소켓을 지정하지 않은
  상태로 둡니다. 이 경우 로컬 소켓이 일치하는 한 모든 외부 소켓이 허용됩니다. 다른 가능성에는
  부분적으로 제한된 일치가 포함됩니다.

  동일한 로컬 소켓을 사용하여 보류 중인 Passive OPEN(TCB에 기록됨)이 여러 개 있는 경우,
  외부 Acitve OPEN은 지정되지 않은 외부 소켓이 있는 TCB를 선택하기 전에 해당 TCB가 존재하는
  경우 외부 Active OPEN의 특정 외부 소켓이 있는 TCB와 일치합니다.

  연결을 설정하는 절차는 동기화(SYN) 제어 플래그를 활용하고 세 가지 메시지 교환을 포함합니다.
  이 교환을 3-way hand shake라고 합니다[3].

  사용자 OPEN 명령에 의해 각각 생성된 SYN 및 대기 TCB 항목을 포함하는 도착 세그먼트의
  랑데부에 의해 연결이 시작됩니다. 로컬 및 외부 소켓의 일치에 따라 연결이 시작된 시기가
  결정됩니다. 시퀀스 번호가 양방향으로 동기화되면 연결이 "설정(established)"됩니다.

  연결 해제에는 세그먼트 교환도 포함되며, 이 경우에는 FIN 제어 플래그를 전달합니다.

2.8.  Data Communication (데이터 통신)

  연결에서 흐르는 데이터는 옥텟의 스트림으로 생각할 수 있습니다. 보내는 사용자는 각 SEND호출에서
  해당 호출(및 선행 호출)의 데이터를 PUSH 플래그 설정을 통해 수신 사용자에게 즉시 푸시해야
  하는지 여부를 나타냅니다.

  보내는 TCP는 보내는 사용자로부터 데이터를 수집하고 푸시 기능이 신호를 받을 때까지 자체 편의에
  따라 해당 데이터를 세그먼트로 보낼 수 있으며 그런 다음 보내지 않은 모든 데이터를 보내야 합니다.
  수신 TCP가 PUSH 플래그를 볼 때 데이터를 수신 프로세스로 전달하기 전에 송신 TCP에서 더 많은
  데이터를 기다리면 안 됩니다.

  푸시 기능과 세그먼트 경계 간에는 필요한 관계가 없습니다. 특정 세그먼트의 데이터는 전체 또는
  일부 또는 여러 SEND 호출의 단일 SEND 호출 결과일 수 있습니다.

  푸시 기능과 PUSH 플래그의 목적은 송신 사용자에서 수신 사용자로 데이터를 푸시하는 것입니다.
  레코드 서비스를 제공하지 않습니다.

  푸시 기능과 TCP/사용자 인터페이스를 교차하는 데이터 버퍼 사용 사이에는 결합이 있습니다.
  PUSH 플래그가 수신 사용자의 버퍼에 배치된 데이터와 연결될 때마다 버퍼가 채워지지 않은
  경우에도 처리를 위해 버퍼가 사용자에게 반환됩니다. PUSH가 발생하기 전에 사용자의 버퍼를
  채우는 데이터가 도착하면 버퍼 크기 단위로 데이터가 사용자에게 전달됩니다.

  TCP는 또한 수신자가 현재 읽고 있는 것보다 데이터 스트림의 더 먼 지점에서 긴급 데이터가 있는
  데이터의 수신자와 통신할 수 있는 수단을 제공합니다. TCP는 보류 중인 긴급 데이터에 대한 알림을
  받았을 때 사용자가 구체적으로 수행하는 작업을 정의하려고 시도하지 않지만 일반적인 개념은 수신
  프로세스가 긴급 데이터를 신속하게 처리하기 위한 조치를 취하는 것입니다.

2.9.  Precedence and Security (우선 순위 및 보안)

  TCP는 인터넷 프로토콜 유형의 서비스 필드와 보안 옵션을 사용하여 TCP 사용자에게 연결별로 우선
  순위와 보안을 제공합니다. 모든 TCP 모듈이 다단계 보안 환경에서 반드시 작동하는 것은 아닙니다;
  일부는 분류되지 않은 사용으로만 제한될 수 있고 다른 일부는 하나의 보안 수준 및 구획에서만
  작동할 수 있습니다. 결과적으로 사용자에 대한 일부 TCP 구현 및 서비스는 다단계 보안 사례의
  하위 집합으로 제한될 수 있습니다.

  다단계 보안 환경에서 작동하는 TCP 모듈은 보안, 구획 및 우선 순위로 나가는 세그먼트를 적절하게
  표시해야 합니다. 이러한 TCP 모듈은 또한 사용자 또는 Telnet 또는 THP와 같은 상위 수준
  프로토콜에 원하는 보안 수준, 구획 및 연결 우선 순위를 지정할 수 있는 인터페이스를 제공해야
  합니다.

2.10.  Robustness Principle (견고성 원칙)

  TCP 구현은 견고성의 일반 원칙을 따릅니다: 즉, 자신이 하는 일에 있어서는 보수적이어야 하고
  다른 사람으로부터 받아들이는 것에 있어서는 자유로워야 합니다.

                      3.  FUNCTIONAL SPECIFICATION (기능 명세)

3.1.  Header Format (헤더 형식)

  TCP 세그먼트는 인터넷 데이터그램으로 전송됩니다. 인터넷 프로토콜 헤더는 송신자 및 수신자
  호스트 주소를 포함하여 여러 정보 필드를 전달합니다 [2]. TCP 헤더는 인터넷 헤더 다음에 TCP
  프로토콜에 특정한 정보를 제공합니다. 이러한 분할은 TCP 이외의 호스트 수준 프로토콜의 존재를
  허용합니다.

  TCP Header Format (TCP 헤더 형식)

                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    TCP Header Format (TCP 헤더 형식)

                  하나의 눈금 표시는 하나의 비트 위치를 나타냅니다.

                                  그림 3.

  Source Port:  16 bits

    송신자 포트 번호입니다.

  Destination Port:  16 bits

    수신자 포트 번호입니다.

  Sequence Number:  32 bits

    이 세그먼트에 있는 첫 번째 데이터 옥텟의 시퀀스 번호입니다(SYN이 있는 경우 제외).
    SYN이 있는 경우 시퀀스 번호는 초기 시퀀스 번호(Inintial Sequence Number)이고 첫
    번째 데이터 옥텟은 ISN+1입니다.

  Acknowledgment Number:  32 bits

    ACK 제어 비트가 설정되면 이 필드에는 세그먼트의 송신자가 수신할 것으로 예상되는 다음
    시퀀스 번호의 값이 포함됩니다. 연결이 설정되면 항상 전송됩니다.

  Data Offset:  4 bits

    TCP 헤더의 32비트 워드(word) 수입니다. 이것은 데이터가 시작되는 위치를 나타냅니다.
    TCP 헤더(옵션 포함)는 32비트 길이의 정수입니다.

  Reserved:  6 bits

    향후 사용을 위해 예약되었습니다. 반드시 0이어야 합니다.

  Control Bits:  6 bits (from left to right):

    URG:  Urgent Pointer field significant
    ACK:  Acknowledgment field significant
    PSH:  Push Function
    RST:  Reset the connection
    SYN:  Synchronize sequence numbers
    FIN:  No more data from sender

  Window:  16 bits

    이 세그먼트의 송신자가 수락할 의향이 있는 acknowledgment 필드에 표시된 것으로 시작하는
    데이터 옥텟의 수입니다.

  Checksum:  16 bits

    체크섬 필드는 헤더와 텍스트에 있는 모든 16비트 단어의 1의 보수 합계에 대한 16비트 1의
    보수입니다. 세그먼트에 체크섬을 계산할 홀수 개의 헤더 및 텍스트 옥텟이 포함된 경우 마지막
    옥텟의 오른쪽이 0으로 채워져 체크섬 목적을 위한 16비트 워드를 형성합니다. 패드는
    세그먼트의 일부로 전송되지 않습니다. 체크섬을 계산하는 동안 체크섬 필드 자체는 0으로
    대체됩니다.

    체크섬은 개념적으로 TCP 헤더에 접두사가 붙은 96비트 pseudo 헤더도 포함합니다. 이
    pseudo 헤더에는 송신자 주소, 수신자 주소, 프로토콜 및 TCP 길이가 포함됩니다. 이는
    잘못 라우팅된 세그먼트에 대한 TCP 보호를 제공합니다. 이 정보는 인터넷 프로토콜에서
    전달되며 IP에서 TCP에 의한 인수 또는 호출 결과로 TCP/네트워크 인터페이스를 통해
    전송됩니다.

                     +--------+--------+--------+--------+
                     |           Source Address          |
                     +--------+--------+--------+--------+
                     |         Destination Address       |
                     +--------+--------+--------+--------+
                     |  zero  |  PTCL  |    TCP Length   |
                     +--------+--------+--------+--------+

      TCP 길이는 TCP 헤더 길이에 옥텟 단위의 데이터 길이를 더한 값이며(이는 명시적으로
      전송된 양이 아니라 계산됨) pseudo 헤더의 12 옥텟은 계산하지 않습니다.

  Urgent Pointer:  16 bits

    이 필드는 Urgent Pointer의 현재 값을 이 세그먼트의 시퀀스 번호에서 양의 오프셋으로
    전달합니다. 긴급 포인터는 긴급 데이터 다음에 오는 옥텟의 시퀀스 번호를 가리킵니다. 이
    필드는 URG 제어 비트가 설정된 세그먼트에서만 해석됩니다.

  Options:  variable

    옵션은 TCP 헤더 끝에서 공간을 차지할 수 있으며 길이가 8비트의 배수입니다. 모든 옵션은
    체크섬에 포함됩니다. 옵션은 모든 옥텟 경계에서 시작할 수 있습니다. 옵션 형식에는 두 가지
    경우가 있습니다:

      Case 1:  옵션 종류의 단일 옥텟.

      Case 2:  옵션 종류의 옥텟, 옵션 길이의 옥텟 및 실제 옵션 데이터 옥텟.

    옵션 길이는 옵션 데이터 옥텟뿐만 아니라 옵션 종류 및 옵션 길이의 두 옥텟을 계산합니다.

    옵션 목록은 데이터 오프셋 필드가 의미하는 것보다 짧을 수 있습니다. End-of-Option
    옵션 이외의 헤더 내용은 헤더 패딩(예: 0)이어야 합니다.

    TCP는 모든 옵션을 반드시 구현해야 합니다.

    현재 정의된 옵션에는 다음이 포함됩니다(종류는 8진수로 표시됨):

      Kind     Length    Meaning
      ----     ------    -------
       0         -       End of option list.
       1         -       No-Operation.
       2         4       Maximum Segment Size.
      

    특정 옵션 정의

      End of Option List

        +--------+
        |00000000|
        +--------+
         Kind=0

        이 옵션 코드는 옵션 목록의 끝을 나타냅니다. 이것은 데이터 오프셋 필드에 따라 TCP
        헤더의 끝과 일치하지 않을 수 있습니다. 이것은 각 옵션의 끝이 아니라 모든 옵션의
        끝에서 사용되며 옵션의 끝이 TCP 헤더의 끝과 일치하지 않는 경우에만 사용해야 합니다.

      No-Operation

        +--------+
        |00000001|
        +--------+
         Kind=1

        이 옵션 코드는 예를 들어 wor 경계에서 후속 옵션의 시작을 정렬하기 위해 옵션 사이에
        사용될 수 있습니다. 발신자가 이 옵션을 사용한다는 보장이 없으므로 수신자는 word
        경계에서 시작하지 않더라도 옵션을 처리할 준비가 되어 있어야 합니다.

      Maximum Segment Size

        +--------+--------+---------+--------+
        |00000010|00000100|   max seg size   |
        +--------+--------+---------+--------+
         Kind=2   Length=4

        Maximum Segment Size Option Data:  16 bits

          이 옵션이 있으면 이 세그먼트를 보내는 TCP에서 최대 수신 세그먼트 크기를
          전달합니다. 이 필드는 초기 연결 요청에서만 전송되어야 합니다(즉, SYN 제어 비트가
          설정된 세그먼트에서). 이 옵션을 사용하지 않으면 모든 세그먼트 크기가 허용됩니다.

  Padding:  variable

    TCP 헤더 패딩은 TCP 헤더가 끝나고 데이터가 32비트 경계에서 시작되도록 하는 데
    사용됩니다. 패딩은 0으로 구성됩니다.

3.2.  Terminology (용어)

  TCP 작동에 대해 많은 논의를 하기 전에 몇 가지 자세한 용어를 소개해야 합니다. TCP 연결을
  유지하려면 여러 변수를 기억해야 합니다. 우리는 이러한 변수가 전송 제어 블록(TCB)이라는 연결
  레코드에 저장된다고 상상합니다. TCB에 저장된 변수 중에는 로컬 및 원격 소켓 번호, 연결의 보안
  및 우선 순위, 사용자의 송신 및 수신 버퍼에 대한 포인터, 재전송 큐 및 현재 세그먼트에 대한
  포인터가 있습니다. 또한 송신 및 수신 시퀀스 번호와 관련된 여러 변수가 TCB에 저장됩니다.

    Send Sequence Variables (시퀀스 변수 전송)

      SND.UNA - unacknowledged 전송
      SND.NXT - next 전송
      SND.WND - window 전송
      SND.UP  - urgent pointer 전송
      SND.WL1 - 마지막 window 업데이트에 사용된 세그먼트 시퀀스 번호
      SND.WL2 - 마지막 window 업데이트에 사용된 세그먼트 acknowledged 번호
      ISS     - 초기 전송 시퀀스 번호

    Receive Sequence Variables (시퀀스 변수 수신)

      RCV.NXT - next 수신
      RCV.WND - window 수신
      RCV.UP  - urgent pointer 수신
      IRS     - 초기 수신 시퀀스 번호

  다음 다이어그램은 이러한 변수 중 일부를 시퀀스 공간과 관련시키는 데 도움이 될 수 있습니다.

  Send Sequence Space (시퀀스 공간 전송)

                   1         2          3          4      
              ----------|----------|----------|---------- 
                     SND.UNA    SND.NXT    SND.UNA        
                                          +SND.WND        

        1 - 확인된 이전 시퀀스 번호
        2 - unacknowledged 데이터의 시퀀스 번호
        3 - 새로운 데이터 전송에 허용되는 시퀀스 번호
        4 - 아직 허용되지 않은 미래 시퀀스 번호

                              시퀀스 공간 전송

                                 그림 4.
    
    

  Window 전송은 그림 4에서 3으로 표시된 시퀀스 공간의 일부입니다.


  Receive Sequence Space (시퀀스 공간 수신)

                       1          2          3      
                   ----------|----------|---------- 
                          RCV.NXT    RCV.NXT        
                                    +RCV.WND        

        1 - acknowledged 받은 이전 시퀀스 번호
        2 - 새로운 수신에 허용되는 시퀀스 번호
        3 - 아직 허용되지 않은 미래 시퀀스 번호

                               시퀀스 공간 수신

                                   그림 5.
    
    

  Window 수신은 그림 5에서 2로 표시된 시퀀스 공간의 일부입니다.

  현재 세그먼트의 필드에서 값을 가져오는 토론에서 자주 사용되는 일부 변수도 있습니다.

    Current Segment Variables (현재 세그먼트 변수)

      SEG.SEQ - 세그먼트 시퀀스 번호
      SEG.ACK - 세그먼트 acknowledgment 번호
      SEG.LEN - 세그먼트 길이
      SEG.WND - 세그먼트 window
      SEG.UP  - 세그먼트 urgent pointer
      SEG.PRC - 세그먼트 우선 순위 값

  연결은 수명 동안 일련의 상태를 통해 진행됩니다. 상태는 LISTEN, SYN-SENT, SYN-RECEIVED,
  ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,
  TIME-WAIT 및 가상 상태 CLOSED입니다. CLOSED는 TCB가 없고 따라서 연결이 없는 상태를
  나타내므로 허구입니다. 상태에 대한 간단한 의미는 다음과 같습니다:

    LISTEN - 원격 TCP 및 포트에서 연결 요청을 기다리는 것을 나타냅니다.

    SYN-SENT - 연결 요청을 보낸 후 일치하는 연결 요청을 기다리는 것을 나타냅니다.

    SYN-RECEIVED - 연결 요청을 수신하고 보낸 후 확인 연결 요청 확인을 기다리는 것을
    나타냅니다.

    ESTABLISHED - 열린 연결을 나타내며 수신된 데이터를 사용자에게 전달할 수 있습니다.
    연결의 데이터 전송 단계에 대한 정상 상태입니다.

    FIN-WAIT-1 - 원격 TCP의 연결 종료 요청을 기다리거나 이전에 보낸 연결 종료 요청에 대한
    확인을 나타냅니다.

    FIN-WAIT-2 - 원격 TCP의 연결 종료 요청을 기다리는 것을 나타냅니다.

    CLOSE-WAIT - 로컬 사용자의 연결 종료 요청을 기다리는 것을 나타냅니다.

    CLOSING - 원격 TCP의 연결 종료 요청 승인을 기다리는 것을 나타냅니다.

    LAST-ACK - 이전에 원격 TCP로 전송된 연결 종료 요청에 대한 확인(연결 종료 요청에 대한
    확인 포함)을 기다리는 것을 나타냅니다.

    TIME-WAIT - 원격 TCP가 연결 종료 요청에 대한 승인을 받았는지 확인하기 위해 충분한 시간을
    기다리는 것을 나타냅니다.

    CLOSED - 연결 상태가 전혀 없음을 나타냅니다.

  TCP 연결은 이벤트에 대한 응답으로 한 상태에서 다른 상태로 진행됩니다. 이벤트란 사용자가
  호출하는 OPEN, SEND, RECEIVE, CLOSE, ABORT 및 STATUS입니다; 들어오는 세그먼트,
  특히 SYN, ACK, RST 및 FIN 플래그을 포함하는 세그먼트; 그리고 타임아웃.

  그림 6의 상태 다이어그램은 원인 이벤트 및 결과 작업과 함께 상태 변경만 보여주지만 상태 변경과
  연결되지 않은 오류 조건이나 작업은 다루지 않습니다. 이후 섹션에서 이벤트에 대한 TCP의 반응과
  관련하여 더 자세한 내용이 제공됩니다.

  NOTE BENE:  이 다이어그램은 요약일 뿐이며 전체 사양으로 간주해서는 안 됩니다.
                                    
                              +---------+ ---------\      active OPEN  
                              |  CLOSED |            \    -----------  
                              +---------+<---------\   \   create TCB  
                                |     ^              \   \  snd SYN    
                   passive OPEN |     |   CLOSE        \   \           
                   ------------ |     | ----------       \   \         
                    create TCB  |     | delete TCB         \   \       
                                V     |                      \   \     
                              +---------+            CLOSE    |    \   
                              |  LISTEN |          ---------- |     |  
                              +---------+          delete TCB |     |  
                   rcv SYN      |     |     SEND              |     |  
                  -----------   |     |    -------            |     V  
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |<-----------------           ------------------>|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |<-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------                  
   |                  x         |     |     snd ACK                    
   |                            V     V                                
   |  CLOSE                   +---------+                              
   | -------                  |  ESTAB  |                              
   | snd FIN                  +---------+                              
   |                   CLOSE    |     |    rcv FIN                     
   V                  -------   |     |    -------                     
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |<-----------------           ------------------>|  CLOSE  |
 | WAIT-1  |------------------                              |   WAIT  |
 +---------+          rcv FIN  \                            +---------+
   | rcv ACK of FIN   -------   |                            CLOSE  |  
   | --------------   snd ACK   |                           ------- |  
   V        x                   V                           snd FIN V  
 +---------+                  +---------+                   +---------+
 |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 +---------+                  +---------+                   +---------+
   |                rcv ACK of FIN |                 rcv ACK of FIN |  
   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |  
   |  -------              x       V    ------------        x       V  
    \ snd ACK                 +---------+delete TCB         +---------+
     ------------------------>|TIME WAIT|------------------>| CLOSED  |
                              +---------+                   +---------+

                          TCP 연결 상태 다이어그램
                                 그림 6.

3.3.  Sequence Numbers (시퀀스 번호)

  설계의 기본 개념은 TCP 연결을 통해 전송되는 모든 데이터 옥텟에 시퀀스 번호가 있다는 것입니다.
  모든 옥텟이 시퀀싱되기 때문에 각 옥텟을 확인할 수 있습니다. 채택된 acknowledgment
  메커니즘은 누적되므로 시퀀스 번호 X의 acknowledgment은 X를 제외한 모든 옥텟이 수신되었음을
  나타냅니다. 이 메커니즘은 재전송이 있을 때 간단한 중복 감지를 허용합니다. 세그먼트 내 옥텟의
  번호 매기기는 헤더 바로 다음의 첫 번째 데이터 옥텟이 가장 낮은 번호가 매겨지고 다음 옥텟이
  연속적으로 번호가 매겨지는 것입니다.

  실제 시퀀스 번호 공간은 매우 크지만 유한하다는 점을 기억하는 것이 중요합니다. 이 공간의 범위는
  0에서 2**32 - 1까지입니다. 공간이 유한하기 때문에 시퀀스 번호를 다루는 모든 산술은 모듈러
  2**32로 수행되어야 합니다. 이 부호 없는 산술은 2**32 - 1에서 0으로 다시 순환할 때 시퀀스
  번호의 관계를 유지합니다. 컴퓨터 모듈러 산술에는 약간의 미묘함이 있으므로 이러한 값의 비교를
  프로그래밍할 때 상당한 주의를 기울여야 합니다. "=<" 기호는 "작거나 같음"(모듈러 2**32)을
  의미합니다.

  TCP가 수행해야 하는 일반적인 시퀀스 번호 비교 유형은 다음과 같습니다:

    (a)  acknowledgment가 전송되었지만 아직 승인(acknowledged)되지 않은 일부 시퀀스
         번호를 참조하는지 확인합니다.

    (b)  세그먼트가 점유한 모든 시퀀스 번호가 승인되었는지 확인(예: 재전송 대기열에서 세그먼트
         제거)

    (c)  들어오는 세그먼트에 예상되는 시퀀스 번호가 포함되어 있는지 확인(즉, 세그먼트가 수신
         window와 "겹침")

  데이터 전송에 대한 응답으로 TCP는 acknowledgment를 받습니다. acknowledgment를
  처리하려면 다음과 같은 비교가 필요합니다.

    SND.UNA = 가장 오래된 unacknowledged 시퀀스 번호

    SND.NXT = 다음 보낼 시퀀스 번호

    SEG.ACK = 수신 TCP의 acknowledgment(수신 TCP가 예상하는 다음 시퀀스 번호)

    SEG.SEQ = 세그먼트의 첫 번째 시퀀스 번호

    SEG.LEN = 세그먼트의 데이터가 차지하는 옥텟 수(SYN 및 FIN 계산)

    SEG.SEQ+SEG.LEN-1 = 세그먼트의 마지막 시퀀스 번호

  새로운 acknowledgment("acceptable ack"이라고 함)는 다음과 같은 부등식을
  유지하는 것입니다:

    SND.UNA < SEG.ACK =< SND.NXT

  재전송 대기열의 세그먼트는 시퀀스 번호와 길이의 합이 수신 세그먼트의 acknowledgment 값보다
  작거나 같으면 완전히 확인된 것입니다.

  데이터가 수신되면 다음 비교가 필요합니다:

    RCV.NXT = 들어오는 세그먼트에서 예상되는 다음 시퀀스 번호이며 수신 window의 왼쪽 또는
        아래쪽 가장자리입니다.

    RCV.NXT+RCV.WND-1 = 들어오는 세그먼트에서 예상되는 마지막 시퀀스 번호이며 수신
        window의 오른쪽 또는 위쪽 가장자리입니다.

    SEG.SEQ = 들어오는 세그먼트가 차지하는 첫 번째 시퀀스 번호

    SEG.SEQ+SEG.LEN-1 = 들어오는 세그먼트가 차지하는 마지막 시퀀스 번호

  다음과 같은 경우 세그먼트가 유효한 수신 시퀀스 공간의 일부를 차지하는 것으로 판단됩니다

    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

  또는

    RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND

  이 테스트의 첫 번째 부분은 세그먼트의 시작 부분이 window에 속하는지 확인하고 테스트의 두 번째
  부분은 세그먼트의 끝이 window에 속하는지 확인합니다. 세그먼트가 테스트의 어느 한 부분을
  통과하면 window에 데이터가 포함됩니다.

  실제로는 이것보다 조금 더 복잡합니다. zero window와 길이가 0인 세그먼트로 인해 들어오는
  세그먼트의 허용 가능성에 대한 네 가지 경우가 있습니다:

    Segment Receive  Test
    Length  Window
    ------- -------  -------------------------------------------

       0       0     SEG.SEQ = RCV.NXT

       0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

      >0       0     not acceptable

      >0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
                  or RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND

  수신 window가 0이면 ACK 세그먼트를 제외하고 어떤 세그먼트도 허용되지 않아야 합니다. 따라서
  TCP가 데이터를 전송하고 ACK를 수신하는 동안 수신 window을 0으로 유지하는 것이 가능합니다.
  그러나 수신 window가 0인 경우에도 TCP는 들어오는 모든 세그먼트의 RST 및 URG 필드를
  처리해야 합니다.

  또한 특정 제어 정보를 보호하기 위해 번호 매기기 체계를 활용했습니다. 이는 시퀀스 공간에 일부
  제어 플래그를 암시적으로 포함하여 혼동 없이 재전송 및 승인될 수 있도록 함으로써 달성됩니다(즉,
  하나의 컨트롤 사본만 실행됨). 제어 정보는 세그먼트 데이터 공간에 물리적으로 전달되지 않습니다.
  결과적으로 컨트롤에 암시적으로 시퀀스 번호를 할당하는 규칙을 채택해야 합니다. SYN 및 FIN은
  이러한 보호가 필요한 유일한 컨트롤이며 이러한 컨트롤은 연결을 열고 닫을 때만 사용됩니다. 시퀀스
  번호를 위해 SYN은 발생하는 세그먼트의 첫 번째 실제 데이터 옥텟 이전에 발생하는 것으로 간주되는
  반면 FIN은 발생하는 세그먼트의 마지막 실제 데이터 옥텟 이후에 발생하는 것으로 간주됩니다.
  세그먼트 길이(SEG.LEN)에는 컨트롤을 차지하는 데이터 및 시퀀스 공간이 모두 포함됩니다. SYN이
  있는 경우 SEG.SEQ는 SYN의 시퀀스 번호입니다.

  Initial Sequence Number Selection (초기 시퀀스 번호 선택)

  프로토콜은 반복해서 사용되는 특정 연결에 제한을 두지 않습니다. 연결은 한 쌍의 소켓으로
  정의됩니다. 연결의 새 인스턴스를 연결의 실현(incarnations)이라고 지칭할 것 입니다. 여기서
  발생하는 문제는 -- "어떻게 TCP가 연결의 이전 실현에서 중복 세그먼트를 식별할 것인가?"
  입니다. 이 문제는 연결이 빠르게 연속적으로 열리고 닫히거나 메모리 손실로 인해 연결이 끊어졌다가
  다시 설정되는 경우 명백해집니다.

  혼동을 피하기 위해 이전 실현에서 네트워크에 동일한 시퀀스 번호가 여전히 존재할 수 있는 동안
  연결의 한 실현에서 세그먼트가 사용되는 것을 방지해야 합니다. TCP가 충돌하여 사용하고 있는
  시퀀스 번호에 대한 모든 정보를 잃어버리더라도 이를 보장하고자 합니다. 새 연결이 생성되면
  새로운 32비트 ISN을 선택하는 초기 시퀀스 번호(ISN = Initial Sequence Number)
  생성기가 사용됩니다. 생성기는 하위 비트가 약 4마이크로초마다 증가하는 (아마도 가상의) 32비트
  클럭에 바인딩됩니다. 따라서 ISN은 약 4.55시간마다 순환합니다. 세그먼트가 최대 세그먼트 수명
  (MSL = Maximum Segment Lifetime) 이하로 네트워크에 유지되고 MSL이 4.55시간
  미만이라고 가정하므로 ISN이 고유할 것이라고 합리적으로 가정할 수 있습니다.

  각 연결에는 송신 시퀀스 번호와 수신 시퀀스 번호가 있습니다. 초기 전송 시퀀스 번호(ISS =
  Initial Send Sequence number)는 데이터 전송 TCP에 의해 선택되고 초기 수신 시퀀스
  번호 (IRS = Initial Receive Sequence number)는 연결 설정 절차 중에 학습됩니다.

  연결을 설정하거나 초기화하려면 두 TCP가 서로의 초기 시퀀스 번호를 동기화해야 합니다. 이것은
  "SYN"(동기화용)이라는 제어 비트와 초기 시퀀스 번호를 전달하는 연결 설정 세그먼트의 교환에서
  수행됩니다. 간단히 말해서 SYN 비트를 전달하는 세그먼트를 "SYN"이라고도 합니다. 따라서
  솔루션에는 초기 시퀀스 번호를 선택하기 위한 적절한 메커니즘과 ISN을 교환하기 위해 약간 관련된
  핸드셰이크가 필요합니다.

  동기화를 위해서는 각 측이 자신의 초기 시퀀스 번호를 전송하고 상대방의 acknowledgment을
  수신해야 합니다. 각 측은 또한 상대방의 초기 시퀀스 번호를 수신하고 확인 acknowledgment를
  보내야 합니다.

    1) A --> B  SYN 내 시퀀스 번호는 X입니다.
    2) A <-- B  ACK 당신의 시퀀스 번호는 X입니다.
    3) A <-- B  SYN 내 시퀀스 번호는 Y입니다.
    4) A --> B  ACK 당신의 시퀀스 번호는 Y입니다.

  2단계와 3단계를 단일 메시지로 결합할 수 있기 때문에 이를 3방향(또는 3개의 메시지)
  핸드셰이크라고 합니다.

  시퀀스 번호가 네트워크의 전역 시계에 연결되어 있지 않고 TCP가 ISN 선택을 위한 다른
  메커니즘을 가질 수 있기 때문에 3방향 핸드셰이크가 필요합니다. 첫 번째 SYN의 수신자는 연결에
  사용된 마지막 시퀀스 번호(항상 가능한 것은 아님)를 기억하지 않는 한 세그먼트가 이전에 지연된
  세그먼트인지 여부를 알 방법이 없으므로 발신자에게 이 SYN을 확인하도록 요청해야 합니다. 3방향
  핸드셰이크와 클록 기반 방식의 장점은 [3]에서 설명합니다.

  Knowing When to Keep Quiet

  TCP가 네트워크에 남아 있는 이전 세그먼트에 의해 복제될 수 있는 시퀀스 번호를 전달하는
  세그먼트를 생성하지 않도록 하기 위해 TCP는 시작 시 시퀀스 번호를 할당하기 전에 최대 세그먼트
  수명(MSL) 동안 조용히 유지하거나 사용 중인 시퀀스 번호의 메모리가 손실된 충돌에서 복구되어야
  합니다. 이 사양의 경우 MSL은 2분으로 간주됩니다. 이는 공학적 선택이며 경험상 그렇게 하는
  것이 바람직하다고 판단되면 변경할 수 있습니다. TCP가 어떤 의미에서 재초기화되었지만 사용 중인
  시퀀스 번호의 메모리를 유지하는 경우 전혀 기다릴 필요가 없습니다; 최근에 사용한 시퀀스 번호보다
  큰 시퀀스 번호만 사용해야 합니다.

  The TCP Quiet Time Concept

    이 사양은 각 활성(즉, 닫히지 않은) 연결에서 전송된 마지막 시퀀스 번호에 대한 지식을 보유하지
    않고 "충돌"하는 호스트는 호스트가 속한 인터넷 시스템에서 합의된 최대 세그먼트 수명(MSL) 이상
    동안 TCP 세그먼트 방출을 지연해야 한다고 규정합니다. 아래 단락에서 이 사양에 대한 설명이
    제공됩니다. TCP 구현자는 "quiet time" 제한을 위반할 수 있지만 인터넷 시스템의 일부
    수신자에 의해 오래된 데이터로 거부되거나 이전 데이터로 거부된 새로운 데이터로 일부 오래된
    데이터가 수락될 위험이 있습니다.

    TCP는 세그먼트가 형성되어 송신자 호스트 네트워크 출력 큐에 입력될 때마다 시퀀스 번호 공간을
    소비합니다. TCP 프로토콜의 중복 감지 및 시퀀싱 알고리즘은 해당 시퀀스 번호에 바인딩된
    세그먼트 데이터가 전달되기 전에 시퀀스 번호가 모든 2**32 값을 순환하지 않는 범위까지 시퀀스
    공간에 대한 세그먼트 데이터의 고유한 바인딩에 의존합니다. 수신자에 의해 확인되고 세그먼트의
    모든 중복 사본이 인터넷에서 "배출"되었습니다. 이러한 가정 없이 두 개의 서로 다른 TCP
    세그먼트는

    동일하거나 겹치는 시퀀스 번호가 할당되어 수신기에서 어떤 데이터가 새 데이터이고 어떤 데이터가
    오래된 것인지 혼동을 일으킵니다. 각 세그먼트는 세그먼트에 있는 데이터의 옥텟 수만큼 많은 연속
    시퀀스 번호에 연결되어 있음을 기억하십시오.

    정상 조건에서 TCP는 최초 사용이 acknowledgment되기 전 실수로 시퀀스 번호를 사용하는 것을
    방지하기 위해 내보낼 다음 시퀀스 번호와 acknowledgment 대기 중인 가장 오래된 시퀀스
    번호를 추적합니다. 이것만으로는 오래된 중복 데이터가 네트워크에서 유출된다는 보장이 없으므로
    떠돌아다니는 중복 데이터가 도착 시 문제를 일으킬 가능성을 줄이기 위해 시퀀스 공간을 매우 크게
    만들었습니다. 2메가비트/초. 시퀀스 공간의 2**32 옥텟을 사용하는 데 4.5시간이 걸립니다.
    네트워크의 최대 세그먼트 수명은 수십 초를 초과하지 않을 것이므로 데이터 속도가 수십
    메가비트/초로 상승하더라도 예측 가능한 네트워크에 대한 충분한 보호로 간주됩니다.
    100메가비트/초에서 주기 시간은 5.4분으로 약간 짧을 수 있지만 여전히 타당합니다.

    TCP의 기본 중복 감지 및 시퀀싱 알고리즘은 원본 TCP에 지정된 연결에서 마지막으로 사용된
    시퀀스 번호의 메모리가 없는 경우 실패할 수 있습니다. 예를 들어, TCP가 시퀀스 번호 0으로 모든
    연결을 시작하는 경우 충돌 및 재시작 시 TCP는 이전 연결을 다시 형성하고(아마도 반쯤 열린 연결
    해결 후) 시퀀스 번호가 동일하거나 겹치는 패킷을 내보낼 수 있습니다. 동일한 연결의 이전 화신에서
    방출된 패킷이 여전히 네트워크에 있습니다. 특정 연결에 사용된 시퀀스 번호에 대한 지식이 없는
    경우 TCP 사양은 연결에서 세그먼트를 방출하기 전에 MSL 초 동안 소스 지연을 권장하여 이전 연결
    구현의 세그먼트가 시스템에서 배출될 시간을 허용합니다.

    하루 중 시간을 기억할 수 있고 이를 사용하여 초기 시퀀스 번호 값을 선택하는 호스트도 이 문제에서
    면역되지 않습니다(즉, 시간을 사용하여 각각의 새로운 연결 구현에 대한 초기 시퀀스 번호를 선택하는
    경우에도).

    예를 들어 시퀀스 번호 S로 시작하는 연결이 열린다고 가정합니다. 이 연결이 많이 사용되지 않고 결국
    초기 시퀀스 번호 함수(ISN(t))가 특정 연결에서 이 TCP가 보낸 마지막 세그먼트의 S1과 같은
    시퀀스 번호와 같은 값을 갖는다고 가정합니다. 이제 이 순간에 호스트가 충돌, 복구 및 연결의 새로운
    실현(incarnation)을 설정한다고 가정합니다. 선택된 초기 시퀀스 번호는 S1 = ISN(t)입니다 --
    이전 연결의 실현에서 마지막으로 사용된 시퀀스 번호입니다! 복구가 충분히 빨리 발생하면 S1 근처에
    있는 net bearing 시퀀스 번호의 이전 중복이 도착할 수 있으며 연결의 새로운 실현 수신자에 의해
    새 패킷으로 처리될 수 있습니다.

    문제는 복구 중인 호스트가 얼마나 오래 충돌했는지 알 수 없으며 이전 연결의 실현에서 시스템에 여전히
    오래된 복제본이 있는지 여부를 알 수 없다는 것입니다.

    이 문제를 처리하는 한 가지 방법은 충돌에서 복구한 후 하나의 MSL에 대한 세그먼트 방출을
    의도적으로 지연시키는 것입니다. 이것이 "quite time" 사양입니다. 대기를 피하는 것을 선호하는
    호스트는 주어진 대상에서 이전 패킷과 새 패킷의 가능한 혼동 위험을 감수하고 "quite time"을
    기다리지 않기로 선택할 수 있습니다. 구현자는 TCP 사용자에게 충돌 후 대기할지 여부를 연결별로
    선택할 수 있는 기능을 제공하거나 모든 연결에 대해 비공식적으로 "quite time"을 구현할 수
    있습니다. 분명히 사용자가 "wait"를 선택한 경우에도 호스트가 최소한 MSL 초 동안 "up" 한
    후에는 이것이 필요하지 않습니다.

    요약: 방출된 모든 세그먼트는 시퀀스 공간에서 하나 이상의 시퀀스 번호를 차지하며, 세그먼트가
    차지하는 번호는 MSL 초가 지날 때까지 "busy" 또는 "in use"이고, 새 연결이 너무 빨리
    시작되고 이전 연결의 실현이 마지막 세그먼트의 시공간 풋프린트에 있는 시퀀스 번호를 사용하는
    경우 크래시 시 시공간 블록이 마지막 방출된 세그먼트의 옥텟에 의해 점유됩니다. 수신기에서
    혼동을 일으킬 수 있는 잠재적인 시퀀스 번호 중복 영역이 있습니다.
    
3.4.  Establishing a connection (연결 설정)

  "3방향 핸드셰이크"는 연결을 설정하는 데 사용되는 절차입니다. 이 절차는 일반적으로 하나의 TCP에 의해
  시작되고 다른 TCP에 의해 응답됩니다. 이 절차는 두 개의 TCP가 동시에 절차를 시작하는 경우에도
  작동합니다. 동시 시도가 발생하면 각 TCP는 "SYN"을 보낸 후 승인을 전달하지 않는 "SYN" 세그먼트를
  받습니다. 물론 오래된 복제 "SYN" 세그먼트가 도착하면 동시 연결 시작이 진행 중인 것처럼 수신자에게
  잠재적으로 나타날 수 있습니다. "reset" 세그먼트를 적절히 사용하면 이러한 경우를 명확하게 구분할 수
  있습니다.

  연결 시작의 몇 가지 예는 다음과 같습니다. 이 예에서는 데이터 운반 세그먼트를 사용하는 연결 동기화를
  보여주지 않지만 수신 TCP가 데이터가 유효하다는 것이 명확해질 때까지 사용자에게 데이터를 전달하지 않는
  한 이것은 완벽하게 합법적입니다(즉, 데이터는 연결이 ESTABLISHED 상태에 도달할 때까지 수신기에서
  버퍼링되어야 합니다). 3방향 핸드셰이크는 잘못된 연결의 가능성을 줄입니다. 이 확인을 위한 정보를
  제공하기 위해 메모리와 메시지 간의 균형을 구현합니다.

  가장 간단한 3방향 핸드셰이크는 아래 그림 7에 나와 있습니다. 수치는 다음과 같이 해석되어야 합니다. 각
  줄은 참조용으로 번호가 매겨져 있습니다. 오른쪽 화살표(-->)는 TCP A에서 TCP B로의 TCP 세그먼트
  출발 또는 A에서 B의 세그먼트 도착을 나타냅니다. 왼쪽 화살표(<--)는 그 반대를 나타냅니다.
  말줄임표(...)는 아직 네트워크에 있는(지연된) 세그먼트를 나타냅니다. "XXX"는 손실되거나 거부된
  세그먼트를 나타냅니다. 설명은 괄호 안에 표시됩니다. TCP 상태는 세그먼트의 출발 또는 도착 이후의
  상태를 나타냅니다(각 라인의 중앙에 내용이 표시됨). 세그먼트 내용은 시퀀스 번호, 제어 플래그 및 ACK
  필드와 함께 약식으로 표시됩니다. window, 주소, 길이 및 텍스트와 같은 다른 필드는 명확성을 위해
  제외되었습니다.
  

      TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED

  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED

                     연결 동기화를 위한 기본 3방향 핸드셰이크

                                  그림 7.

  그림 7의 라인 2에서 TCP A는 시퀀스 번호 100으로 시작하는 시퀀스 번호를 사용할 것임을 나타내는
  SYN 세그먼트를 보내는 것으로 시작합니다. 라인 3에서 TCP B는 SYN을 보내고 TCP A로부터 받은
  SYN을 승인합니다. acknowledgment 필드는 TCP B가 이제 시퀀스 100을 점유한 SYN을 승인하여
  시퀀스 101을 수신할 것으로 예상하고 있음을 나타냅니다.

  4행에서 TCP A는 TCP B의 SYN에 대한 ACK를 포함하는 빈 세그먼트로 응답합니다. 5번째 줄에서
  TCP A는 일부 데이터를 보냅니다. ACK가 시퀀스 번호 공간을 차지하지 않기 때문에 라인 5에 있는
  세그먼트의 시퀀스 번호는 라인 4와 동일합니다(만약 그렇다면 ACK를 ACK하는 것입니다!).

  동시 시작은 그림 8에 표시된 것처럼 약간 더 복잡할 뿐입니다. 각 TCP는 CLOSED에서 SYN-SENT,
  SYN-RECEIVED, ESTABLISHED로 순환합니다.
  

      TCP A                                            TCP B

  1.  CLOSED                                           CLOSED

  2.  SYN-SENT     --> <SEQ=100><CTL=SYN>              ...

  3.  SYN-RECEIVED <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT

  4.               ... <SEQ=100><CTL=SYN>              --> SYN-RECEIVED

  5.  SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...

  6.  ESTABLISHED  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED

  7.               ... <SEQ=101><ACK=301><CTL=ACK>     --> ESTABLISHED

                              동시 연결 동기화

                                 그림 8.

  3방향 핸드셰이크의 주된 이유는 오래된 중복 연결 시작으로 인해 혼란이 발생하지 않도록 하기 위함입니다.
  이를 처리하기 위해 특별한 제어 메시지인 reset이 고안되었습니다. 수신 TCP가 동기화되지 않은 상태
  (즉, SYN-SENT, SYN-RECEIVED)에 있는 경우 허용 가능한 재설정을 수신하면 LISTEN으로
  돌아갑니다. TCP가 동기화된 상태(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT,
  CLOSING, LAST-ACK, TIME-WAIT) 중 하나에 있으면 연결을 중단하고 사용자에게 알립니다. 이
  후자의 경우는 아래의 "half-open" 연결에서 논의합니다.

      TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               ...

  3.  (duplicate) ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED

  4.  SYN-SENT    <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED

  5.  SYN-SENT    --> <SEQ=91><CTL=RST>               --> LISTEN
  

  6.              ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  7.  SYN-SENT    <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED

                           이전 중복 SYN에서 복구

                                 그림 9.

  오래된 중복에서 복구하는 간단한 예로 그림 9를 살펴보십시오. 3행에서 오래된 중복 SYN이 TCP B에
  도착합니다. TCP B는 이것이 오래된 중복임을 알 수 없으므로 정상적으로 응답합니다(4행). TCP A는
  ACK 필드가 잘못되었음을 감지하고 세그먼트를 믿을 수 있도록 선택한 SEQ 필드와 함께 RST(reset)를
  반환합니다. RST를 수신한 TCP B는 LISTEN 상태로 돌아갑니다. 원래 SYN(말장난 의도)이 마침내
  6행에 도착하면 동기화가 정상적으로 진행됩니다. 6행의 SYN이 RST보다 먼저 도착했다면 양방향으로
  전송된 RST와 함께 더 복잡한 교환이 발생했을 수 있습니다.

  Half-Open Connections and Other Anomalies (Half-Open 및 기타 이상 현상)

  설정된 연결은 TCP 중 하나가 다른 TCP에 대한 지식 없이 끝에서 연결을 닫거나 중단한 경우나 충돌로
  인한 메모리 손실 때문에 연결의 두 끝이 비동기화된 경우를 "half-open"이라고 합니다. 이러한 연결은
  어느 방향으로든 데이터를 보내려고 하면 자동으로 재설정됩니다. 그러나 half-open 연결은 일반적이지
  않을 것으로 예상되며 복구 절차가 약간 포함됩니다.

  사이트 A에 연결이 더 이상 존재하지 않는 경우 사이트 B의 사용자가 데이터를 보내려고 시도하면 사이트 B
  TCP가 reset 제어 메시지를 수신하게 됩니다. 이러한 메시지는 사이트 B TCP에 무언가 잘못되었음을
  알리고 연결을 중단할 것으로 예상됩니다.

  충돌이 발생하여 A의 TCP에 대한 메모리 손실이 발생했을 때 두 사용자 프로세스 A와 B가 서로 통신하고
  있다고 가정합니다. A의 TCP를 지원하는 운영 체제에 따라 일부 오류 복구 메커니즘이 존재할 수 있습니다.
  TCP가 다시 가동되면 A는 처음부터 또는 복구 지점에서 다시 시작할 가능성이 높습니다. 결과적으로 A는
  아마도 연결을 다시 OPEN하려고 시도하거나 열려 있다고 믿는 연결에서 SEND를 시도할 것입니다. 후자의
  경우 로컬(A)의 TCP로부터 "connection not open"이라는 오류 메시지를 수신합니다. 연결을
  설정하려는 시도에서 A의 TCP는 SYN이 포함된 세그먼트를 보냅니다. 이 시나리오는 그림 10에 표시된
  예제로 이어집니다. TCP A 충돌 후 사용자는 연결을 다시 열려고 시도합니다. 그 동안 TCP B는 연결이
  열려 있다고 생각합니다.

  

      TCP A                                           TCP B

  1.  (CRASH)                               (send 300,receive 100)

  2.  CLOSED                                           ESTABLISHED

  3.  SYN-SENT --> <SEQ=400><CTL=SYN>              --> (??)

  4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED

  5.  SYN-SENT --> <SEQ=100><CTL=RST>              --> (Abort!!)

  6.  SYN-SENT                                         CLOSED

  7.  SYN-SENT --> <SEQ=400><CTL=SYN>              -->

                            Half-Open 연결 검색

                                  그림 10.

  SYN이 라인 3에 도착하면 동기화된 상태에 있는 TCP B와 윈도우 외부의 들어오는 세그먼트는 다음에 어떤
  시퀀스를 들을 것으로 예상하는지(ACK 100) 나타내는 acknowledgment으로 응답합니다. TCP A는 이
  세그먼트가 자신이 보낸 어떤 것도 승인하지 않는 것을 확인하고 동기화되지 않은 상태에서 half-open
  연결을 감지했기 때문에 reset(RST)을 보냅니다. TCP B는 5행에서 중단됩니다. TCP A는 계속해서 연결
  설정을 시도합니다; 문제는 이제 그림 7의 기본 3방향 핸드셰이크로 축소되었습니다.

  흥미로운 대안 사례는 TCP A가 충돌하고 TCP B가 동기화된 연결이라고 생각하는 데이터를 보내려고 할 때
  발생합니다. 이것은 그림 11에 설명되어 있습니다. 이 경우 TCP B에서 TCP A로 도착하는 데이터(라인
  2)는 그러한 연결이 존재하지 않기 때문에 허용되지 않으므로 TCP A는 RST를 보냅니다. RST가 허용되므로
  TCP B가 이를 처리하고 연결을 중단합니다.

  

        TCP A                                              TCP B

  1.  (CRASH)                                   (send 300,receive 100)

  2.  (??)    <-- <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED

  3.          --> <SEQ=100><CTL=RST>                   --> (ABORT!!)

                     Active 측에서 Half-Open 연결 검색 

                                  그림 11.

  그림 12에서 수동 연결이 SYN을 기다리는 두 개의 TCP A와 B를 볼 수 있습니다. TCP B(라인 2)에
  도착한 오래된 복제본은 B를 행동으로 몰아넣습니다. SYN-ACK가 반환되고(라인 3) TCP A가 RST를
  생성하도록 합니다(라인 3의 ACK는 허용되지 않음). TCP B는 재설정을 수락하고 Passive LISTEN
  상태로 돌아갑니다.

  

      TCP A                                         TCP B

  1.  LISTEN                                        LISTEN

  2.       ... <SEQ=Z><CTL=SYN>                -->  SYN-RECEIVED

  3.  (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED

  4.       --> <SEQ=Z+1><CTL=RST>              -->  (return to LISTEN!)

  5.  LISTEN                                        LISTEN

              오래된 중복 SYN이 2개의 Passive 소켓에서 재설정을 시작함

                                 그림 12.

  다양한 다른 경우가 가능하며 모두 RST 생성 및 처리에 대한 다음 규칙에 의해 설명됩니다.

  Reset Generation (Reset 생성)

  일반적으로 재설정(RST)은 현재 연결을 위한 것이 아닌 것으로 보이는 세그먼트가 도착할 때마다
  전송되어야 합니다. 이것이 사실인지 확실하지 않은 경우 reset을 보내서는 안 됩니다.

  세 가지 상태 그룹이 있습니다:

    1.  연결이 존재하지 않는 경우(CLOSED) 다른 reset을 제외한 수신 세그먼트에 대한 응답으로
    reset이 전송됩니다. 특히, 존재하지 않는 연결로 주소 지정된 SYN은 이 방법으로 거부됩니다.

    수신 세그먼트에 ACK 필드가 있는 경우 reset은 세그먼트의 ACK 필드에서 시퀀스 번호를 가져오고,
    그렇지 않으면 reset의 시퀀스 번호는 0이고 ACK 필드는 수신 세그먼트의 시퀀스 번호와 세그먼트
    길이의 합으로 설정됩니다. 연결은 CLOSED 상태로 유지됩니다.

    2.  연결이 동기화되지 않은 상태(LISTEN, SYN-SENT, SYN-RECEIVED)에 있고 수신 세그먼트가
    아직 전송되지 않은 것을 승인하거나(세그먼트가 허용할 수 없는 ACK를 전달함) 수신 세그먼트에 보안
    수준이 있거나 연결에 대해 요청된 구획 및 레벨과 정확히 일치하지 않는 구획이 있는 경우 reset이
    전송됩니다.

    SYN이 확인되지 않고 들어오는 세그먼트의 우선 순위 수준이 요청된 우선 순위 수준보다 높으면 로컬 우선
    순위 수준을 높이거나(사용자와 시스템에서 허용하는 경우) reset을 보냅니다. 또는 들어오는 세그먼트의
    우선 순위 수준이 요청된 우선 순위 수준보다 낮으면 우선 순위가 정확히 일치하는 것처럼 계속합니다(원격
    TCP가 우리와 일치하도록 우선 순위 수준을 올릴 수 없는 경우 이것은 전송하는 다음 세그먼트에서
    감지되고 그러면 연결이 종료됩니다.) SYN이 승인된 경우(아마도 이 수신 세그먼트에서) 수신 세그먼트의
    우선 순위 수준은 로컬 우선 순위 수준과 정확히 일치해야 하며 그렇지 않은 경우 reset을 전송해야
    합니다.

    수신 세그먼트에 ACK 필드가 있는 경우 reset은 세그먼트의 ACK 필드에서 시퀀스 번호를 가져오고,
    그렇지 않으면 reset의 시퀀스 번호는 0이고 ACK 필드는 수신 세그먼트의 시퀀스 번호와 세그먼트 길이의
    합으로 설정됩니다. 연결은 동일한 상태로 유지됩니다.

    3.  연결이 동기화된 상태(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING,
    LAST-ACK, TIME-WAIT)인 경우 허용되지 않는 세그먼트(윈도우 시퀀스 번호 밖 또는 허용되지 않는
    acknowledgment 번호)는 현재 전송 시퀀스 번호와 수신될 것으로 예상되는 다음 시퀀스 번호를
    나타내는 acknowledgment를 포함하는 빈 acknowledgment 세그먼트만 이끌어내야 하며 연결은
    동일한 상태로 유지됩니다.

    들어오는 세그먼트에 연결에 대해 요청된 수준, 구획 및 우선 순위와 정확히 일치하지 않는 보안 수준,
    구획 또는 우선 순위가 있는 경우 reset이 전송되고 연결이 CLOSED 상태로 전환됩니다. reset은
    들어오는 세그먼트의 ACK 필드에서 시퀀스 번호를 가져옵니다.

  Reset Processing (Reset 처리)

  SYN-SENT를 제외한 모든 상태에서 모든 reset(RST) 세그먼트는 SEQ 필드를 확인하여 확인됩니다.
  시퀀스 번호가 window에 있으면 reset이 유효합니다. SYN-SENT 상태(초기 SYN에 대한 응답으로 수신된
  RST)에서 ACK 필드가 SYN을 승인하면 RST가 허용됩니다.

  RST의 수신자는 먼저 유효성을 검사한 다음 상태를 변경합니다. 수신자가 LISTEN 상태에 있으면 무시합니다.
  수신자가 SYN-RECEIVED 상태이고 이전에 LISTEN 상태였다면 수신자는 LISTEN 상태로 돌아가고, 그렇지
  않으면 수신자는 연결을 중단하고 CLOSED 상태로 이동합니다. 수신자가 다른 상태에 있으면 연결을 중단하고
  사용자에게 알리고 CLOSED 상태로 이동합니다.

3.5.  Closing a Connection

  CLOSE is an operation meaning "I have no more data to send."  The
  notion of closing a full-duplex connection is subject to ambiguous
  interpretation, of course, since it may not be obvious how to treat
  the receiving side of the connection.  We have chosen to treat CLOSE
  in a simplex fashion.  The user who CLOSEs may continue to RECEIVE
  until he is told that the other side has CLOSED also.  Thus, a program
  could initiate several SENDs followed by a CLOSE, and then continue to
  RECEIVE until signaled that a RECEIVE failed because the other side
  has CLOSED.  We assume that the TCP will signal a user, even if no
  RECEIVEs are outstanding, that the other side has closed, so the user
  can terminate his side gracefully.  A TCP will reliably deliver all
  buffers SENT before the connection was CLOSED so a user who expects no
  data in return need only wait to hear the connection was CLOSED
  successfully to know that all his data was received at the destination
  TCP.  Users must keep reading connections they close for sending until
  the TCP says no more data.

  There are essentially three cases:

    1) The user initiates by telling the TCP to CLOSE the connection

    2) The remote TCP initiates by sending a FIN control signal

    3) Both users CLOSE simultaneously

  Case 1:  Local user initiates the close

    In this case, a FIN segment can be constructed and placed on the
    outgoing segment queue.  No further SENDs from the user will be
    accepted by the TCP, and it enters the FIN-WAIT-1 state.  RECEIVEs
    are allowed in this state.  All segments preceding and including FIN
    will be retransmitted until acknowledged.  When the other TCP has
    both acknowledged the FIN and sent a FIN of its own, the first TCP
    can ACK this FIN.  Note that a TCP receiving a FIN will ACK but not
    send its own FIN until its user has CLOSED the connection also.

  Case 2:  TCP receives a FIN from the network

    If an unsolicited FIN arrives from the network, the receiving TCP
    can ACK it and tell the user that the connection is closing.  The
    user will respond with a CLOSE, upon which the TCP can send a FIN to
    the other TCP after sending any remaining data.  The TCP then waits
    until its own FIN is acknowledged whereupon it deletes the
    connection.  If an ACK is not forthcoming, after the user timeout
    the connection is aborted and the user is told.

  Case 3:  both users close simultaneously

    A simultaneous CLOSE by users at both ends of a connection causes
    FIN segments to be exchanged.  When all segments preceding the FINs
    have been processed and acknowledged, each TCP can ACK the FIN it
    has received.  Both will, upon receiving these ACKs, delete the
    connection.

      TCP A                                                TCP B

  1.  ESTABLISHED                                          ESTABLISHED

  2.  (Close)
      FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT

  3.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT

  4.                                                       (Close)
      TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK

  5.  TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED

  6.  (2 MSL)
      CLOSED                                                      

                         Normal Close Sequence

                               Figure 13.

  

      TCP A                                                TCP B

  1.  ESTABLISHED                                          ESTABLISHED

  2.  (Close)                                              (Close)
      FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1
                  <-- <SEQ=300><ACK=100><CTL=FIN,ACK>  <--
                  ... <SEQ=100><ACK=300><CTL=FIN,ACK>  -->

  3.  CLOSING     --> <SEQ=101><ACK=301><CTL=ACK>      ... CLOSING
                  <-- <SEQ=301><ACK=101><CTL=ACK>      <--
                  ... <SEQ=101><ACK=301><CTL=ACK>      -->

  4.  TIME-WAIT                                            TIME-WAIT
      (2 MSL)                                              (2 MSL)
      CLOSED                                               CLOSED

                      Simultaneous Close Sequence

                               Figure 14.

3.6.  Precedence and Security

  The intent is that connection be allowed only between ports operating
  with exactly the same security and compartment values and at the
  higher of the precedence level requested by the two ports.

  The precedence and security parameters used in TCP are exactly those
  defined in the Internet Protocol (IP) [2].  Throughout this TCP
  specification the term "security/compartment" is intended to indicate
  the security parameters used in IP including security, compartment,
  user group, and handling restriction.

  A connection attempt with mismatched security/compartment values or a
  lower precedence value must be rejected by sending a reset.  Rejecting
  a connection due to too low a precedence only occurs after an
  acknowledgment of the SYN has been received.

  Note that TCP modules which operate only at the default value of
  precedence will still have to check the precedence of incoming
  segments and possibly raise the precedence level they use on the
  connection.

  The security paramaters may be used even in a non-secure environment
  (the values would indicate unclassified data), thus hosts in
  non-secure environments must be prepared to receive the security
  parameters, though they need not send them.

3.7.  Data Communication

  Once the connection is established data is communicated by the
  exchange of segments.  Because segments may be lost due to errors
  (checksum test failure), or network congestion, TCP uses
  retransmission (after a timeout) to ensure delivery of every segment.
  Duplicate segments may arrive due to network or TCP retransmission.
  As discussed in the section on sequence numbers the TCP performs
  certain tests on the sequence and acknowledgment numbers in the
  segments to verify their acceptability.

  The sender of data keeps track of the next sequence number to use in
  the variable SND.NXT.  The receiver of data keeps track of the next
  sequence number to expect in the variable RCV.NXT.  The sender of data
  keeps track of the oldest unacknowledged sequence number in the
  variable SND.UNA.  If the data flow is momentarily idle and all data
  sent has been acknowledged then the three variables will be equal.

  When the sender creates a segment and transmits it the sender advances
  SND.NXT.  When the receiver accepts a segment it advances RCV.NXT and
  sends an acknowledgment.  When the data sender receives an
  acknowledgment it advances SND.UNA.  The extent to which the values of
  these variables differ is a measure of the delay in the communication.
  The amount by which the variables are advanced is the length of the
  data in the segment.  Note that once in the ESTABLISHED state all
  segments must carry current acknowledgment information.

  The CLOSE user call implies a push function, as does the FIN control
  flag in an incoming segment.

  Retransmission Timeout

  Because of the variability of the networks that compose an
  internetwork system and the wide range of uses of TCP connections the
  retransmission timeout must be dynamically determined.  One procedure
  for determining a retransmission time out is given here as an
  illustration.

    An Example Retransmission Timeout Procedure

      Measure the elapsed time between sending a data octet with a
      particular sequence number and receiving an acknowledgment that
      covers that sequence number (segments sent do not have to match
      segments received).  This measured elapsed time is the Round Trip
      Time (RTT).  Next compute a Smoothed Round Trip Time (SRTT) as:

        SRTT = ( ALPHA * SRTT ) + ((1-ALPHA) * RTT)

      and based on this, compute the retransmission timeout (RTO) as:

        RTO = min[UBOUND,max[LBOUND,(BETA*SRTT)]]

      where UBOUND is an upper bound on the timeout (e.g., 1 minute),
      LBOUND is a lower bound on the timeout (e.g., 1 second), ALPHA is
      a smoothing factor (e.g., .8 to .9), and BETA is a delay variance
      factor (e.g., 1.3 to 2.0).

  The Communication of Urgent Information

  The objective of the TCP urgent mechanism is to allow the sending user
  to stimulate the receiving user to accept some urgent data and to
  permit the receiving TCP to indicate to the receiving user when all
  the currently known urgent data has been received by the user.

  This mechanism permits a point in the data stream to be designated as
  the end of urgent information.  Whenever this point is in advance of
  the receive sequence number (RCV.NXT) at the receiving TCP, that TCP
  must tell the user to go into "urgent mode"; when the receive sequence
  number catches up to the urgent pointer, the TCP must tell user to go
  into "normal mode".  If the urgent pointer is updated while the user
  is in "urgent mode", the update will be invisible to the user.

  The method employs a urgent field which is carried in all segments
  transmitted.  The URG control flag indicates that the urgent field is
  meaningful and must be added to the segment sequence number to yield
  the urgent pointer.  The absence of this flag indicates that there is
  no urgent data outstanding.

  To send an urgent indication the user must also send at least one data
  octet.  If the sending user also indicates a push, timely delivery of
  the urgent information to the destination process is enhanced.

  Managing the Window

  The window sent in each segment indicates the range of sequence
  numbers the sender of the window (the data receiver) is currently
  prepared to accept.  There is an assumption that this is related to
  the currently available data buffer space available for this
  connection.

  Indicating a large window encourages transmissions.  If more data
  arrives than can be accepted, it will be discarded.  This will result
  in excessive retransmissions, adding unnecessarily to the load on the
  network and the TCPs.  Indicating a small window may restrict the
  transmission of data to the point of introducing a round trip delay
  between each new segment transmitted.

  The mechanisms provided allow a TCP to advertise a large window and to
  subsequently advertise a much smaller window without having accepted
  that much data.  This, so called "shrinking the window," is strongly
  discouraged.  The robustness principle dictates that TCPs will not
  shrink the window themselves, but will be prepared for such behavior
  on the part of other TCPs.

  The sending TCP must be prepared to accept from the user and send at
  least one octet of new data even if the send window is zero.  The
  sending TCP must regularly retransmit to the receiving TCP even when
  the window is zero.  Two minutes is recommended for the retransmission
  interval when the window is zero.  This retransmission is essential to
  guarantee that when either TCP has a zero window the re-opening of the
  window will be reliably reported to the other.

  When the receiving TCP has a zero window and a segment arrives it must
  still send an acknowledgment showing its next expected sequence number
  and current window (zero).

  The sending TCP packages the data to be transmitted into segments
  which fit the current window, and may repackage segments on the
  retransmission queue.  Such repackaging is not required, but may be
  helpful.

  In a connection with a one-way data flow, the window information will
  be carried in acknowledgment segments that all have the same sequence
  number so there will be no way to reorder them if they arrive out of
  order.  This is not a serious problem, but it will allow the window
  information to be on occasion temporarily based on old reports from
  the data receiver.  A refinement to avoid this problem is to act on
  the window information from segments that carry the highest
  acknowledgment number (that is segments with acknowledgment number
  equal or greater than the highest previously received).

  The window management procedure has significant influence on the
  communication performance.  The following comments are suggestions to
  implementers.

    Window Management Suggestions

      Allocating a very small window causes data to be transmitted in
      many small segments when better performance is achieved using
      fewer large segments.

      One suggestion for avoiding small windows is for the receiver to
      defer updating a window until the additional allocation is at
      least X percent of the maximum allocation possible for the
      connection (where X might be 20 to 40).

      Another suggestion is for the sender to avoid sending small
      segments by waiting until the window is large enough before
      sending data.  If the the user signals a push function then the
      data must be sent even if it is a small segment.

      Note that the acknowledgments should not be delayed or unnecessary
      retransmissions will result.  One strategy would be to send an
      acknowledgment when a small segment arrives (with out updating the
      window information), and then to send another acknowledgment with
      new window information when the window is larger.

      The segment sent to probe a zero window may also begin a break up
      of transmitted data into smaller and smaller segments.  If a
      segment containing a single data octet sent to probe a zero window
      is accepted, it consumes one octet of the window now available.
      If the sending TCP simply sends as much as it can whenever the
      window is non zero, the transmitted data will be broken into
      alternating big and small segments.  As time goes on, occasional
      pauses in the receiver making window allocation available will
      result in breaking the big segments into a small and not quite so
      big pair. And after a while the data transmission will be in
      mostly small segments.

      The suggestion here is that the TCP implementations need to
      actively attempt to combine small window allocations into larger
      windows, since the mechanisms for managing the window tend to lead
      to many small windows in the simplest minded implementations.

3.8.  Interfaces

  There are of course two interfaces of concern:  the user/TCP interface
  and the TCP/lower-level interface.  We have a fairly elaborate model
  of the user/TCP interface, but the interface to the lower level
  protocol module is left unspecified here, since it will be specified
  in detail by the specification of the lowel level protocol.  For the
  case that the lower level is IP we note some of the parameter values
  that TCPs might use.

  User/TCP Interface

    The following functional description of user commands to the TCP is,
    at best, fictional, since every operating system will have different
    facilities.  Consequently, we must warn readers that different TCP
    implementations may have different user interfaces.  However, all
    TCPs must provide a certain minimum set of services to guarantee
    that all TCP implementations can support the same protocol
    hierarchy.  This section specifies the functional interfaces
    required of all TCP implementations.

    TCP User Commands

      The following sections functionally characterize a USER/TCP
      interface.  The notation used is similar to most procedure or
      function calls in high level languages, but this usage is not
      meant to rule out trap type service calls (e.g., SVCs, UUOs,
      EMTs).

      The user commands described below specify the basic functions the
      TCP must perform to support interprocess communication.
      Individual implementations must define their own exact format, and
      may provide combinations or subsets of the basic functions in
      single calls.  In particular, some implementations may wish to
      automatically OPEN a connection on the first SEND or RECEIVE
      issued by the user for a given connection.

      In providing interprocess communication facilities, the TCP must
      not only accept commands, but must also return information to the
      processes it serves.  The latter consists of:

        (a) general information about a connection (e.g., interrupts,
        remote close, binding of unspecified foreign socket).

        (b) replies to specific user commands indicating success or
        various types of failure.

      Open

        Format:  OPEN (local port, foreign socket, active/passive
        [, timeout] [, precedence] [, security/compartment] [, options])
        -> local connection name

        We assume that the local TCP is aware of the identity of the
        processes it serves and will check the authority of the process
        to use the connection specified.  Depending upon the
        implementation of the TCP, the local network and TCP identifiers
        for the source address will either be supplied by the TCP or the
        lower level protocol (e.g., IP).  These considerations are the
        result of concern about security, to the extent that no TCP be
        able to masquerade as another one, and so on.  Similarly, no
        process can masquerade as another without the collusion of the
        TCP.

        If the active/passive flag is set to passive, then this is a
        call to LISTEN for an incoming connection.  A passive open may
        have either a fully specified foreign socket to wait for a
        particular connection or an unspecified foreign socket to wait
        for any call.  A fully specified passive call can be made active
        by the subsequent execution of a SEND.

        A transmission control block (TCB) is created and partially
        filled in with data from the OPEN command parameters.

        On an active OPEN command, the TCP will begin the procedure to
        synchronize (i.e., establish) the connection at once.

        The timeout, if present, permits the caller to set up a timeout
        for all data submitted to TCP.  If data is not successfully
        delivered to the destination within the timeout period, the TCP
        will abort the connection.  The present global default is five
        minutes.

        The TCP or some component of the operating system will verify
        the users authority to open a connection with the specified
        precedence or security/compartment.  The absence of precedence
        or security/compartment specification in the OPEN call indicates
        the default values must be used.

        TCP will accept incoming requests as matching only if the
        security/compartment information is exactly the same and only if
        the precedence is equal to or higher than the precedence
        requested in the OPEN call.

        The precedence for the connection is the higher of the values
        requested in the OPEN call and received from the incoming
        request, and fixed at that value for the life of the
        connection.Implementers may want to give the user control of
        this precedence negotiation.  For example, the user might be
        allowed to specify that the precedence must be exactly matched,
        or that any attempt to raise the precedence be confirmed by the
        user.

        A local connection name will be returned to the user by the TCP.
        The local connection name can then be used as a short hand term
        for the connection defined by the <local socket, foreign socket>
        pair.

      Send

        Format:  SEND (local connection name, buffer address, byte
        count, PUSH flag, URGENT flag [,timeout])

        This call causes the data contained in the indicated user buffer
        to be sent on the indicated connection.  If the connection has
        not been opened, the SEND is considered an error.  Some
        implementations may allow users to SEND first; in which case, an
        automatic OPEN would be done.  If the calling process is not
        authorized to use this connection, an error is returned.

        If the PUSH flag is set, the data must be transmitted promptly
        to the receiver, and the PUSH bit will be set in the last TCP
        segment created from the buffer.  If the PUSH flag is not set,
        the data may be combined with data from subsequent SENDs for
        transmission efficiency.

        If the URGENT flag is set, segments sent to the destination TCP
        will have the urgent pointer set.  The receiving TCP will signal
        the urgent condition to the receiving process if the urgent
        pointer indicates that data preceding the urgent pointer has not
        been consumed by the receiving process.  The purpose of urgent
        is to stimulate the receiver to process the urgent data and to
        indicate to the receiver when all the currently known urgent
        data has been received.  The number of times the sending user's
        TCP signals urgent will not necessarily be equal to the number
        of times the receiving user will be notified of the presence of
        urgent data.

        If no foreign socket was specified in the OPEN, but the
        connection is established (e.g., because a LISTENing connection
        has become specific due to a foreign segment arriving for the
        local socket), then the designated buffer is sent to the implied
        foreign socket.  Users who make use of OPEN with an unspecified
        foreign socket can make use of SEND without ever explicitly
        knowing the foreign socket address.

        However, if a SEND is attempted before the foreign socket
        becomes specified, an error will be returned.  Users can use the
        STATUS call to determine the status of the connection.  In some
        implementations the TCP may notify the user when an unspecified
        socket is bound.

        If a timeout is specified, the current user timeout for this
        connection is changed to the new one.

        In the simplest implementation, SEND would not return control to
        the sending process until either the transmission was complete
        or the timeout had been exceeded.  However, this simple method
        is both subject to deadlocks (for example, both sides of the
        connection might try to do SENDs before doing any RECEIVEs) and
        offers poor performance, so it is not recommended.  A more
        sophisticated implementation would return immediately to allow
        the process to run concurrently with network I/O, and,
        furthermore, to allow multiple SENDs to be in progress.
        Multiple SENDs are served in first come, first served order, so
        the TCP will queue those it cannot service immediately.

        We have implicitly assumed an asynchronous user interface in
        which a SEND later elicits some kind of SIGNAL or
        pseudo-interrupt from the serving TCP.  An alternative is to
        return a response immediately.  For instance, SENDs might return
        immediate local acknowledgment, even if the segment sent had not
        been acknowledged by the distant TCP.  We could optimistically
        assume eventual success.  If we are wrong, the connection will
        close anyway due to the timeout.  In implementations of this
        kind (synchronous), there will still be some asynchronous
        signals, but these will deal with the connection itself, and not
        with specific segments or buffers.

        In order for the process to distinguish among error or success
        indications for different SENDs, it might be appropriate for the
        buffer address to be returned along with the coded response to
        the SEND request.  TCP-to-user signals are discussed below,
        indicating the information which should be returned to the
        calling process.

      Receive

        Format:  RECEIVE (local connection name, buffer address, byte
        count) -> byte count, urgent flag, push flag

        This command allocates a receiving buffer associated with the
        specified connection.  If no OPEN precedes this command or the
        calling process is not authorized to use this connection, an
        error is returned.

        In the simplest implementation, control would not return to the
        calling program until either the buffer was filled, or some
        error occurred, but this scheme is highly subject to deadlocks.
        A more sophisticated implementation would permit several
        RECEIVEs to be outstanding at once.  These would be filled as
        segments arrive.  This strategy permits increased throughput at
        the cost of a more elaborate scheme (possibly asynchronous) to
        notify the calling program that a PUSH has been seen or a buffer
        filled.

        If enough data arrive to fill the buffer before a PUSH is seen,
        the PUSH flag will not be set in the response to the RECEIVE.
        The buffer will be filled with as much data as it can hold.  If
        a PUSH is seen before the buffer is filled the buffer will be
        returned partially filled and PUSH indicated.

        If there is urgent data the user will have been informed as soon
        as it arrived via a TCP-to-user signal.  The receiving user
        should thus be in "urgent mode".  If the URGENT flag is on,
        additional urgent data remains.  If the URGENT flag is off, this
        call to RECEIVE has returned all the urgent data, and the user
        may now leave "urgent mode".  Note that data following the
        urgent pointer (non-urgent data) cannot be delivered to the user
        in the same buffer with preceeding urgent data unless the
        boundary is clearly marked for the user.

        To distinguish among several outstanding RECEIVEs and to take
        care of the case that a buffer is not completely filled, the
        return code is accompanied by both a buffer pointer and a byte
        count indicating the actual length of the data received.

        Alternative implementations of RECEIVE might have the TCP
        allocate buffer storage, or the TCP might share a ring buffer
        with the user.

      Close

        Format:  CLOSE (local connection name)

        This command causes the connection specified to be closed.  If
        the connection is not open or the calling process is not
        authorized to use this connection, an error is returned.
        Closing connections is intended to be a graceful operation in
        the sense that outstanding SENDs will be transmitted (and
        retransmitted), as flow control permits, until all have been
        serviced.  Thus, it should be acceptable to make several SEND
        calls, followed by a CLOSE, and expect all the data to be sent
        to the destination.  It should also be clear that users should
        continue to RECEIVE on CLOSING connections, since the other side
        may be trying to transmit the last of its data.  Thus, CLOSE
        means "I have no more to send" but does not mean "I will not
        receive any more."  It may happen (if the user level protocol is
        not well thought out) that the closing side is unable to get rid
        of all its data before timing out.  In this event, CLOSE turns
        into ABORT, and the closing TCP gives up.

        The user may CLOSE the connection at any time on his own
        initiative, or in response to various prompts from the TCP
        (e.g., remote close executed, transmission timeout exceeded,
        destination inaccessible).

        Because closing a connection requires communication with the
        foreign TCP, connections may remain in the closing state for a
        short time.  Attempts to reopen the connection before the TCP
        replies to the CLOSE command will result in error responses.

        Close also implies push function.

      Status

        Format:  STATUS (local connection name) -> status data

        This is an implementation dependent user command and could be
        excluded without adverse effect.  Information returned would
        typically come from the TCB associated with the connection.

        This command returns a data block containing the following
        information:

          local socket,
          foreign socket,
          local connection name,
          receive window,
          send window,
          connection state,
          number of buffers awaiting acknowledgment,
          number of buffers pending receipt,
          urgent state,
          precedence,
          security/compartment,
          and transmission timeout.

        Depending on the state of the connection, or on the
        implementation itself, some of this information may not be
        available or meaningful.  If the calling process is not
        authorized to use this connection, an error is returned.  This
        prevents unauthorized processes from gaining information about a
        connection.

      Abort

        Format:  ABORT (local connection name)

        This command causes all pending SENDs and RECEIVES to be
        aborted, the TCB to be removed, and a special RESET message to
        be sent to the TCP on the other side of the connection.
        Depending on the implementation, users may receive abort
        indications for each outstanding SEND or RECEIVE, or may simply
        receive an ABORT-acknowledgment.

    TCP-to-User Messages

      It is assumed that the operating system environment provides a
      means for the TCP to asynchronously signal the user program.  When
      the TCP does signal a user program, certain information is passed
      to the user.  Often in the specification the information will be
      an error message.  In other cases there will be information
      relating to the completion of processing a SEND or RECEIVE or
      other user call.

      The following information is provided:

        Local Connection Name                    Always
        Response String                          Always
        Buffer Address                           Send & Receive
        Byte count (counts bytes received)       Receive
        Push flag                                Receive
        Urgent flag                              Receive

  TCP/Lower-Level Interface

    The TCP calls on a lower level protocol module to actually send and
    receive information over a network.  One case is that of the ARPA
    internetwork system where the lower level module is the Internet
    Protocol (IP) [2].

    If the lower level protocol is IP it provides arguments for a type
    of service and for a time to live.  TCP uses the following settings
    for these parameters:

      Type of Service = Precedence: routine, Delay: normal, Throughput:
      normal, Reliability: normal; or 00000000.

      Time to Live    = one minute, or 00111100.

        Note that the assumed maximum segment lifetime is two minutes.
        Here we explicitly ask that a segment be destroyed if it cannot
        be delivered by the internet system within one minute.

    If the lower level is IP (or other protocol that provides this
    feature) and source routing is used, the interface must allow the
    route information to be communicated.  This is especially important
    so that the source and destination addresses used in the TCP
    checksum be the originating source and ultimate destination. It is
    also important to preserve the return route to answer connection
    requests.

    Any lower level protocol will have to provide the source address,
    destination address, and protocol fields, and some way to determine
    the "TCP length", both to provide the functional equivlent service
    of IP and to be used in the TCP checksum.

3.9.  Event Processing

  The processing depicted in this section is an example of one possible
  implementation.  Other implementations may have slightly different
  processing sequences, but they should differ from those in this
  section only in detail, not in substance.

  The activity of the TCP can be characterized as responding to events.
  The events that occur can be cast into three categories:  user calls,
  arriving segments, and timeouts.  This section describes the
  processing the TCP does in response to each of the events.  In many
  cases the processing required depends on the state of the connection.

    Events that occur:

      User Calls

        OPEN
        SEND
        RECEIVE
        CLOSE
        ABORT
        STATUS

      Arriving Segments

        SEGMENT ARRIVES

      Timeouts

        USER TIMEOUT
        RETRANSMISSION TIMEOUT
        TIME-WAIT TIMEOUT

  The model of the TCP/user interface is that user commands receive an
  immediate return and possibly a delayed response via an event or
  pseudo interrupt.  In the following descriptions, the term "signal"
  means cause a delayed response.

  Error responses are given as character strings.  For example, user
  commands referencing connections that do not exist receive "error:
  connection not open".

  Please note in the following that all arithmetic on sequence numbers,
  acknowledgment numbers, windows, et cetera, is modulo 2**32 the size
  of the sequence number space.  Also note that "=<" means less than or
  equal to (modulo 2**32).

  A natural way to think about processing incoming segments is to
  imagine that they are first tested for proper sequence number (i.e.,
  that their contents lie in the range of the expected "receive window"
  in the sequence number space) and then that they are generally queued
  and processed in sequence number order.

  When a segment overlaps other already received segments we reconstruct
  the segment to contain just the new data, and adjust the header fields
  to be consistent.

  Note that if no state change is mentioned the TCP stays in the same
  state.

  OPEN Call

    CLOSED STATE (i.e., TCB does not exist)

      Create a new transmission control block (TCB) to hold connection
      state information.  Fill in local socket identifier, foreign
      socket, precedence, security/compartment, and user timeout
      information.  Note that some parts of the foreign socket may be
      unspecified in a passive OPEN and are to be filled in by the
      parameters of the incoming SYN segment.  Verify the security and
      precedence requested are allowed for this user, if not return
      "error:  precedence not allowed" or "error:  security/compartment
      not allowed."  If passive enter the LISTEN state and return.  If
      active and the foreign socket is unspecified, return "error:
      foreign socket unspecified"; if active and the foreign socket is
      specified, issue a SYN segment.  An initial send sequence number
      (ISS) is selected.  A SYN segment of the form <SEQ=ISS><CTL=SYN>
      is sent.  Set SND.UNA to ISS, SND.NXT to ISS+1, enter SYN-SENT
      state, and return.

      If the caller does not have access to the local socket specified,
      return "error:  connection illegal for this process".  If there is
      no room to create a new connection, return "error:  insufficient
      resources".

    LISTEN STATE

      If active and the foreign socket is specified, then change the
      connection from passive to active, select an ISS.  Send a SYN
      segment, set SND.UNA to ISS, SND.NXT to ISS+1.  Enter SYN-SENT
      state.  Data associated with SEND may be sent with SYN segment or
      queued for transmission after entering ESTABLISHED state.  The
      urgent bit if requested in the command must be sent with the data
      segments sent as a result of this command.  If there is no room to
      queue the request, respond with "error:  insufficient resources".
      If Foreign socket was not specified, then return "error:  foreign
      socket unspecified".

    SYN-SENT STATE
    SYN-RECEIVED STATE
    ESTABLISHED STATE
    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE
    CLOSE-WAIT STATE
    CLOSING STATE
    LAST-ACK STATE
    TIME-WAIT STATE

      Return "error:  connection already exists".

  SEND Call

    CLOSED STATE (i.e., TCB does not exist)

      If the user does not have access to such a connection, then return
      "error:  connection illegal for this process".

      Otherwise, return "error:  connection does not exist".

    LISTEN STATE

      If the foreign socket is specified, then change the connection
      from passive to active, select an ISS.  Send a SYN segment, set
      SND.UNA to ISS, SND.NXT to ISS+1.  Enter SYN-SENT state.  Data
      associated with SEND may be sent with SYN segment or queued for
      transmission after entering ESTABLISHED state.  The urgent bit if
      requested in the command must be sent with the data segments sent
      as a result of this command.  If there is no room to queue the
      request, respond with "error:  insufficient resources".  If
      Foreign socket was not specified, then return "error:  foreign
      socket unspecified".

    SYN-SENT STATE
    SYN-RECEIVED STATE

      Queue the data for transmission after entering ESTABLISHED state.
      If no space to queue, respond with "error:  insufficient
      resources".

    ESTABLISHED STATE
    CLOSE-WAIT STATE

      Segmentize the buffer and send it with a piggybacked
      acknowledgment (acknowledgment value = RCV.NXT).  If there is
      insufficient space to remember this buffer, simply return "error:
      insufficient resources".

      If the urgent flag is set, then SND.UP <- SND.NXT-1 and set the
      urgent pointer in the outgoing segments.

    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE
    CLOSING STATE
    LAST-ACK STATE
    TIME-WAIT STATE

      Return "error:  connection closing" and do not service request.

  RECEIVE Call

    CLOSED STATE (i.e., TCB does not exist)

      If the user does not have access to such a connection, return
      "error:  connection illegal for this process".

      Otherwise return "error:  connection does not exist".

    LISTEN STATE
    SYN-SENT STATE
    SYN-RECEIVED STATE

      Queue for processing after entering ESTABLISHED state.  If there
      is no room to queue this request, respond with "error:
      insufficient resources".

    ESTABLISHED STATE
    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE

      If insufficient incoming segments are queued to satisfy the
      request, queue the request.  If there is no queue space to
      remember the RECEIVE, respond with "error:  insufficient
      resources".

      Reassemble queued incoming segments into receive buffer and return
      to user.  Mark "push seen" (PUSH) if this is the case.

      If RCV.UP is in advance of the data currently being passed to the
      user notify the user of the presence of urgent data.

      When the TCP takes responsibility for delivering data to the user
      that fact must be communicated to the sender via an
      acknowledgment.  The formation of such an acknowledgment is
      described below in the discussion of processing an incoming
      segment.

    CLOSE-WAIT STATE

      Since the remote side has already sent FIN, RECEIVEs must be
      satisfied by text already on hand, but not yet delivered to the
      user.  If no text is awaiting delivery, the RECEIVE will get a
      "error:  connection closing" response.  Otherwise, any remaining
      text can be used to satisfy the RECEIVE.

    CLOSING STATE
    LAST-ACK STATE
    TIME-WAIT STATE

      Return "error:  connection closing".

  CLOSE Call

    CLOSED STATE (i.e., TCB does not exist)

      If the user does not have access to such a connection, return
      "error:  connection illegal for this process".

      Otherwise, return "error:  connection does not exist".

    LISTEN STATE

      Any outstanding RECEIVEs are returned with "error:  closing"
      responses.  Delete TCB, enter CLOSED state, and return.

    SYN-SENT STATE

      Delete the TCB and return "error:  closing" responses to any
      queued SENDs, or RECEIVEs.

    SYN-RECEIVED STATE

      If no SENDs have been issued and there is no pending data to send,
      then form a FIN segment and send it, and enter FIN-WAIT-1 state;
      otherwise queue for processing after entering ESTABLISHED state.

    ESTABLISHED STATE

      Queue this until all preceding SENDs have been segmentized, then
      form a FIN segment and send it.  In any case, enter FIN-WAIT-1
      state.

    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE

      Strictly speaking, this is an error and should receive a "error:
      connection closing" response.  An "ok" response would be
      acceptable, too, as long as a second FIN is not emitted (the first
      FIN may be retransmitted though).

    CLOSE-WAIT STATE

      Queue this request until all preceding SENDs have been
      segmentized; then send a FIN segment, enter CLOSING state.

    CLOSING STATE
    LAST-ACK STATE
    TIME-WAIT STATE

      Respond with "error:  connection closing".

  ABORT Call

    CLOSED STATE (i.e., TCB does not exist)

      If the user should not have access to such a connection, return
      "error:  connection illegal for this process".

      Otherwise return "error:  connection does not exist".

    LISTEN STATE

      Any outstanding RECEIVEs should be returned with "error:
      connection reset" responses.  Delete TCB, enter CLOSED state, and
      return.

    SYN-SENT STATE

      All queued SENDs and RECEIVEs should be given "connection reset"
      notification, delete the TCB, enter CLOSED state, and return.

    SYN-RECEIVED STATE
    ESTABLISHED STATE
    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE
    CLOSE-WAIT STATE

      Send a reset segment:

        <SEQ=SND.NXT><CTL=RST>

      All queued SENDs and RECEIVEs should be given "connection reset"
      notification; all segments queued for transmission (except for the
      RST formed above) or retransmission should be flushed, delete the
      TCB, enter CLOSED state, and return.

    CLOSING STATE
    LAST-ACK STATE
    TIME-WAIT STATE

      Respond with "ok" and delete the TCB, enter CLOSED state, and
      return.

  STATUS Call

    CLOSED STATE (i.e., TCB does not exist)

      If the user should not have access to such a connection, return
      "error:  connection illegal for this process".

      Otherwise return "error:  connection does not exist".

    LISTEN STATE

      Return "state = LISTEN", and the TCB pointer.

    SYN-SENT STATE

      Return "state = SYN-SENT", and the TCB pointer.

    SYN-RECEIVED STATE

      Return "state = SYN-RECEIVED", and the TCB pointer.

    ESTABLISHED STATE

      Return "state = ESTABLISHED", and the TCB pointer.

    FIN-WAIT-1 STATE

      Return "state = FIN-WAIT-1", and the TCB pointer.

    FIN-WAIT-2 STATE

      Return "state = FIN-WAIT-2", and the TCB pointer.

    CLOSE-WAIT STATE

      Return "state = CLOSE-WAIT", and the TCB pointer.

    CLOSING STATE

      Return "state = CLOSING", and the TCB pointer.

    LAST-ACK STATE

      Return "state = LAST-ACK", and the TCB pointer.

    TIME-WAIT STATE

      Return "state = TIME-WAIT", and the TCB pointer.

  SEGMENT ARRIVES

    If the state is CLOSED (i.e., TCB does not exist) then

      all data in the incoming segment is discarded.  An incoming
      segment containing a RST is discarded.  An incoming segment not
      containing a RST causes a RST to be sent in response.  The
      acknowledgment and sequence field values are selected to make the
      reset sequence acceptable to the TCP that sent the offending
      segment.

      If the ACK bit is off, sequence number zero is used,

        <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>

      If the ACK bit is on,

        <SEQ=SEG.ACK><CTL=RST>

      Return.

    If the state is LISTEN then

      first check for an RST

        An incoming RST should be ignored.  Return.

      second check for an ACK

        Any acknowledgment is bad if it arrives on a connection still in
        the LISTEN state.  An acceptable reset segment should be formed
        for any arriving ACK-bearing segment.  The RST should be
        formatted as follows:

          <SEQ=SEG.ACK><CTL=RST>

        Return.

      third check for a SYN

        If the SYN bit is set, check the security.  If the
        security/compartment on the incoming segment does not exactly
        match the security/compartment in the TCB then send a reset and
        return.

          <SEQ=SEG.ACK><CTL=RST>

        If the SEG.PRC is greater than the TCB.PRC then if allowed by
        the user and the system set TCB.PRC<-SEG.PRC, if not allowed
        send a reset and return.

          <SEQ=SEG.ACK><CTL=RST>

        If the SEG.PRC is less than the TCB.PRC then continue.

        Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ and any other
        control or text should be queued for processing later.  ISS
        should be selected and a SYN segment sent of the form:

          <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>

        SND.NXT is set to ISS+1 and SND.UNA to ISS.  The connection
        state should be changed to SYN-RECEIVED.  Note that any other
        incoming control or data (combined with SYN) will be processed
        in the SYN-RECEIVED state, but processing of SYN and ACK should
        not be repeated.  If the listen was not fully specified (i.e.,
        the foreign socket was not fully specified), then the
        unspecified fields should be filled in now.

      fourth other text or control

        Any other control or text-bearing segment (not containing SYN)
        must have an ACK and thus would be discarded by the ACK
        processing.  An incoming RST segment could not be valid, since
        it could not have been sent in response to anything sent by this
        incarnation of the connection.  So you are unlikely to get here,
        but if you do, drop the segment, and return.

    If the state is SYN-SENT then

      first check the ACK bit

        If the ACK bit is set

          If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send a reset (unless
          the RST bit is set, if so drop the segment and return)

            <SEQ=SEG.ACK><CTL=RST>

          and discard the segment.  Return.

          If SND.UNA =< SEG.ACK =< SND.NXT then the ACK is acceptable.

      second check the RST bit

        If the RST bit is set

          If the ACK was acceptable then signal the user "error:
          connection reset", drop the segment, enter CLOSED state,
          delete TCB, and return.  Otherwise (no ACK) drop the segment
          and return.

      third check the security and precedence

        If the security/compartment in the segment does not exactly
        match the security/compartment in the TCB, send a reset

          If there is an ACK

            <SEQ=SEG.ACK><CTL=RST>

          Otherwise

            <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>

        If there is an ACK

          The precedence in the segment must match the precedence in the
          TCB, if not, send a reset

            <SEQ=SEG.ACK><CTL=RST>

        If there is no ACK

          If the precedence in the segment is higher than the precedence
          in the TCB then if allowed by the user and the system raise
          the precedence in the TCB to that in the segment, if not
          allowed to raise the prec then send a reset.

            <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>

          If the precedence in the segment is lower than the precedence
          in the TCB continue.

        If a reset was sent, discard the segment and return.

      fourth check the SYN bit

        This step should be reached only if the ACK is ok, or there is
        no ACK, and it the segment did not contain a RST.

        If the SYN bit is on and the security/compartment and precedence
        are acceptable then, RCV.NXT is set to SEG.SEQ+1, IRS is set to
        SEG.SEQ.  SND.UNA should be advanced to equal SEG.ACK (if there
        is an ACK), and any segments on the retransmission queue which
        are thereby acknowledged should be removed.

        If SND.UNA > ISS (our SYN has been ACKed), change the connection
        state to ESTABLISHED, form an ACK segment

          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>

        and send it.  Data or controls which were queued for
        transmission may be included.  If there are other controls or
        text in the segment then continue processing at the sixth step
        below where the URG bit is checked, otherwise return.

        Otherwise enter SYN-RECEIVED, form a SYN,ACK segment

          <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>

        and send it.  If there are other controls or text in the
        segment, queue them for processing after the ESTABLISHED state
        has been reached, return.

      fifth, if neither of the SYN or RST bits is set then drop the
      segment and return.

    Otherwise,

    first check sequence number

      SYN-RECEIVED STATE
      ESTABLISHED STATE
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE
      CLOSE-WAIT STATE
      CLOSING STATE
      LAST-ACK STATE
      TIME-WAIT STATE

        Segments are processed in sequence.  Initial tests on arrival
        are used to discard old duplicates, but further processing is
        done in SEG.SEQ order.  If a segment's contents straddle the
        boundary between old and new, only the new parts should be
        processed.

        There are four cases for the acceptability test for an incoming
        segment:

        Segment Receive  Test
        Length  Window
        ------- -------  -------------------------------------------

           0       0     SEG.SEQ = RCV.NXT

           0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

          >0       0     not acceptable

          >0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
                      or RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND

        If the RCV.WND is zero, no segments will be acceptable, but
        special allowance should be made to accept valid ACKs, URGs and
        RSTs.

        If an incoming segment is not acceptable, an acknowledgment
        should be sent in reply (unless the RST bit is set, if so drop
        the segment and return):

          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>

        After sending the acknowledgment, drop the unacceptable segment
        and return.

        In the following it is assumed that the segment is the idealized
        segment that begins at RCV.NXT and does not exceed the window.
        One could tailor actual segments to fit this assumption by
        trimming off any portions that lie outside the window (including
        SYN and FIN), and only processing further if the segment then
        begins at RCV.NXT.  Segments with higher begining sequence
        numbers may be held for later processing.

    second check the RST bit,

      SYN-RECEIVED STATE

        If the RST bit is set

          If this connection was initiated with a passive OPEN (i.e.,
          came from the LISTEN state), then return this connection to
          LISTEN state and return.  The user need not be informed.  If
          this connection was initiated with an active OPEN (i.e., came
          from SYN-SENT state) then the connection was refused, signal
          the user "connection refused".  In either case, all segments
          on the retransmission queue should be removed.  And in the
          active OPEN case, enter the CLOSED state and delete the TCB,
          and return.

      ESTABLISHED
      FIN-WAIT-1
      FIN-WAIT-2
      CLOSE-WAIT

        If the RST bit is set then, any outstanding RECEIVEs and SEND
        should receive "reset" responses.  All segment queues should be
        flushed.  Users should also receive an unsolicited general
        "connection reset" signal.  Enter the CLOSED state, delete the
        TCB, and return.

      CLOSING STATE
      LAST-ACK STATE
      TIME-WAIT

        If the RST bit is set then, enter the CLOSED state, delete the
        TCB, and return.

    third check security and precedence

      SYN-RECEIVED

        If the security/compartment and precedence in the segment do not
        exactly match the security/compartment and precedence in the TCB
        then send a reset, and return.

      ESTABLISHED STATE

        If the security/compartment and precedence in the segment do not
        exactly match the security/compartment and precedence in the TCB
        then send a reset, any outstanding RECEIVEs and SEND should
        receive "reset" responses.  All segment queues should be
        flushed.  Users should also receive an unsolicited general
        "connection reset" signal.  Enter the CLOSED state, delete the
        TCB, and return.

      Note this check is placed following the sequence check to prevent
      a segment from an old connection between these ports with a
      different security or precedence from causing an abort of the
      current connection.

    fourth, check the SYN bit,

      SYN-RECEIVED
      ESTABLISHED STATE
      FIN-WAIT STATE-1
      FIN-WAIT STATE-2
      CLOSE-WAIT STATE
      CLOSING STATE
      LAST-ACK STATE
      TIME-WAIT STATE

        If the SYN is in the window it is an error, send a reset, any
        outstanding RECEIVEs and SEND should receive "reset" responses,
        all segment queues should be flushed, the user should also
        receive an unsolicited general "connection reset" signal, enter
        the CLOSED state, delete the TCB, and return.

        If the SYN is not in the window this step would not be reached
        and an ack would have been sent in the first step (sequence
        number check).

    fifth check the ACK field,

      if the ACK bit is off drop the segment and return

      if the ACK bit is on

        SYN-RECEIVED STATE

          If SND.UNA =< SEG.ACK =< SND.NXT then enter ESTABLISHED state
          and continue processing.

            If the segment acknowledgment is not acceptable, form a
            reset segment,

              <SEQ=SEG.ACK><CTL=RST>

            and send it.

        ESTABLISHED STATE

          If SND.UNA < SEG.ACK =< SND.NXT then, set SND.UNA <- SEG.ACK.
          Any segments on the retransmission queue which are thereby
          entirely acknowledged are removed.  Users should receive
          positive acknowledgments for buffers which have been SENT and
          fully acknowledged (i.e., SEND buffer should be returned with
          "ok" response).  If the ACK is a duplicate
          (SEG.ACK < SND.UNA), it can be ignored.  If the ACK acks
          something not yet sent (SEG.ACK > SND.NXT) then send an ACK,
          drop the segment, and return.

          If SND.UNA < SEG.ACK =< SND.NXT, the send window should be
          updated.  If (SND.WL1 < SEG.SEQ or (SND.WL1 = SEG.SEQ and
          SND.WL2 =< SEG.ACK)), set SND.WND <- SEG.WND, set
          SND.WL1 <- SEG.SEQ, and set SND.WL2 <- SEG.ACK.

          Note that SND.WND is an offset from SND.UNA, that SND.WL1
          records the sequence number of the last segment used to update
          SND.WND, and that SND.WL2 records the acknowledgment number of
          the last segment used to update SND.WND.  The check here
          prevents using old segments to update the window.

        FIN-WAIT-1 STATE

          In addition to the processing for the ESTABLISHED state, if
          our FIN is now acknowledged then enter FIN-WAIT-2 and continue
          processing in that state.

        FIN-WAIT-2 STATE

          In addition to the processing for the ESTABLISHED state, if
          the retransmission queue is empty, the user's CLOSE can be
          acknowledged ("ok") but do not delete the TCB.

        CLOSE-WAIT STATE

          Do the same processing as for the ESTABLISHED state.

        CLOSING STATE

          In addition to the processing for the ESTABLISHED state, if
          the ACK acknowledges our FIN then enter the TIME-WAIT state,
          otherwise ignore the segment.

        LAST-ACK STATE

          The only thing that can arrive in this state is an
          acknowledgment of our FIN.  If our FIN is now acknowledged,
          delete the TCB, enter the CLOSED state, and return.

        TIME-WAIT STATE

          The only thing that can arrive in this state is a
          retransmission of the remote FIN.  Acknowledge it, and restart
          the 2 MSL timeout.

    sixth, check the URG bit,

      ESTABLISHED STATE
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE

        If the URG bit is set, RCV.UP <- max(RCV.UP,SEG.UP), and signal
        the user that the remote side has urgent data if the urgent
        pointer (RCV.UP) is in advance of the data consumed.  If the
        user has already been signaled (or is still in the "urgent
        mode") for this continuous sequence of urgent data, do not
        signal the user again.

      CLOSE-WAIT STATE
      CLOSING STATE
      LAST-ACK STATE
      TIME-WAIT

        This should not occur, since a FIN has been received from the
        remote side.  Ignore the URG.

    seventh, process the segment text,

      ESTABLISHED STATE
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE

        Once in the ESTABLISHED state, it is possible to deliver segment
        text to user RECEIVE buffers.  Text from segments can be moved
        into buffers until either the buffer is full or the segment is
        empty.  If the segment empties and carries an PUSH flag, then
        the user is informed, when the buffer is returned, that a PUSH
        has been received.

        When the TCP takes responsibility for delivering the data to the
        user it must also acknowledge the receipt of the data.

        Once the TCP takes responsibility for the data it advances
        RCV.NXT over the data accepted, and adjusts RCV.WND as
        apporopriate to the current buffer availability.  The total of
        RCV.NXT and RCV.WND should not be reduced.

        Please note the window management suggestions in section 3.7.

        Send an acknowledgment of the form:

          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>

        This acknowledgment should be piggybacked on a segment being
        transmitted if possible without incurring undue delay.

      CLOSE-WAIT STATE
      CLOSING STATE
      LAST-ACK STATE
      TIME-WAIT STATE

        This should not occur, since a FIN has been received from the
        remote side.  Ignore the segment text.

    eighth, check the FIN bit,

      Do not process the FIN if the state is CLOSED, LISTEN or SYN-SENT
      since the SEG.SEQ cannot be validated; drop the segment and
      return.

      If the FIN bit is set, signal the user "connection closing" and
      return any pending RECEIVEs with same message, advance RCV.NXT
      over the FIN, and send an acknowledgment for the FIN.  Note that
      FIN implies PUSH for any segment text not yet delivered to the
      user.

        SYN-RECEIVED STATE
        ESTABLISHED STATE

          Enter the CLOSE-WAIT state.

        FIN-WAIT-1 STATE

          If our FIN has been ACKed (perhaps in this segment), then
          enter TIME-WAIT, start the time-wait timer, turn off the other
          timers; otherwise enter the CLOSING state.

        FIN-WAIT-2 STATE

          Enter the TIME-WAIT state.  Start the time-wait timer, turn
          off the other timers.

        CLOSE-WAIT STATE

          Remain in the CLOSE-WAIT state.

        CLOSING STATE

          Remain in the CLOSING state.

        LAST-ACK STATE

          Remain in the LAST-ACK state.

        TIME-WAIT STATE

          Remain in the TIME-WAIT state.  Restart the 2 MSL time-wait
          timeout.

    and return.

  USER TIMEOUT

    For any state if the user timeout expires, flush all queues, signal
    the user "error:  connection aborted due to user timeout" in general
    and for any outstanding calls, delete the TCB, enter the CLOSED
    state and return.

  RETRANSMISSION TIMEOUT

    For any state if the retransmission timeout expires on a segment in
    the retransmission queue, send the segment at the front of the
    retransmission queue again, reinitialize the retransmission timer,
    and return.

  TIME-WAIT TIMEOUT

    If the time-wait timeout expires on a connection delete the TCB,
    enter the CLOSED state and return.

                                GLOSSARY



1822
          BBN Report 1822, "The Specification of the Interconnection of
          a Host and an IMP".  The specification of interface between a
          host and the ARPANET.

ACK
          A control bit (acknowledge) occupying no sequence space, which
          indicates that the acknowledgment field of this segment
          specifies the next sequence number the sender of this segment
          is expecting to receive, hence acknowledging receipt of all
          previous sequence numbers.

ARPANET message
          The unit of transmission between a host and an IMP in the
          ARPANET.  The maximum size is about 1012 octets (8096 bits).

ARPANET packet
          A unit of transmission used internally in the ARPANET between
          IMPs.  The maximum size is about 126 octets (1008 bits).

connection
          A logical communication path identified by a pair of sockets.

datagram
          A message sent in a packet switched computer communications
          network.

Destination Address
          The destination address, usually the network and host
          identifiers.

FIN
          A control bit (finis) occupying one sequence number, which
          indicates that the sender will send no more data or control
          occupying sequence space.

fragment
          A portion of a logical unit of data, in particular an internet
          fragment is a portion of an internet datagram.

FTP
          A file transfer protocol.

header
          Control information at the beginning of a message, segment,
          fragment, packet or block of data.

host
          A computer.  In particular a source or destination of messages
          from the point of view of the communication network.

Identification
          An Internet Protocol field.  This identifying value assigned
          by the sender aids in assembling the fragments of a datagram.

IMP
          The Interface Message Processor, the packet switch of the
          ARPANET.

internet address
          A source or destination address specific to the host level.

internet datagram
          The unit of data exchanged between an internet module and the
          higher level protocol together with the internet header.

internet fragment
          A portion of the data of an internet datagram with an internet
          header.

IP
          Internet Protocol.

IRS
          The Initial Receive Sequence number.  The first sequence
          number used by the sender on a connection.

ISN
          The Initial Sequence Number.  The first sequence number used
          on a connection, (either ISS or IRS).  Selected on a clock
          based procedure.

ISS
          The Initial Send Sequence number.  The first sequence number
          used by the sender on a connection.

leader
          Control information at the beginning of a message or block of
          data.  In particular, in the ARPANET, the control information
          on an ARPANET message at the host-IMP interface.

left sequence
          This is the next sequence number to be acknowledged by the
          data receiving TCP (or the lowest currently unacknowledged
          sequence number) and is sometimes referred to as the left edge
          of the send window.

local packet
          The unit of transmission within a local network.

module
          An implementation, usually in software, of a protocol or other
          procedure.

MSL
          Maximum Segment Lifetime, the time a TCP segment can exist in
          the internetwork system.  Arbitrarily defined to be 2 minutes.

octet
          An eight bit byte.

Options
          An Option field may contain several options, and each option
          may be several octets in length.  The options are used
          primarily in testing situations; for example, to carry
          timestamps.  Both the Internet Protocol and TCP provide for
          options fields.

packet
          A package of data with a header which may or may not be
          logically complete.  More often a physical packaging than a
          logical packaging of data.

port
          The portion of a socket that specifies which logical input or
          output channel of a process is associated with the data.

process
          A program in execution.  A source or destination of data from
          the point of view of the TCP or other host-to-host protocol.

PUSH
          A control bit occupying no sequence space, indicating that
          this segment contains data that must be pushed through to the
          receiving user.

RCV.NXT
          receive next sequence number

RCV.UP
          receive urgent pointer

RCV.WND
          receive window

receive next sequence number
          This is the next sequence number the local TCP is expecting to
          receive.

receive window
          This represents the sequence numbers the local (receiving) TCP
          is willing to receive.  Thus, the local TCP considers that
          segments overlapping the range RCV.NXT to
          RCV.NXT + RCV.WND - 1 carry acceptable data or control.
          Segments containing sequence numbers entirely outside of this
          range are considered duplicates and discarded.

RST
          A control bit (reset), occupying no sequence space, indicating
          that the receiver should delete the connection without further
          interaction.  The receiver can determine, based on the
          sequence number and acknowledgment fields of the incoming
          segment, whether it should honor the reset command or ignore
          it.  In no case does receipt of a segment containing RST give
          rise to a RST in response.

RTP
          Real Time Protocol:  A host-to-host protocol for communication
          of time critical information.

SEG.ACK
          segment acknowledgment

SEG.LEN
          segment length

SEG.PRC
          segment precedence value

SEG.SEQ
          segment sequence

SEG.UP
          segment urgent pointer field

SEG.WND
          segment window field

segment
          A logical unit of data, in particular a TCP segment is the
          unit of data transfered between a pair of TCP modules.

segment acknowledgment
          The sequence number in the acknowledgment field of the
          arriving segment.

segment length
          The amount of sequence number space occupied by a segment,
          including any controls which occupy sequence space.

segment sequence
          The number in the sequence field of the arriving segment.

send sequence
          This is the next sequence number the local (sending) TCP will
          use on the connection.  It is initially selected from an
          initial sequence number curve (ISN) and is incremented for
          each octet of data or sequenced control transmitted.

send window
          This represents the sequence numbers which the remote
          (receiving) TCP is willing to receive.  It is the value of the
          window field specified in segments from the remote (data
          receiving) TCP.  The range of new sequence numbers which may
          be emitted by a TCP lies between SND.NXT and
          SND.UNA + SND.WND - 1. (Retransmissions of sequence numbers
          between SND.UNA and SND.NXT are expected, of course.)

SND.NXT
          send sequence

SND.UNA
          left sequence

SND.UP
          send urgent pointer

SND.WL1
          segment sequence number at last window update

SND.WL2
          segment acknowledgment number at last window update

SND.WND
          send window

socket
          An address which specifically includes a port identifier, that
          is, the concatenation of an Internet Address with a TCP port.

Source Address
          The source address, usually the network and host identifiers.

SYN
          A control bit in the incoming segment, occupying one sequence
          number, used at the initiation of a connection, to indicate
          where the sequence numbering will start.

TCB
          Transmission control block, the data structure that records
          the state of a connection.

TCB.PRC
          The precedence of the connection.

TCP
          Transmission Control Protocol:  A host-to-host protocol for
          reliable communication in internetwork environments.

TOS
          Type of Service, an Internet Protocol field.

Type of Service
          An Internet Protocol field which indicates the type of service
          for this internet fragment.

URG
          A control bit (urgent), occupying no sequence space, used to
          indicate that the receiving user should be notified to do
          urgent processing as long as there is data to be consumed with
          sequence numbers less than the value indicated in the urgent
          pointer.

urgent pointer
          A control field meaningful only when the URG bit is on.  This
          field communicates the value of the urgent pointer which
          indicates the data octet associated with the sending user's
          urgent call.

                               REFERENCES



[1]  Cerf, V., and R. Kahn, "A Protocol for Packet Network
     Intercommunication", IEEE Transactions on Communications,
     Vol. COM-22, No. 5, pp 637-648, May 1974.

[2]  Postel, J. (ed.), "Internet Protocol - DARPA Internet Program
     Protocol Specification", RFC 791, USC/Information Sciences
     Institute, September 1981.

[3]  Dalal, Y. and C. Sunshine, "Connection Management in Transport
     Protocols", Computer Networks, Vol. 2, No. 6, pp. 454-473,
     December 1978.

[4]  Postel, J., "Assigned Numbers", RFC 790, USC/Information Sciences
     Institute, September 1981.
