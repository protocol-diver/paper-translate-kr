RFC: 793
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                              전송 제어 프로토콜
                                    
                                    
                         DARPA INTERNET PROGRAM
                                    
                                프로토콜 사양
                                    
                                    
                                    
                             September 1981













                              prepared for
                                    
               Defense Advanced Research Projects Agency
                Information Processing Techniques Office
                         1400 Wilson Boulevard
                       Arlington, Virginia  22209







                                   by

                     Information Sciences Institute
                   University of Southern California
                           4676 Admiralty Way
                   Marina del Rey, California  90291
                   
                                  목차

    머리말

1.  INTRODUCTION (소개)

  1.1  Motivation (동기)
  1.2  Scope (범위)
  1.3  About This Document (문서 정보)
  1.4  Interfaces (인터페이스)
  1.5  Operation (작업)

2.  PHILOSOPHY (철학)

  2.1  Elements of the Internetwork System
       (인터네트워크 시스템 요소)
  2.2  Model of Operation
       (운영 모델)
  2.3  The Host Environment
       (호스트 환경)
  2.4  Interfaces
       (인터페이스)
  2.5  Relation to Other Protocols
       (다른 프로토콜과의 관계)
  2.6  Reliable Communication
       (신뢰할 수 있는 통신)
  2.7  Connection Establishment and Clearing
       (연결 설정 및 삭제)
  2.8  Data Communication
       (데이터 통신)
  2.9  Precedence and Security
       (우선 순위 및 보안)
  2.10 Robustness Principle
       (견고성 원칙)

3.  FUNCTIONAL SPECIFICATION (기능 명세)

  3.1  Header Format
       (헤더 형식)
  3.2  Terminology
       (용어)
  3.3  Sequence Numbers
       (시퀀스 번호)
  3.4  Establishing a connection
       (연결 설정)
  3.5  Closing a Connection
       (연결 종료)
  3.6  Precedence and Security
       (우선 순위 및 보안)
  3.7  Data Communication
       (데이터 통신)
  3.8  Interfaces
       (인터페이스)
  3.9  Event Processing
       (이벤트 처리)

용어 사전

참조

                                 머리말



이 문서는 DoD 표준 전송 제어 프로토콜(TCP)에 대해 설명합니다. 이 표준의 기반이 되는 ARPA
TCP 사양의 이전 버전은 9개였으며 현재 텍스트는 이들에서 많은 부분을 가져옵니다. 개념과 텍스트
측면 모두에서 이 작업에 많은 기여자가 있었습니다. 이 에디션은 몇 가지 세부 사항을 명확히 하고
문자 끝 버퍼 크기 조정을 제거하고 문자 메커니즘을 푸시 기능으로 다시 설명합니다.

                                                           Jon Postel

                                                           Editor

RFC:  793
Replaces: RFC 761
IENs:  129, 124, 112, 81,
55, 44, 40, 27, 21, 5

                             전송 제어 프로토콜

                         DARPA INTERNET PROGRAM
                               프로토콜 사양



                         1.  INTRODUCTION (소개)

전송 제어 프로토콜(TCP)은 패킷 교환 컴퓨터 통신 네트워크와 이러한 네트워크의 상호 연결된
시스템에서 호스트 간에 매우 안정적인 호스트 간 프로토콜로 사용하기 위한 것입니다.

이 문서는 전송 제어 프로토콜이 수행하는 기능, 이를 구현하는 프로그램, 서비스를 필요로 하는
프로그램 또는 사용자에 대한 인터페이스에 대해 설명합니다.

1.1.  Motivation (동기)

[번역자 주석]
  - (dbadoy) DoD: Department of Defense (국방부)

  컴퓨터 통신 시스템은 군대, 정부 및 민간 환경에서 점점 더 중요한 역할을 하고 있습니다. 이
  문서는 주로 군용 컴퓨터 통신 요구 사항, 특히 통신 불안정성이 있는 경우의 견고성과 혼잡이
  있는 경우의 가용성에 초점을 맞추고 있지만 이러한 문제 중 많은 부분이 민간 및 정부 부문에서도
  발견됩니다.

  전략적 및 전술적 컴퓨터 통신 네트워크가 개발되고 배치됨에 따라 이를 상호 연결하는 수단을
  제공하고 광범위한 응용 프로그램을 지원할 수 있는 표준 프로세스 간 통신 프로토콜을 제공하는
  것이 필수적입니다. 이러한 표준의 필요성을 예상하여 국방부 연구 및 엔지니어링 차관은 여기에
  설명된 전송 제어 프로토콜(TCP)이 DoD 전체 프로세스 간 통신 프로토콜 표준화의 기초가 될
  것이라고 선언했습니다.

  TCP는 다중 네트워크 응용 프로그램을 지원하는 계층화된 프로토콜 계층 구조에 적합하도록 설계된
  연결 지향 종단 간 신뢰할 수 있는 프로토콜입니다. TCP는 별개이지만 상호 연결된 컴퓨터 통신
  네트워크에 연결된 호스트 컴퓨터의 프로세스 쌍 간에 안정적인 프로세스 간 통신을 제공합니다.
  TCP 계층 아래의 통신 프로토콜의 신뢰성에 대한 가정은 거의 없습니다. TCP는 하위 수준
  프로토콜에서 간단하고 잠재적으로 신뢰할 수 없는 데이터그램 서비스를 얻을 수 있다고 가정합니다.
  원칙적으로 TCP는 유선 연결에서 패킷 교환 또는 회선 교환 네트워크에 이르는 광범위한 통신
  시스템에서 작동할 수 있어야 합니다.

  TCP는 [1]에서 Cerf와 Kahn이 처음 설명한 개념을 기반으로 합니다. TCP는 TCP가 인터넷
  데이터그램 "envelopes"에 포함된 정보의 가변 길이 세그먼트를 송수신하는 방법을 제공하는
  기본 인터넷 프로토콜[2] 바로 위의 계층화된 프로토콜 아키텍처에 적합합니다. 인터넷
  데이터그램은 서로 다른 네트워크에서 송신자 및 수신자 TCP의 주소를 지정하는 수단을 제공합니다.
  인터넷 프로토콜은 또한 여러 네트워크와 상호 연결 게이트웨이를 통해 전송 및 전달을 달성하는
  데 필요한 TCP 세그먼트의 조각화 또는 재조립을 처리합니다. 인터넷 프로토콜은 또한 TCP
  세그먼트의 우선 순위, 보안 분류 및 구획에 대한 정보를 전달하므로 이 정보는 여러 네트워크에서
  엔드 투 엔드로 전달될 수 있습니다.

                           Protocol Layering

                        +---------------------+
                        |     higher-level    |
                        +---------------------+
                        |        TCP          |
                        +---------------------+
                        |  internet protocol  |
                        +---------------------+
                        |communication network|
                        +---------------------+

                                그림 1

  이 문서의 대부분은 호스트 컴퓨터에서 더 높은 수준의 프로토콜과 함께 상주하는 TCP 구현의
  맥락에서 작성되었습니다. 일부 컴퓨터 시스템은 TCP 및 인터넷 프로토콜 계층과 네트워크별
  소프트웨어를 수용하는 프런트 엔드 컴퓨터를 통해 네트워크에 연결됩니다. TCP 사양은 적절한
  호스트-프론트 엔드 프로토콜이 구현되는 한 프런트 엔드 경우에도 구현 가능한 것으로 보이는 상위
  수준 프로토콜에 대한 인터페이스를 설명합니다.

1.2.  Scope (범위)

  TCP는 다중 네트워크 환경에서 안정적인 프로세스 간 통신 서비스를 제공하기 위한 것입니다.
  TCP는 여러 네트워크에서 일반적으로 사용되는 호스트 간 프로토콜입니다.

1.3.  About this Document (문서 정보)

  이 문서는 상위 수준 프로토콜과의 상호 작용 및 다른 TCP와의 상호 작용 모두에서 TCP 구현에
  필요한 동작 사양을 나타냅니다. 이 섹션의 나머지 부분에서는 프로토콜 인터페이스 및 작업에 대한
  매우 간략한 보기를 제공합니다. 섹션 2에서는 TCP 설계의 철학적 기반을 요약합니다. 섹션
  3에서는 다양한 이벤트(새 세그먼트 도착, 사용자 호출, 오류 등)가 발생할 때 TCP에 필요한
  조치에 대한 자세한 설명과 TCP 세그먼트의 형식에 대한 세부 정보를 모두 제공합니다.

1.4.  Interfaces (인터페이스)

  TCP는 한쪽에서 사용자 또는 응용 프로그램 프로세스에 연결하고 다른 쪽에서 인터넷 프로토콜과
  같은 하위 수준 프로토콜에 연결합니다.

  애플리케이션 프로세스와 TCP 사이의 인터페이스는 합리적으로 자세히 설명되어 있습니다. 이
  인터페이스는 운영 체제가 파일 조작을 위해 응용 프로그램 프로세스에 제공하는 호출과 매우 유사한
  일련의 호출로 구성됩니다. 예를 들어 연결을 열고 닫고 설정된 연결에서 데이터를 보내고 받는
  호출이 있습니다. 또한 TCP가 애플리케이션 프로그램과 비동기식으로 통신할 수 있을 것으로
  예상됩니다. 특정 운영 체제 환경에 적합한 인터페이스를 설계하기 위해 TCP 구현자에게 상당한
  자유가 허용되지만 유효한 구현을 위해 TCP/사용자 인터페이스에는 최소한의 기능이 필요합니다.

  TCP와 하위 수준 프로토콜 간의 인터페이스는 기본적으로 두 수준이 서로 정보를 비동기적으로
  전달할 수 있는 메커니즘이 있다고 가정하는 것을 제외하고는 지정되지 않습니다. 일반적으로 이
  인터페이스를 지정하는 하위 수준 프로토콜을 기대합니다. TCP는 상호 연결된 네트워크의 매우
  일반적인 환경에서 작동하도록 설계되었습니다. 이 문서 전체에서 가정되는 하위 수준 프로토콜은
  Internet Protocol[2]입니다.

1.5.  Operation (작업)

  위에서 언급한 바와 같이 TCP의 주요 목적은 신뢰할 수 있고 안전한 논리 회로 또는 프로세스 쌍
  간의 연결 서비스를 제공하는 것입니다. 신뢰성이 낮은 인터넷 통신 시스템 위에서 이 서비스를
  제공하려면 다음 영역의 시설이 필요합니다:

    Basic Data Transfer (기본 데이터 전송)
    Reliability (신뢰성)
    Flow Control (흐름 제어)
    Multiplexing (다중화)
    Connections (연결)
    Precedence and Security (우선 순위 및 보안)

  이러한 각 영역에서 TCP의 기본 작동은 다음 단락에 설명되어 있습니다.

  Basic Data Transfer (기본 데이터 전송):

    TCP는 인터넷 시스템을 통한 전송을 위해 몇 개의 옥텟을 세그먼트로 패키징하여 사용자 간에
    각 방향으로 연속적인 옥텟 스트림을 전송할 수 있습니다. 일반적으로 TCP는 자신의 편의에
    따라 데이터를 차단하고 전달할 시기를 결정합니다.

    때때로 사용자는 TCP에 제출한 모든 데이터가 전송되었는지 확인해야 합니다. 이를 위해 푸시
    기능이 정의됩니다. TCP에 제출된 데이터가 실제로 전송되도록 하기 위해 보내는 사용자는
    데이터를 받는 사용자에게 푸시해야 함을 나타냅니다. 푸시는 TCP가 해당 지점까지의 데이터를
    수신자에게 즉시 전달하고 전달하도록 합니다. 정확한 푸시 지점은 수신 사용자에게 표시되지
    않을 수 있으며 푸시 기능은 레코드 경계 마커를 제공하지 않습니다.

  Reliability (신뢰성):

    TCP는 인터넷 통신 시스템에 의해 손상, 손실, 복제 또는 순서 없이 전달된 데이터로부터
    복구해야 합니다. 이는 전송된 각 옥텟에 시퀀스 번호를 할당하고 수신 TCP에서 긍정적인
    승인(ACK)을 요구함으로써 달성됩니다. 시간 초과 간격 내에 ACK를 받지 못하면 데이터가
    다시 전송됩니다. 수신기에서 시퀀스 번호는 잘못된 순서로 수신될 수 있는 세그먼트를 올바르게
    정렬하고 중복을 제거하는 데 사용됩니다. 손상은 전송된 각 세그먼트에 체크섬을 추가하고
    수신자에서 확인하고 손상된 세그먼트를 버리는 방식으로 처리됩니다.

    TCP가 계속 제대로 작동하고 인터넷 시스템이 완전히 분할되지 않는 한 전송 오류는 올바른
    데이터 전달에 영향을 미치지 않습니다. TCP는 인터넷 통신 시스템 오류에서 복구합니다.

  Flow Control (흐름 제어):

    TCP는 수신자가 발신자가 보낸 데이터의 양을 제어할 수 있는 수단을 제공합니다. 이는
    성공적으로 수신된 마지막 세그먼트를 넘어 허용 가능한 시퀀스 번호의 범위를 나타내는 모든
    ACK와 함께 "윈도우"를 반환함으로써 달성됩니다. 윈도우는 발신자가 추가 허가를 받기
    전에 전송할 수 있는 허용된 옥텟 수를 나타냅니다.

  Multiplexing (다중화):

    단일 호스트 내의 많은 프로세스가 동시에 TCP 통신 기능을 사용할 수 있도록 하기 위해
    TCP는 각 호스트 내에 일련의 주소 또는 포트를 제공합니다. 인터넷 통신 계층의 네트워크 및
    호스트 주소와 연결되어 소켓을 형성합니다. 소켓 쌍은 각 연결을 고유하게 식별합니다. 즉,
    하나의 소켓을 여러 연결에서 동시에 사용할 수 있습니다.

    프로세스에 대한 포트 바인딩은 각 호스트에서 독립적으로 처리됩니다. 그러나 대중에게 알려진
    고정 소켓에 자주 사용되는 프로세스(예: "logger" 또는 시분할 서비스)를 연결하는 것이
    유용합니다. 그런 다음 알려진 주소를 통해 이러한 서비스에 액세스할 수 있습니다. 다른
    프로세스의 포트 주소를 설정하고 학습하려면 보다 동적인 메커니즘이 필요할 수 있습니다.

  Connections (연결):

    위에서 설명한 안정성 및 흐름 제어 메커니즘은 TCP가 각 데이터 스트림에 대한 특정 상태
    정보를 초기화하고 유지 관리할 것을 요구합니다. 소켓, 시퀀스 번호 및 윈도우 크기가
    포함된 이 정보의 조합을 연결(connection)이라고 합니다. 각 연결은 양쪽을 식별하는
    한 쌍의 소켓으로 고유하게 지정됩니다.

    두 프로세스가 통신하려면 TCP가 먼저 연결을 설정해야 합니다(양쪽에서 상태 정보 초기화).
    통신이 완료되면 연결이 종료되거나 종료되어 리소스를 다른 용도로 사용할 수 있습니다.

    신뢰할 수 없는 호스트 간에 그리고 신뢰할 수 없는 인터넷 통신 시스템을 통해 연결을
    설정해야 하므로 잘못된 연결 초기화를 방지하기 위해 시계-기반 시퀀스 번호가 있는
    핸드셰이크 메커니즘이 사용됩니다.

  Precedence and Security (우선 순위 및 보안):

    TCP 사용자는 통신의 보안 및 우선 순위를 나타낼 수 있습니다. 이러한 기능이 필요하지 않을
    때 사용할 기본값이 제공됩니다.

                             2.  PHILOSOPHY (철학)

2.1.  Elements of the Internetwork System (인터네트워크 시스템 요소)

  인터네트워크 환경은 게이트웨이를 통해 상호 연결된 네트워크에 연결된 호스트로 구성됩니다.
  여기서 네트워크는 로컬 네트워크(예: ETHERNET) 또는 대규모 네트워크(예: ARPANET)일 수
  있지만 어떤 경우든 패킷 교환 기술을 기반으로 한다고 가정합니다. 메시지를 생성하고 소비하는
  활성 에이전트는 프로세스입니다. 네트워크, 게이트웨이 및 호스트의 다양한 수준의 프로토콜은
  프로세스 포트 간의 논리적 연결에서 양방향 데이터 흐름을 제공하는 프로세스 간 통신 시스템을
  지원합니다.

  여기서 패킷이라는 용어는 일반적으로 호스트와 해당 네트워크 간의 하나의 트랜잭션 데이터를
  의미하는 데 사용됩니다. 네트워크 내에서 교환되는 데이터 블록의 형식은 일반적으로 우리에게
  중요하지 않습니다.

  호스트는 네트워크에 연결된 컴퓨터이며 통신 네트워크의 관점에서 보면 패킷의 송신지와
  목적지입니다. 프로세스는 호스트 컴퓨터에서 활성 요소로 간주됩니다(프로세스를 실행 중인
  프로그램으로 정의하는 일반적인 정의에 따름). 터미널과 파일 또는 기타 I/O 장치도 프로세스를
  사용하여 서로 통신하는 것으로 간주됩니다. 따라서 모든 통신은 프로세스 간 통신으로
  간주됩니다.

  프로세스는 자신과 다른 프로세스(또는 프로세스) 사이의 여러 통신 스트림을 구별해야 할 수
  있으므로 각 프로세스에는 다른 프로세스의 포트와 통신하는 데 사용되는 여러 포트가 있을 수
  있다고 가정합니다.

2.2.  Model of Operation (운영 모델)

  프로세스는 TCP를 호출하고 데이터 버퍼를 인수로 전달하여 데이터를 전송합니다. TCP는 이러한
  버퍼의 데이터를 세그먼트로 패키징하고 인터넷 모듈을 호출하여 각 세그먼트를 대상 TCP로
  전송합니다. 수신 TCP는 세그먼트의 데이터를 수신 사용자의 버퍼에 놓고 수신 사용자에게
  알립니다. TCP는 신뢰할 수 있는 데이터 전송 순서를 보장하기 위해 사용하는 세그먼트에 제어
  정보를 포함합니다.

  인터넷 통신 모델은 로컬 네트워크에 인터페이스를 제공하는 각 TCP와 연결된 인터넷 프로토콜
  모듈이 있다는 것입니다. 이 인터넷 모듈은 인터넷 데이터그램 내부의 TCP 세그먼트를 패키징하고
  이러한 데이터그램을 대상 인터넷 모듈 또는 중간 게이트웨이로 라우팅합니다. 로컬 네트워크를
  통해 데이터그램을 전송하기 위해 로컬 네트워크 패킷에 포함됩니다.

  패킷 스위치는 로컬 패킷을 목적지 인터넷 모듈로 전달하기 위해 추가 패키징, 단편화 또는 기타
  작업을 수행할 수 있습니다.

  네트워크 사이의 게이트웨이에서 인터넷 데이터그램은 로컬 패킷에서 "unwrapped"되고 인터넷
  데이터그램이 다음에 이동해야 하는 네트워크를 결정하기 위해 검사됩니다. 그런 다음 인터넷
  데이터그램은 다음 네트워크에 적합한 로컬 패킷으로 "wrapped"되어 다음 게이트웨이 또는 최종
  목적지로 라우팅됩니다.

  게이트웨이는 다음 네트워크를 통한 전송에 필요한 경우 인터넷 데이터그램을 더 작은 인터넷
  데이터그램 조각으로 분해할 수 있습니다. 이를 위해 게이트웨이는 일련의 인터넷 데이터그램을
  생성합니다; 각각 조각을 적재하고 있는. 조각은 후속 게이트웨이에서 더 작은 조각으로 더
  세분화될 수 있습니다. 인터넷 데이터그램 조각 형식은 대상 인터넷 모듈이 조각을 인터넷
  데이터그램으로 재조립할 수 있도록 설계되었습니다.

  대상 인터넷 모듈은 데이터그램에서 세그먼트를 풀고(필요한 경우 데이터그램을 재조립한 후)
  대상 TCP로 전달합니다.

  이 간단한 작업 모델은 많은 세부 사항을 얼버무립니다. 중요한 기능 중 하나는 서비스
  유형입니다. 이는 게이트웨이(또는 인터넷 모듈)에 정보를 제공하여 다음 네트워크 통과에 사용할
  서비스 매개변수를 선택하도록 안내합니다. 서비스 정보 유형에는 데이터그램의 우선 순위가
  포함됩니다. 데이터그램은 또한 보안 고려 사항과 데이터그램을 적절하게 분리하기 위해 다단계
  보안 환경에서 작동하는 호스트 및 게이트웨이를 허용하는 보안 정보를 전달할 수 있습니다.

2.3.  The Host Environment (호스트 환경)

  TCP는 운영 체제의 모듈로 간주됩니다. 사용자는 파일 시스템에 액세스하는 것처럼 TCP에
  액세스합니다. TCP는 예를 들어 데이터 구조를 관리하기 위해 다른 운영 체제 기능을 호출할 수
  있습니다. 네트워크에 대한 실제 인터페이스는 장치 드라이버 모듈에 의해 제어되는 것으로
  가정합니다. TCP는 네트워크 장치 드라이버를 직접 호출하지 않고 오히려 장치 드라이버를 호출할
  수 있는 인터넷 데이터그램 프로토콜 모듈을 호출합니다.

  TCP 메커니즘은 프런트 엔드 프로세서에서 TCP 구현을 배제하지 않습니다. 그러나 이러한
  구현에서 호스트-프론트 엔드 프로토콜은 이 문서에 설명된 TCP 사용자 인터페이스 유형을
  지원하는 기능을 제공해야 합니다.

2.4.  Interfaces (인터페이스)

  TCP/사용자 인터페이스는 연결을 열거나 닫거나, 데이터를 보내거나 받거나, 연결에 대한
  STATUS를 얻기 위해 TCP에서 사용자가 만든 호출을 제공합니다. 이러한 호출은 예를 들어 파일
  열기, 읽기 및 닫기 호출과 같이 운영 체제의 사용자 프로그램에서 발생하는 다른 호출과 같습니다.

  TCP/인터넷 인터페이스는 인터넷 시스템의 호스트에 있는 TCP 모듈로 지정된 데이터그램을
  송수신하기 위한 호출을 제공합니다. 이러한 호출에는 주소, 서비스 유형, 우선 순위, 보안 및
  기타 제어 정보를 전달하기 위한 매개 변수가 있습니다.

2.5.  Relation to Other Protocols (다른 프로토콜과의 관계)

  다음 다이어그램은 프로토콜 계층에서 TCP의 위치를 ​​보여줍니다:

                                    
       +------+ +-----+ +-----+       +-----+                    
       |Telnet| | FTP | |Voice|  ...  |     |  Application Level 
       +------+ +-----+ +-----+       +-----+                    
             |   |         |             |                       
            +-----+     +-----+       +-----+                    
            | TCP |     | RTP |  ...  |     |  Host Level        
            +-----+     +-----+       +-----+                    
               |           |             |                       
            +-------------------------------+                    
            |    Internet Protocol & ICMP   |  Gateway Level     
            +-------------------------------+                    
                           |                                     
              +---------------------------+                      
              |   Local Network Protocol  |    Network Level     
              +---------------------------+                      

                         Protocol Relationships

                                 그림 2.

  TCP가 더 높은 수준의 프로토콜을 효율적으로 지원할 수 있을 것으로 예상됩니다. ARPANET
  Telnet 또는 AUTODIN II THP와 같은 상위 수준 프로토콜을 TCP에 쉽게 인터페이스할 수
  있어야 합니다.

2.6.  Reliable Communication (신뢰할 수 있는 통신)

[번역자 주석]
  - (dbadoy) acknowledgment는 ack로 표현합니다.

  TCP 연결에서 전송된 데이터 스트림은 대상에서 순서대로 안정적으로 전달됩니다.

  전송은 시퀀스 번호와 ack(acknowledgments)를 사용하여 안정적으로 이루어집니다.
  개념적으로 데이터의 각 옥텟에는 시퀀스 번호가 할당됩니다. 세그먼트에 있는 데이터의 첫 번째
  옥텟의 시퀀스 번호는 해당 세그먼트와 함께 전송되며 세그먼트 시퀀스 번호라고 합니다.
  세그먼트는 또한 역방향 전송의 다음 예상 데이터 옥텟의 시퀀스 번호인 ack 번호를 전달합니다.
  TCP가 데이터가 포함된 세그먼트를 전송할 때 복사본을 재전송 대기열에 넣고 타이머를
  시작합니다. 해당 데이터에 대한 ack를 받으면 세그먼트가 대기열에서 삭제됩니다. 타이머가
  종료되기 전에 ack가 수신되지 않으면 세그먼트가 재전송됩니다.

  TCP의 ack는 데이터가 최종 사용자에게 전달되었음을 보장하지 않으며 수신 TCP가 이에 대한
  책임을 졌다는 것을 의미할 뿐입니다.

  TCP 사이의 데이터 흐름을 제어하기 위해 흐름 제어 메커니즘이 사용됩니다. 수신 TCP는 송신
  TCP에 "윈도우"를 보고합니다. 윈도우는 ack 번호로 시작하여 수신 TCP가 현재 수신할
  준비가 된 옥텟 수를 지정합니다.

2.7.  Connection Establishment and Clearing (연결 설정 및 삭제)

  TCP가 처리할 수 있는 별도의 데이터 스트림을 식별하기 위해 TCP는 포트 식별자를 제공합니다.
  포트 식별자는 각 TCP에 의해 독립적으로 선택되므로 고유하지 않을 수 있습니다. 각 TCP
  내에서 고유한 주소를 제공하기 위해 TCP를 식별하는 인터넷 주소를 포트 식별자와 연결하여 함께
  연결된 모든 네트워크에서 고유한 소켓을 만듭니다.

  연결은 끝에 있는 한 쌍의 소켓으로 완전히 지정됩니다. 로컬 소켓은 다른 외부 소켓에 대한 많은
  연결에 참여할 수 있습니다. 연결은 양방향으로 데이터를 전달하는 데 사용할 수 있습니다. 즉,
  "전이중"입니다.

  TCP는 선택에 따라 포트를 프로세스와 자유롭게 연결할 수 있습니다. 그러나 모든 구현에는 몇
  가지 기본 개념이 필요합니다. TCP가 어떤 방식으로든 "적절한" 프로세스와만 연관시키는 잘
  알려진 소켓이 있어야 합니다. 우리는 프로세스가 포트를 "소유"할 수 있고 프로세스가 소유한
  포트에서만 연결을 시작할 수 있다고 생각합니다. (소유권을 구현하는 수단은 로컬 문제이지만
  요청 포트 사용자 명령 또는 주어진 프로세스에 포트 그룹을 고유하게 할당하는 방법(예: 포트
  이름의 상위 비트를 주어진 프로세스와 연결)을 구상합니다.)

  연결은 로컬 포트 및 외부 소켓 인수에 의해 OPEN 호출에서 지정됩니다. 그 대가로 TCP는
  사용자가 후속 호출에서 연결을 참조하는 (짧은) 로컬 연결 이름을 제공합니다. 연결에 대해
  기억해야 할 몇 가지 사항이 있습니다. 이 정보를 저장하기 위해 TCB(Transmission
  Control Block)라는 데이터 구조가 있다고 가정합니다. 구현 전략 중 하나는 로컬 연결
  이름이 이 연결에 대한 TCB에 대한 포인터가 되도록 하는 것입니다. OPEN 호출은 또한 연결
  설정을 능동적(Active)으로 추구할지 또는 수동적(Passive)으로 기다릴지 여부를 지정합니다.

  Passive OPEN 요청은 프로세스가 연결을 시작하려고 시도하는 대신 들어오는
  연결 요청을 수락하려고 함을 의미합니다. 종종 Passive OPEN을 요청하는 프로세스는 모든
  호출자의 연결 요청을 수락합니다. 이 경우 모두 0인 외부 소켓이 지정되지 않은 소켓을
  나타내는 데 사용됩니다. 지정되지 않은 외부 소켓은 Passive OPEN에서만 허용됩니다.

  알 수 없는 다른 프로세스에 서비스를 제공하려는 서비스 프로세스는 지정되지 않은 외부 소켓을
  사용하여 Passive OPEN 요청을 발행합니다. 그런 다음 이 로컬 소켓에 대한 연결을 요청한
  모든 프로세스와 연결할 수 있습니다. 이 로컬 소켓이 이 서비스와 연관되어 있는 것으로 알려져
  있다면 도움이 될 것입니다.

  Well-known 소켓은 소켓 주소를 표준 서비스와 연관시키는 선험적인 메커니즘입니다. 예를 들어,
  "Telnet-Server" 프로세스는 특정 소켓에 영구적으로 할당되고 다른 소켓은 파일 전송, 원격
  작업 항목, 텍스트 생성기, Echoer 및 싱크 프로세스(마지막 3개는 테스트용임)용으로
  예약됩니다. 새로 생성된 서비스가 제공될 특정 소켓을 반환하는 "Look-Up" 서비스에 대한
  액세스를 위해 소켓 주소를 예약할 수 있습니다. Well-known 소켓의 개념은 TCP 사양의
  일부이지만 서비스에 대한 소켓 할당은 이 사양의 범위를 벗어납니다. ([4] 참조.)

  프로세스는 Passive OPEN을 발행하고 다른 프로세스에서 일치하는 Active OPEN을 기다릴 수
  있으며 연결이 설정되면 TCP에서 알립니다. 동시에 서로에게 Active OPEN을 발행하는 두
  프로세스가 올바르게 연결됩니다. 이러한 유연성은 구성 요소가 서로에 대해 비동기적으로 작동하는
  분산 컴퓨팅 지원에 매우 중요합니다.

  로컬 Passive OPEN과 외부 Active OPEN의 소켓을 일치시키는 두 가지 주요 사례가
  있습니다. 첫 번째 경우 로컬 Passive OPEN이 외부 소켓을 완전히 지정했습니다. 이 경우 일치
  항목이 정확해야 합니다. 두 번째 경우에는 로컬 Passive OPEN이 외부 소켓을 지정하지 않은
  상태로 둡니다. 이 경우 로컬 소켓이 일치하는 한 모든 외부 소켓이 허용됩니다. 다른 가능성에는
  부분적으로 제한된 일치가 포함됩니다.

  동일한 로컬 소켓을 사용하여 보류 중인 Passive OPEN(TCB에 기록됨)이 여러 개 있는 경우,
  외부 Acitve OPEN은 지정되지 않은 외부 소켓이 있는 TCB를 선택하기 전에 해당 TCB가
  존재하는 경우 외부 Active OPEN의 특정 외부 소켓이 있는 TCB와 일치합니다.

  연결을 설정하는 절차는 동기화(SYN) 제어 플래그를 활용하고 세 가지 메시지 교환을 포함합니다.
  이 교환을 3-way hand shake라고 합니다[3].

  사용자 OPEN 명령에 의해 각각 생성된 SYN 및 대기 TCB 항목을 포함하는 도착 세그먼트의
  랑데부에 의해 연결이 시작됩니다. 로컬 및 외부 소켓의 일치에 따라 연결이 시작된 시기가
  결정됩니다. 시퀀스 번호가 양방향으로 동기화되면 연결이 "설정(established)"됩니다.

  연결 해제에는 세그먼트 교환도 포함되며, 이 경우에는 FIN 제어 플래그를 전달합니다.

2.8.  Data Communication (데이터 통신)

  연결에서 흐르는 데이터는 옥텟의 스트림으로 생각할 수 있습니다. 보내는 사용자는 각 SEND 
  호출에서 해당 호출(및 선행 호출)의 데이터를 PUSH 플래그 설정을 통해 수신 사용자에게 즉시
  푸시해야 하는지 여부를 나타냅니다.

  보내는 TCP는 보내는 사용자로부터 데이터를 수집하고 푸시 기능이 신호를 받을 때까지 자체
  편의에 따라 해당 데이터를 세그먼트로 보낼 수 있으며 그런 다음 보내지 않은 모든 데이터를
  보내야 합니다. 수신 TCP가 PUSH 플래그를 볼 때 데이터를 수신 프로세스로 전달하기 전에 송신
  TCP에서 더 많은 데이터를 기다리면 안 됩니다.

  푸시 기능과 세그먼트 경계 간에는 필요한 관계가 없습니다. 특정 세그먼트의 데이터는 전체 또는
  일부 또는 여러 SEND 호출의 단일 SEND 호출 결과일 수 있습니다.

  푸시 기능과 PUSH 플래그의 목적은 송신 사용자에서 수신 사용자로 데이터를 푸시하는 것입니다.
  레코드 서비스를 제공하지 않습니다.

  푸시 기능과 TCP/사용자 인터페이스를 교차하는 데이터 버퍼 사용 사이에는 결합이 있습니다.
  PUSH 플래그가 수신 사용자의 버퍼에 배치된 데이터와 연결될 때마다 버퍼가 채워지지 않은
  경우에도 처리를 위해 버퍼가 사용자에게 반환됩니다. PUSH가 발생하기 전에 사용자의 버퍼를
  채우는 데이터가 도착하면 버퍼 크기 단위로 데이터가 사용자에게 전달됩니다.

  TCP는 또한 수신자가 현재 읽고 있는 것보다 데이터 스트림의 더 먼 지점에서 긴급 데이터가 있는
  데이터의 수신자와 통신할 수 있는 수단을 제공합니다. TCP는 보류 중인 긴급 데이터에 대한
  알림을 받았을 때 사용자가 구체적으로 수행하는 작업을 정의하려고 시도하지 않지만 일반적인
  개념은 수신 프로세스가 긴급 데이터를 신속하게 처리하기 위한 조치를 취하는 것입니다.

2.9.  Precedence and Security (우선 순위 및 보안)

  TCP는 인터넷 프로토콜 유형의 서비스 필드와 보안 옵션을 사용하여 TCP 사용자에게 연결별로
  우선 순위와 보안을 제공합니다. 모든 TCP 모듈이 다단계 보안 환경에서 반드시 작동하는 것은
  아닙니다; 일부는 분류되지 않은 사용으로만 제한될 수 있고 다른 일부는 하나의 보안 수준 및
  구획에서만 작동할 수 있습니다. 결과적으로 사용자에 대한 일부 TCP 구현 및 서비스는 다단계
  보안 사례의 하위 집합으로 제한될 수 있습니다.

  다단계 보안 환경에서 작동하는 TCP 모듈은 보안, 구획 및 우선 순위로 나가는 세그먼트를
  적절하게 표시해야 합니다. 이러한 TCP 모듈은 또한 사용자 또는 Telnet 또는 THP와 같은
  상위 수준 프로토콜에 원하는 보안 수준, 구획 및 연결 우선 순위를 지정할 수 있는 인터페이스를
  제공해야 합니다.

2.10.  Robustness Principle (견고성 원칙)

  TCP 구현은 견고성의 일반 원칙을 따릅니다: 즉, 자신이 하는 일에 있어서는 보수적이어야 하고
  다른 사람으로부터 받아들이는 것에 있어서는 자유로워야 합니다.

                      3.  FUNCTIONAL SPECIFICATION (기능 명세)

3.1.  Header Format (헤더 형식)

  TCP 세그먼트는 인터넷 데이터그램으로 전송됩니다. 인터넷 프로토콜 헤더는 송신자 및 수신자
  호스트 주소를 포함하여 여러 정보 필드를 전달합니다 [2]. TCP 헤더는 인터넷 헤더 다음에 TCP
  프로토콜에 특정한 정보를 제공합니다. 이러한 분할은 TCP 이외의 호스트 수준 프로토콜의 존재를
  허용합니다.

  TCP Header Format (TCP 헤더 형식)

                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    TCP Header Format (TCP 헤더 형식)

                  하나의 눈금 표시는 하나의 비트 위치를 나타냅니다.

                                  그림 3.

  Source Port:  16 bits

    송신자 포트 번호입니다.

  Destination Port:  16 bits

    수신자 포트 번호입니다.

  Sequence Number:  32 bits

    이 세그먼트에 있는 첫 번째 데이터 옥텟의 시퀀스 번호입니다(SYN이 있는 경우 제외).
    SYN이 있는 경우 시퀀스 번호는 초기 시퀀스 번호(Inintial Sequence Number)이고 첫
    번째 데이터 옥텟은 ISN+1입니다.

  Acknowledgment Number:  32 bits

    ACK 제어 비트가 설정되면 이 필드에는 세그먼트의 송신자가 수신할 것으로 예상되는 다음
    시퀀스 번호의 값이 포함됩니다. 연결이 설정되면 항상 전송됩니다.

  Data Offset:  4 bits

    TCP 헤더의 32비트 워드(word) 수입니다. 이것은 데이터가 시작되는 위치를 나타냅니다.
    TCP 헤더(옵션 포함)는 32비트 길이의 정수입니다.

  Reserved:  6 bits

    향후 사용을 위해 예약되었습니다. 반드시 0이어야 합니다.

  Control Bits:  6 bits (from left to right):

    URG:  Urgent Pointer field significant
    ACK:  Acknowledgment field significant
    PSH:  Push Function
    RST:  Reset the connection
    SYN:  Synchronize sequence numbers
    FIN:  No more data from sender

  Window:  16 bits

    이 세그먼트의 송신자가 수락할 의향이 있는 acknowledgment 필드에 표시된 것으로 시작하는
    데이터 옥텟의 수입니다.

  Checksum:  16 bits

    체크섬 필드는 헤더와 텍스트에 있는 모든 16비트 단어의 1의 보수 합계에 대한 16비트 1의
    보수입니다. 세그먼트에 체크섬을 계산할 홀수 개의 헤더 및 텍스트 옥텟이 포함된 경우 마지막
    옥텟의 오른쪽이 0으로 채워져 체크섬 목적을 위한 16비트 워드를 형성합니다. 패드는
    세그먼트의 일부로 전송되지 않습니다. 체크섬을 계산하는 동안 체크섬 필드 자체는 0으로
    대체됩니다.

    체크섬은 개념적으로 TCP 헤더에 접두사가 붙은 96비트 pseudo 헤더도 포함합니다. 이
    pseudo 헤더에는 송신자 주소, 수신자 주소, 프로토콜 및 TCP 길이가 포함됩니다. 이는
    잘못 라우팅된 세그먼트에 대한 TCP 보호를 제공합니다. 이 정보는 인터넷 프로토콜에서
    전달되며 IP에서 TCP에 의한 인수 또는 호출 결과로 TCP/네트워크 인터페이스를 통해
    전송됩니다.

                     +--------+--------+--------+--------+
                     |           Source Address          |
                     +--------+--------+--------+--------+
                     |         Destination Address       |
                     +--------+--------+--------+--------+
                     |  zero  |  PTCL  |    TCP Length   |
                     +--------+--------+--------+--------+

      TCP 길이는 TCP 헤더 길이에 옥텟 단위의 데이터 길이를 더한 값이며(이는 명시적으로
      전송된 양이 아니라 계산됨) pseudo 헤더의 12 옥텟은 계산하지 않습니다.

  Urgent Pointer:  16 bits

    이 필드는 Urgent Pointer의 현재 값을 이 세그먼트의 시퀀스 번호에서 양의 오프셋으로
    전달합니다. 긴급 포인터는 긴급 데이터 다음에 오는 옥텟의 시퀀스 번호를 가리킵니다. 이
    필드는 URG 제어 비트가 설정된 세그먼트에서만 해석됩니다.

  Options:  variable

    옵션은 TCP 헤더 끝에서 공간을 차지할 수 있으며 길이가 8비트의 배수입니다. 모든 옵션은
    체크섬에 포함됩니다. 옵션은 모든 옥텟 경계에서 시작할 수 있습니다. 옵션 형식에는 두 가지
    경우가 있습니다:

      Case 1:  옵션 종류의 단일 옥텟.

      Case 2:  옵션 종류의 옥텟, 옵션 길이의 옥텟 및 실제 옵션 데이터 옥텟.

    옵션 길이는 옵션 데이터 옥텟뿐만 아니라 옵션 종류 및 옵션 길이의 두 옥텟을 계산합니다.

    옵션 목록은 데이터 오프셋 필드가 의미하는 것보다 짧을 수 있습니다. End-of-Option
    옵션 이외의 헤더 내용은 헤더 패딩(예: 0)이어야 합니다.

    TCP는 모든 옵션을 반드시 구현해야 합니다.

    현재 정의된 옵션에는 다음이 포함됩니다(종류는 8진수로 표시됨):

      Kind     Length    Meaning
      ----     ------    -------
       0         -       End of option list.
       1         -       No-Operation.
       2         4       Maximum Segment Size.
      

    특정 옵션 정의

      End of Option List

        +--------+
        |00000000|
        +--------+
         Kind=0

        이 옵션 코드는 옵션 목록의 끝을 나타냅니다. 이것은 데이터 오프셋 필드에 따라 TCP
        헤더의 끝과 일치하지 않을 수 있습니다. 이것은 각 옵션의 끝이 아니라 모든 옵션의
        끝에서 사용되며 옵션의 끝이 TCP 헤더의 끝과 일치하지 않는 경우에만 사용해야 합니다.

      No-Operation

        +--------+
        |00000001|
        +--------+
         Kind=1

        이 옵션 코드는 예를 들어 wor 경계에서 후속 옵션의 시작을 정렬하기 위해 옵션 사이에
        사용될 수 있습니다. 발신자가 이 옵션을 사용한다는 보장이 없으므로 수신자는 word
        경계에서 시작하지 않더라도 옵션을 처리할 준비가 되어 있어야 합니다.

      Maximum Segment Size

        +--------+--------+---------+--------+
        |00000010|00000100|   max seg size   |
        +--------+--------+---------+--------+
         Kind=2   Length=4

        Maximum Segment Size Option Data:  16 bits

          이 옵션이 있으면 이 세그먼트를 보내는 TCP에서 최대 수신 세그먼트 크기를
          전달합니다. 이 필드는 초기 연결 요청에서만 전송되어야 합니다(즉, SYN 제어 비트가
          설정된 세그먼트에서). 이 옵션을 사용하지 않으면 모든 세그먼트 크기가 허용됩니다.

  Padding:  variable

    TCP 헤더 패딩은 TCP 헤더가 끝나고 데이터가 32비트 경계에서 시작되도록 하는 데
    사용됩니다. 패딩은 0으로 구성됩니다.

3.2.  Terminology (용어)

  TCP 작동에 대해 많은 논의를 하기 전에 몇 가지 자세한 용어를 소개해야 합니다. TCP 연결을
  유지하려면 여러 변수를 기억해야 합니다. 우리는 이러한 변수가 전송 제어 블록(TCB)이라는 연결
  레코드에 저장된다고 상상합니다. TCB에 저장된 변수 중에는 로컬 및 원격 소켓 번호, 연결의
  보안 및 우선 순위, 사용자의 송신 및 수신 버퍼에 대한 포인터, 재전송 큐 및 현재 세그먼트에
  대한 포인터가 있습니다. 또한 송신 및 수신 시퀀스 번호와 관련된 여러 변수가 TCB에 저장됩니다.

    Send Sequence Variables (시퀀스 변수 전송)

      SND.UNA - unacknowledged 전송
      SND.NXT - next 전송
      SND.WND - 윈도우 전송
      SND.UP  - urgent pointer 전송
      SND.WL1 - 마지막 윈도우 업데이트에 사용된 세그먼트 시퀀스 번호
      SND.WL2 - 마지막 윈도우 업데이트에 사용된 세그먼트 acknowledged 번호
      ISS     - 초기 전송 시퀀스 번호

    Receive Sequence Variables (시퀀스 변수 수신)

      RCV.NXT - next 수신
      RCV.WND - 윈도우 수신
      RCV.UP  - urgent pointer 수신
      IRS     - 초기 수신 시퀀스 번호

  다음 다이어그램은 이러한 변수 중 일부를 시퀀스 공간과 관련시키는 데 도움이 될 수 있습니다.

  Send Sequence Space (시퀀스 공간 전송)

                   1         2          3          4      
              ----------|----------|----------|---------- 
                     SND.UNA    SND.NXT    SND.UNA        
                                          +SND.WND        

        1 - 확인된 이전 시퀀스 번호
        2 - unacknowledged 데이터의 시퀀스 번호
        3 - 새로운 데이터 전송에 허용되는 시퀀스 번호
        4 - 아직 허용되지 않은 미래 시퀀스 번호

                              시퀀스 공간 전송

                                 그림 4.
    
    

  윈도우 전송은 그림 4에서 3으로 표시된 시퀀스 공간의 일부입니다.


  Receive Sequence Space (시퀀스 공간 수신)

                       1          2          3      
                   ----------|----------|---------- 
                          RCV.NXT    RCV.NXT        
                                    +RCV.WND        

        1 - acknowledged 받은 이전 시퀀스 번호
        2 - 새로운 수신에 허용되는 시퀀스 번호
        3 - 아직 허용되지 않은 미래 시퀀스 번호

                               시퀀스 공간 수신

                                   그림 5.
    
    

  윈도우 수신은 그림 5에서 2로 표시된 시퀀스 공간의 일부입니다.

  현재 세그먼트의 필드에서 값을 가져오는 토론에서 자주 사용되는 일부 변수도 있습니다.

    Current Segment Variables (현재 세그먼트 변수)

      SEG.SEQ - 세그먼트 시퀀스 번호
      SEG.ACK - 세그먼트 acknowledgment 번호
      SEG.LEN - 세그먼트 길이
      SEG.WND - 세그먼트 윈도우
      SEG.UP  - 세그먼트 urgent pointer
      SEG.PRC - 세그먼트 우선 순위 값

  연결은 수명 동안 일련의 상태를 통해 진행됩니다. 상태는 LISTEN, SYN-SENT,
  SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT,
  CLOSING, LAST-ACK, TIME-WAIT 및 가상 상태 CLOSED입니다. CLOSED는 TCB가 없고
  따라서 연결이 없는 상태를 나타내므로 허구입니다. 상태에 대한 간단한 의미는 다음과 같습니다:

    LISTEN - 원격 TCP 및 포트에서 연결 요청을 기다리는 것을 나타냅니다.

    SYN-SENT - 연결 요청을 보낸 후 일치하는 연결 요청을 기다리는 것을 나타냅니다.

    SYN-RECEIVED - 연결 요청을 수신하고 보낸 후 확인 연결 요청 확인을 기다리는 것을
    나타냅니다.

    ESTABLISHED - 열린 연결을 나타내며 수신된 데이터를 사용자에게 전달할 수 있습니다.
    연결의 데이터 전송 단계에 대한 정상 상태입니다.

    FIN-WAIT-1 - 원격 TCP의 연결 종료 요청을 기다리거나 이전에 보낸 연결 종료 요청에
    대한 확인을 나타냅니다.

    FIN-WAIT-2 - 원격 TCP의 연결 종료 요청을 기다리는 것을 나타냅니다.

    CLOSE-WAIT - 로컬 사용자의 연결 종료 요청을 기다리는 것을 나타냅니다.

    CLOSING - 원격 TCP의 연결 종료 요청 acknowledgment을 기다리는 것을 나타냅니다.

    LAST-ACK - 이전에 원격 TCP로 전송된 연결 종료 요청에 대한 확인(연결 종료 요청에 대한
    확인 포함)을 기다리는 것을 나타냅니다.

    TIME-WAIT - 원격 TCP가 연결 종료 요청에 대한 acknowledgment을 받았는지 확인하기
    위해 충분한 시간을 기다리는 것을 나타냅니다.

    CLOSED - 연결 상태가 전혀 없음을 나타냅니다.

  TCP 연결은 이벤트에 대한 응답으로 한 상태에서 다른 상태로 진행됩니다. 이벤트란 사용자가
  호출하는 OPEN, SEND, RECEIVE, CLOSE, ABORT 및 STATUS입니다; 들어오는 세그먼트,
  특히 SYN, ACK, RST 및 FIN 플래그을 포함하는 세그먼트; 그리고 타임아웃.

  그림 6의 상태 다이어그램은 원인 이벤트 및 결과 작업과 함께 상태 변경만 보여주지만 상태
  변경과 연결되지 않은 오류 조건이나 작업은 다루지 않습니다. 이후 섹션에서 이벤트에 대한
  TCP의 반응과 관련하여 더 자세한 내용이 제공됩니다.

  NOTE BENE:  이 다이어그램은 요약일 뿐이며 전체 사양으로 간주해서는 안 됩니다.
                                    
                              +---------+ ---------\      active OPEN  
                              |  CLOSED |            \    -----------  
                              +---------+<---------\   \   create TCB  
                                |     ^              \   \  snd SYN    
                   passive OPEN |     |   CLOSE        \   \           
                   ------------ |     | ----------       \   \         
                    create TCB  |     | delete TCB         \   \       
                                V     |                      \   \     
                              +---------+            CLOSE    |    \   
                              |  LISTEN |          ---------- |     |  
                              +---------+          delete TCB |     |  
                   rcv SYN      |     |     SEND              |     |  
                  -----------   |     |    -------            |     V  
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |<-----------------           ------------------>|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |<-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------                  
   |                  x         |     |     snd ACK                    
   |                            V     V                                
   |  CLOSE                   +---------+                              
   | -------                  |  ESTAB  |                              
   | snd FIN                  +---------+                              
   |                   CLOSE    |     |    rcv FIN                     
   V                  -------   |     |    -------                     
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |<-----------------           ------------------>|  CLOSE  |
 | WAIT-1  |------------------                              |   WAIT  |
 +---------+          rcv FIN  \                            +---------+
   | rcv ACK of FIN   -------   |                            CLOSE  |  
   | --------------   snd ACK   |                           ------- |  
   V        x                   V                           snd FIN V  
 +---------+                  +---------+                   +---------+
 |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 +---------+                  +---------+                   +---------+
   |                rcv ACK of FIN |                 rcv ACK of FIN |  
   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |  
   |  -------              x       V    ------------        x       V  
    \ snd ACK                 +---------+delete TCB         +---------+
     ------------------------>|TIME WAIT|------------------>| CLOSED  |
                              +---------+                   +---------+

                          TCP 연결 상태 다이어그램
                                 그림 6.

3.3.  Sequence Numbers (시퀀스 번호)

  설계의 기본 개념은 TCP 연결을 통해 전송되는 모든 데이터 옥텟에 시퀀스 번호가 있다는
  것입니다. 모든 옥텟이 시퀀싱되기 때문에 각 옥텟을 확인할 수 있습니다. 채택된
  acknowledgment 메커니즘은 누적되므로 시퀀스 번호 X의 acknowledgment은 X를 제외한
  모든 옥텟이 수신되었음을 나타냅니다. 이 메커니즘은 재전송이 있을 때 간단한 중복 감지를
  허용합니다. 세그먼트 내 옥텟의 번호 매기기는 헤더 바로 다음의 첫 번째 데이터 옥텟이 가장
  낮은 번호가 매겨지고 다음 옥텟이 연속적으로 번호가 매겨지는 것입니다.

  실제 시퀀스 번호 공간은 매우 크지만 유한하다는 점을 기억하는 것이 중요합니다. 이 공간의
  범위는 0에서 2**32 - 1까지입니다. 공간이 유한하기 때문에 시퀀스 번호를 다루는 모든 산술은
  모듈러 2**32로 수행되어야 합니다. 이 부호 없는 산술은 2**32 - 1에서 0으로 다시 순환할
  때 시퀀스 번호의 관계를 유지합니다. 컴퓨터 모듈러 산술에는 약간의 미묘함이 있으므로 이러한
  값의 비교를 프로그래밍할 때 상당한 주의를 기울여야 합니다. "=<" 기호는 "작거나 같음"
  (모듈러 2**32)을 의미합니다.

  TCP가 수행해야 하는 일반적인 시퀀스 번호 비교 유형은 다음과 같습니다:

    (a)  acknowledgment가 전송되었지만 아직 승인(acknowledged)되지 않은 일부 시퀀스
         번호를 참조하는지 확인합니다.

    (b)  세그먼트가 점유한 모든 시퀀스 번호가 승인되었는지 확인(예: 재전송 대기열에서
         세그먼트 제거)

    (c)  들어오는 세그먼트에 예상되는 시퀀스 번호가 포함되어 있는지 확인(즉, 세그먼트가 수신
         윈도우와 "겹침")

  데이터 전송에 대한 응답으로 TCP는 acknowledgment를 받습니다. acknowledgment를
  처리하려면 다음과 같은 비교가 필요합니다.

    SND.UNA = 가장 오래된 unacknowledged 시퀀스 번호

    SND.NXT = 다음 보낼 시퀀스 번호

    SEG.ACK = 수신 TCP의 acknowledgment(수신 TCP가 예상하는 다음 시퀀스 번호)

    SEG.SEQ = 세그먼트의 첫 번째 시퀀스 번호

    SEG.LEN = 세그먼트의 데이터가 차지하는 옥텟 수(SYN 및 FIN 계산)

    SEG.SEQ+SEG.LEN-1 = 세그먼트의 마지막 시퀀스 번호

  새로운 acknowledgment("acceptable ack"이라고 함)는 다음과 같은 부등식을
  유지하는 것입니다:

    SND.UNA < SEG.ACK =< SND.NXT

  재전송 대기열의 세그먼트는 시퀀스 번호와 길이의 합이 수신 세그먼트의 acknowledgment
  값보다 작거나 같으면 완전히 확인된 것입니다.

  데이터가 수신되면 다음 비교가 필요합니다:

    RCV.NXT = 들어오는 세그먼트에서 예상되는 다음 시퀀스 번호이며 수신 윈도우의 왼쪽 또는
        아래쪽 가장자리입니다.

    RCV.NXT+RCV.WND-1 = 들어오는 세그먼트에서 예상되는 마지막 시퀀스 번호이며 수신
        윈도우의 오른쪽 또는 위쪽 가장자리입니다.

    SEG.SEQ = 들어오는 세그먼트가 차지하는 첫 번째 시퀀스 번호

    SEG.SEQ+SEG.LEN-1 = 들어오는 세그먼트가 차지하는 마지막 시퀀스 번호

  다음과 같은 경우 세그먼트가 유효한 수신 시퀀스 공간의 일부를 차지하는 것으로 판단됩니다

    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

  또는

    RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND

  이 테스트의 첫 번째 부분은 세그먼트의 시작 부분이 윈도우에 속하는지 확인하고 테스트의 두
  번째 부분은 세그먼트의 끝이 윈도우에 속하는지 확인합니다. 세그먼트가 테스트의 어느 한
  부분을 통과하면 윈도우에 데이터가 포함됩니다.

  실제로는 이것보다 조금 더 복잡합니다. 제로 윈도우와 길이가 0인 세그먼트로 인해 들어오는
  세그먼트의 허용 가능성에 대한 네 가지 경우가 있습니다:

    Segment Receive  Test
    Length  Window
    ------- -------  -------------------------------------------

       0       0     SEG.SEQ = RCV.NXT

       0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

      >0       0     not acceptable

      >0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
                  or RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND

  수신 윈도우가 0이면 ACK 세그먼트를 제외하고 어떤 세그먼트도 허용되지 않아야 합니다.
  따라서 TCP가 데이터를 전송하고 ACK를 수신하는 동안 수신 윈도우를 0으로 유지하는 것이
  가능합니다. 그러나 수신 윈도우가 0인 경우에도 TCP는 들어오는 모든 세그먼트의 RST 및
  URG 필드를 처리해야 합니다.

  또한 특정 제어 정보를 보호하기 위해 번호 매기기 체계를 활용했습니다. 이는 시퀀스 공간에 일부
  제어 플래그를 암시적으로 포함하여 혼동 없이 재전송 및 승인될 수 있도록 함으로써 달성됩니다
  (즉, 하나의 컨트롤 사본만 실행됨). 제어 정보는 세그먼트 데이터 공간에 물리적으로 전달되지
  않습니다. 결과적으로 컨트롤에 암시적으로 시퀀스 번호를 할당하는 규칙을 채택해야 합니다. SYN
  및 FIN은 이러한 보호가 필요한 유일한 컨트롤이며 이러한 컨트롤은 연결을 열고 닫을 때만
  사용됩니다. 시퀀스 번호를 위해 SYN은 발생하는 세그먼트의 첫 번째 실제 데이터 옥텟 이전에
  발생하는 것으로 간주되는 반면 FIN은 발생하는 세그먼트의 마지막 실제 데이터 옥텟 이후에
  발생하는 것으로 간주됩니다. 세그먼트 길이(SEG.LEN)에는 컨트롤을 차지하는 데이터 및 시퀀스
  공간이 모두 포함됩니다. SYN이 있는 경우 SEG.SEQ는 SYN의 시퀀스 번호입니다.

  Initial Sequence Number Selection (초기 시퀀스 번호 선택)

  프로토콜은 반복해서 사용되는 특정 연결에 제한을 두지 않습니다. 연결은 한 쌍의 소켓으로
  정의됩니다. 연결의 새 인스턴스를 연결의 실현(incarnations)이라고 지칭할 것 입니다.
  여기서 발생하는 문제는 -- "어떻게 TCP가 연결의 이전 실현에서 중복 세그먼트를 식별할
  것인가?" 입니다. 이 문제는 연결이 빠르게 연속적으로 열리고 닫히거나 메모리 손실로 인해
  연결이 끊어졌다가 다시 설정되는 경우 명백해집니다.

  혼동을 피하기 위해 이전 실현에서 네트워크에 동일한 시퀀스 번호가 여전히 존재할 수 있는 동안
  연결의 한 실현에서 세그먼트가 사용되는 것을 방지해야 합니다. TCP가 충돌하여 사용하고 있는
  시퀀스 번호에 대한 모든 정보를 잃어버리더라도 이를 보장하고자 합니다. 새 연결이 생성되면
  새로운 32비트 ISN을 선택하는 초기 시퀀스 번호(ISN = Initial Sequence Number)
  생성기가 사용됩니다. 생성기는 하위 비트가 약 4마이크로초마다 증가하는 (아마도 가상의)
  32비트 클럭에 바인딩됩니다. 따라서 ISN은 약 4.55시간마다 순환합니다. 세그먼트가 최대
  세그먼트 수명 (MSL = Maximum Segment Lifetime) 이하로 네트워크에 유지되고 MSL이
  4.55시간 미만이라고 가정하므로 ISN이 고유할 것이라고 합리적으로 가정할 수 있습니다.

  각 연결에는 송신 시퀀스 번호와 수신 시퀀스 번호가 있습니다. 초기 전송 시퀀스 번호(ISS =
  Initial Send Sequence number)는 데이터 전송 TCP에 의해 선택되고 초기 수신 시퀀스
  번호 (IRS = Initial Receive Sequence number)는 연결 설정 절차 중에 학습됩니다.

  연결을 설정하거나 초기화하려면 두 TCP가 서로의 초기 시퀀스 번호를 동기화해야 합니다. 이것은
  "SYN"(동기화용)이라는 제어 비트와 초기 시퀀스 번호를 전달하는 연결 설정 세그먼트의 교환에서
  수행됩니다. 간단히 말해서 SYN 비트를 전달하는 세그먼트를 "SYN"이라고도 합니다. 따라서
  솔루션에는 초기 시퀀스 번호를 선택하기 위한 적절한 메커니즘과 ISN을 교환하기 위해 약간
  관련된 핸드셰이크가 필요합니다.

  동기화를 위해서는 각 측이 자신의 초기 시퀀스 번호를 전송하고 상대방의 acknowledgment을
  수신해야 합니다. 각 측은 또한 상대방의 초기 시퀀스 번호를 수신하고 확인 acknowledgment를
  보내야 합니다.

    1) A --> B  SYN 내 시퀀스 번호는 X입니다.
    2) A <-- B  ACK 당신의 시퀀스 번호는 X입니다.
    3) A <-- B  SYN 내 시퀀스 번호는 Y입니다.
    4) A --> B  ACK 당신의 시퀀스 번호는 Y입니다.

  2단계와 3단계를 단일 메시지로 결합할 수 있기 때문에 이를 3방향(또는 3개의 메시지)
  핸드셰이크라고 합니다.

  시퀀스 번호가 네트워크의 전역 시계에 연결되어 있지 않고 TCP가 ISN 선택을 위한 다른
  메커니즘을 가질 수 있기 때문에 3방향 핸드셰이크가 필요합니다. 첫 번째 SYN의 수신자는 연결에
  사용된 마지막 시퀀스 번호(항상 가능한 것은 아님)를 기억하지 않는 한 세그먼트가 이전에 지연된
  세그먼트인지 여부를 알 방법이 없으므로 발신자에게 이 SYN을 확인하도록 요청해야 합니다. 3방향
  핸드셰이크와 클록 기반 방식의 장점은 [3]에서 설명합니다.

  Knowing When to Keep Quiet

  TCP가 네트워크에 남아 있는 이전 세그먼트에 의해 복제될 수 있는 시퀀스 번호를 전달하는
  세그먼트를 생성하지 않도록 하기 위해 TCP는 시작 시 시퀀스 번호를 할당하기 전에 최대 세그먼트
  수명(MSL) 동안 조용히 유지하거나 사용 중인 시퀀스 번호의 메모리가 손실된 충돌에서 복구되어야
  합니다. 이 사양의 경우 MSL은 2분으로 간주됩니다. 이는 공학적 선택이며 경험상 그렇게 하는
  것이 바람직하다고 판단되면 변경할 수 있습니다. TCP가 어떤 의미에서 재초기화되었지만 사용
  중인 시퀀스 번호의 메모리를 유지하는 경우 전혀 기다릴 필요가 없습니다; 최근에 사용한 시퀀스
  번호보다 큰 시퀀스 번호만 사용해야 합니다.

  The TCP Quiet Time Concept

    이 사양은 각 활성(즉, 닫히지 않은) 연결에서 전송된 마지막 시퀀스 번호에 대한 지식을
    보유하지 않고 "충돌"하는 호스트는 호스트가 속한 인터넷 시스템에서 합의된 최대 세그먼트
    수명(MSL) 이상 동안 TCP 세그먼트 방출을 지연해야 한다고 규정합니다. 아래 단락에서 이
    사양에 대한 설명이 제공됩니다. TCP 구현자는 "quiet time" 제한을 위반할 수 있지만
    인터넷 시스템의 일부 수신자에 의해 오래된 데이터로 거부되거나 이전 데이터로 거부된 새로운
    데이터로 일부 오래된 데이터가 수락될 위험이 있습니다.

    TCP는 세그먼트가 형성되어 송신자 호스트 네트워크 출력 큐에 입력될 때마다 시퀀스 번호 
    공간을 소비합니다. TCP 프로토콜의 중복 감지 및 시퀀싱 알고리즘은 해당 시퀀스 번호에
    바인딩된 세그먼트 데이터가 전달되기 전에 시퀀스 번호가 모든 2**32 값을 순환하지 않는
    범위까지 시퀀스 공간에 대한 세그먼트 데이터의 고유한 바인딩에 의존합니다. 수신자에 의해
    확인되고 세그먼트의 모든 중복 사본이 인터넷에서 "배출"되었습니다. 이러한 가정 없이 두
    개의 서로 다른 TCP 세그먼트는

    동일하거나 겹치는 시퀀스 번호가 할당되어 수신기에서 어떤 데이터가 새 데이터이고 어떤
    데이터가 오래된 것인지 혼동을 일으킵니다. 각 세그먼트는 세그먼트에 있는 데이터의 옥텟
    수만큼 많은 연속 시퀀스 번호에 연결되어 있음을 기억하십시오.

    정상 조건에서 TCP는 최초 사용이 acknowledgment되기 전 실수로 시퀀스 번호를 사용하는
    것을 방지하기 위해 내보낼 다음 시퀀스 번호와 acknowledgment 대기 중인 가장 오래된
    시퀀스 번호를 추적합니다. 이것만으로는 오래된 중복 데이터가 네트워크에서 유출된다는 보장이
    없으므로 떠돌아다니는 중복 데이터가 도착 시 문제를 일으킬 가능성을 줄이기 위해 시퀀스
    공간을 매우 크게 만들었습니다. 2메가비트/초. 시퀀스 공간의 2**32 옥텟을 사용하는 데
    4.5시간이 걸립니다. 네트워크의 최대 세그먼트 수명은 수십 초를 초과하지 않을 것이므로
    데이터 속도가 수십 메가비트/초로 상승하더라도 예측 가능한 네트워크에 대한 충분한 보호로
    간주됩니다. 100메가비트/초에서 주기 시간은 5.4분으로 약간 짧을 수 있지만 여전히
    타당합니다.

    TCP의 기본 중복 감지 및 시퀀싱 알고리즘은 원본 TCP에 지정된 연결에서 마지막으로 사용된
    시퀀스 번호의 메모리가 없는 경우 실패할 수 있습니다. 예를 들어, TCP가 시퀀스 번호 0으로
    모든 연결을 시작하는 경우 충돌 및 재시작 시 TCP는 이전 연결을 다시 형성하고(아마도 반쯤
    열린 연결 해결 후) 시퀀스 번호가 동일하거나 겹치는 패킷을 내보낼 수 있습니다. 동일한
    연결의 이전 화신에서 방출된 패킷이 여전히 네트워크에 있습니다. 특정 연결에 사용된 시퀀스
    번호에 대한 지식이 없는 경우 TCP 사양은 연결에서 세그먼트를 방출하기 전에 MSL 초 동안
    소스 지연을 권장하여 이전 연결 구현의 세그먼트가 시스템에서 배출될 시간을 허용합니다.

    하루 중 시간을 기억할 수 있고 이를 사용하여 초기 시퀀스 번호 값을 선택하는 호스트도 이
    문제에서 면역되지 않습니다(즉, 시간을 사용하여 각각의 새로운 연결 구현에 대한 초기 시퀀스
    번호를 선택하는 경우에도).

    예를 들어 시퀀스 번호 S로 시작하는 연결이 열린다고 가정합니다. 이 연결이 많이 사용되지
    않고 결국 초기 시퀀스 번호 함수(ISN(t))가 특정 연결에서 이 TCP가 보낸 마지막
    세그먼트의 S1과 같은 시퀀스 번호와 같은 값을 갖는다고 가정합니다. 이제 이 순간에 호스트가
    충돌, 복구 및 연결의 새로운 실현(incarnation)을 설정한다고 가정합니다. 선택된 초기
    시퀀스 번호는 S1 = ISN(t)입니다 -- 이전 연결의 실현에서 마지막으로 사용된 시퀀스
    번호입니다! 복구가 충분히 빨리 발생하면 S1 근처에 있는 net bearing 시퀀스 번호의 이전
    중복이 도착할 수 있으며 연결의 새로운 실현 수신자에 의해 새 패킷으로 처리될 수 있습니다.

    문제는 복구 중인 호스트가 얼마나 오래 충돌했는지 알 수 없으며 이전 연결의 실현에서
    시스템에 여전히 오래된 복제본이 있는지 여부를 알 수 없다는 것입니다.

    이 문제를 처리하는 한 가지 방법은 충돌에서 복구한 후 하나의 MSL에 대한 세그먼트 방출을
    의도적으로 지연시키는 것입니다. 이것이 "quite time" 사양입니다. 대기를 피하는 것을
    선호하는 ㄴ호스트는 주어진 대상에서 이전 패킷과 새 패킷의 가능한 혼동 위험을 감수하고
    "quite time"을 기다리지 않기로 선택할 수 있습니다. 구현자는 TCP 사용자에게 충돌 후
    대기할지 여부를 연결별로 선택할 수 있는 기능을 제공하거나 모든 연결에 대해 비공식적으로
    "quite time"을 구현할 수 있습니다. 분명히 사용자가 "wait"를 선택한 경우에도 호스트가
    최소한 MSL 초 동안 "up" 한 후에는 이것이 필요하지 않습니다.

    요약: 방출된 모든 세그먼트는 시퀀스 공간에서 하나 이상의 시퀀스 번호를 차지하며,
    세그먼트가 차지하는 번호는 MSL 초가 지날 때까지 "busy" 또는 "in use"이고, 새 연결이
    너무 빨리 시작되고 이전 연결의 실현이 마지막 세그먼트의 시공간 풋프린트에 있는 시퀀스
    번호를 사용하는 경우 크래시 시 시공간 블록이 마지막 방출된 세그먼트의 옥텟에 의해
    점유됩니다. 수신기에서 혼동을 일으킬 수 있는 잠재적인 시퀀스 번호 중복 영역이 있습니다.
    
3.4.  Establishing a connection (연결 설정)

  "3방향 핸드셰이크"는 연결을 설정하는 데 사용되는 절차입니다. 이 절차는 일반적으로 하나의
  TCP에 의해 시작되고 다른 TCP에 의해 응답됩니다. 이 절차는 두 개의 TCP가 동시에 절차를
  시작하는 경우에도 작동합니다. 동시 시도가 발생하면 각 TCP는 "SYN"을 보낸 후
  acknowledgment을 전달하지 않는 "SYN" 세그먼트를 받습니다. 물론 오래된 복제 "SYN"
  세그먼트가 도착하면 동시 연결 시작이 진행 중인 것처럼 수신자에게 잠재적으로 나타날 수
  있습니다. "reset" 세그먼트를 적절히 사용하면 이러한 경우를 명확하게 구분할 수 있습니다.

  연결 시작의 몇 가지 예는 다음과 같습니다. 이 예에서는 데이터 운반 세그먼트를 사용하는 연결
  동기화를 보여주지 않지만 수신 TCP가 데이터가 유효하다는 것이 명확해질 때까지 사용자에게
  데이터를 전달하지 않는 한 이것은 완벽하게 합법적입니다(즉, 데이터는 연결이 ESTABLISHED
  상태에 도달할 때까지 수신기에서 버퍼링되어야 합니다). 3방향 핸드셰이크는 잘못된 연결의
  가능성을 줄입니다. 이 확인을 위한 정보를 제공하기 위해 메모리와 메시지 간의 균형을
  구현합니다.

  가장 간단한 3방향 핸드셰이크는 아래 그림 7에 나와 있습니다. 수치는 다음과 같이 해석되어야
  합니다. 각 줄은 참조용으로 번호가 매겨져 있습니다. 오른쪽 화살표(-->)는 TCP A에서 TCP
  B로의 TCP 세그먼트 출발 또는 A에서 B의 세그먼트 도착을 나타냅니다. 왼쪽 화살표(<--)는 그
  반대를 나타냅니다. 말줄임표(...)는 아직 네트워크에 있는(지연된) 세그먼트를 나타냅니다.
  "XXX"는 손실되거나 거부된 세그먼트를 나타냅니다. 설명은 괄호 안에 표시됩니다. TCP 상태는
  세그먼트의 출발 또는 도착 이후의 상태를 나타냅니다(각 라인의 중앙에 내용이 표시됨). 세그먼트
  내용은 시퀀스 번호, 제어 플래그 및 ACK 필드와 함께 약식으로 표시됩니다. 윈도우, 주소,
  길이 및 텍스트와 같은 다른 필드는 명확성을 위해 제외되었습니다.
  

      TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED

  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED

                     연결 동기화를 위한 기본 3방향 핸드셰이크

                                  그림 7.

  그림 7의 라인 2에서 TCP A는 시퀀스 번호 100으로 시작하는 시퀀스 번호를 사용할 것임을
  나타내는 SYN 세그먼트를 보내는 것으로 시작합니다. 라인 3에서 TCP B는 SYN을 보내고 TCP
  A로부터 받은 SYN을 승인합니다. acknowledgment 필드는 TCP B가 이제 시퀀스 100을
  점유한 SYN을 승인하여 시퀀스 101을 수신할 것으로 예상하고 있음을 나타냅니다.

  4행에서 TCP A는 TCP B의 SYN에 대한 ACK를 포함하는 빈 세그먼트로 응답합니다. 5번째
  줄에서 TCP A는 일부 데이터를 보냅니다. ACK가 시퀀스 번호 공간을 차지하지 않기 때문에 라인
  5에 있는 세그먼트의 시퀀스 번호는 라인 4와 동일합니다(만약 그렇다면 ACK를 ACK하는
  것입니다!).

  동시 시작은 그림 8에 표시된 것처럼 약간 더 복잡할 뿐입니다. 각 TCP는 CLOSED에서
  SYN-SENT, SYN-RECEIVED, ESTABLISHED로 순환합니다.
  

      TCP A                                            TCP B

  1.  CLOSED                                           CLOSED

  2.  SYN-SENT     --> <SEQ=100><CTL=SYN>              ...

  3.  SYN-RECEIVED <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT

  4.               ... <SEQ=100><CTL=SYN>              --> SYN-RECEIVED

  5.  SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...

  6.  ESTABLISHED  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED

  7.               ... <SEQ=101><ACK=301><CTL=ACK>     --> ESTABLISHED

                              동시 연결 동기화

                                 그림 8.

  3방향 핸드셰이크의 주된 이유는 오래된 중복 연결 시작으로 인해 혼란이 발생하지 않도록 하기
  위함입니다. 이를 처리하기 위해 특별한 제어 메시지인 reset이 고안되었습니다. 수신 TCP가
  동기화되지 않은 상태 (즉, SYN-SENT, SYN-RECEIVED)에 있는 경우 허용 가능한 재설정을
  수신하면 LISTEN으로 돌아갑니다. TCP가 동기화된 상태(ESTABLISHED, FIN-WAIT-1,
  FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT) 중 하나에 있으면
  연결을 중단하고 사용자에게 알립니다. 이 후자의 경우는 아래의 "half-open" 연결에서
  논의합니다.

      TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               ...

  3.  (duplicate) ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED

  4.  SYN-SENT    <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED

  5.  SYN-SENT    --> <SEQ=91><CTL=RST>               --> LISTEN
  

  6.              ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  7.  SYN-SENT    <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED

                           이전 중복 SYN에서 복구

                                 그림 9.

  오래된 중복에서 복구하는 간단한 예로 그림 9를 살펴보십시오. 3행에서 오래된 중복 SYN이 TCP
  B에 도착합니다. TCP B는 이것이 오래된 중복임을 알 수 없으므로 정상적으로 응답합니다(4행).
  TCP A는 ACK 필드가 잘못되었음을 감지하고 세그먼트를 믿을 수 있도록 선택한 SEQ 필드와 함께
  RST(reset)를 반환합니다. RST를 수신한 TCP B는 LISTEN 상태로 돌아갑니다. 원래
  SYN(말장난 의도)이 마침내 6행에 도착하면 동기화가 정상적으로 진행됩니다. 6행의 SYN이
  RST보다 먼저 도착했다면 양방향으로 전송된 RST와 함께 더 복잡한 교환이 발생했을 수 있습니다.

  Half-Open Connections and Other Anomalies (Half-Open 및 기타 이상 현상)

  설정된 연결은 TCP 중 하나가 다른 TCP에 대한 지식 없이 끝에서 연결을 닫거나 중단한 경우나
  충돌로 인한 메모리 손실 때문에 연결의 두 끝이 비동기화된 경우를 "half-open"이라고 합니다.
  이러한 연결은 어느 방향으로든 데이터를 보내려고 하면 자동으로 재설정됩니다. 그러나
  half-open 연결은 일반적이지 않을 것으로 예상되며 복구 절차가 약간 포함됩니다.

  사이트 A에 연결이 더 이상 존재하지 않는 경우 사이트 B의 사용자가 데이터를 보내려고 시도하면
  사이트 B TCP가 reset 제어 메시지를 수신하게 됩니다. 이러한 메시지는 사이트 B TCP에
  무언가 잘못되었음을 알리고 연결을 중단할 것으로 예상됩니다.

  충돌이 발생하여 A의 TCP에 대한 메모리 손실이 발생했을 때 두 사용자 프로세스 A와 B가 서로
  통신하고 있다고 가정합니다. A의 TCP를 지원하는 운영 체제에 따라 일부 오류 복구 메커니즘이
  존재할 수 있습니다. TCP가 다시 가동되면 A는 처음부터 또는 복구 지점에서 다시 시작할
  가능성이 높습니다. 결과적으로 A는 아마도 연결을 다시 OPEN하려고 시도하거나 열려 있다고 믿는
  연결에서 SEND를 시도할 것입니다. 후자의 경우 로컬(A)의 TCP로부터 "connection not
  open"이라는 오류 메시지를 수신합니다. 연결을 설정하려는 시도에서 A의 TCP는 SYN이 포함된
  세그먼트를 보냅니다. 이 시나리오는 그림 10에 표시된 예제로 이어집니다. TCP A 충돌 후
  사용자는 연결을 다시 열려고 시도합니다. 그 동안 TCP B는 연결이 열려 있다고 생각합니다.

  

      TCP A                                           TCP B

  1.  (CRASH)                               (send 300,receive 100)

  2.  CLOSED                                           ESTABLISHED

  3.  SYN-SENT --> <SEQ=400><CTL=SYN>              --> (??)

  4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED

  5.  SYN-SENT --> <SEQ=100><CTL=RST>              --> (Abort!!)

  6.  SYN-SENT                                         CLOSED

  7.  SYN-SENT --> <SEQ=400><CTL=SYN>              -->

                            Half-Open 연결 검색

                                  그림 10.

  SYN이 라인 3에 도착하면 동기화된 상태에 있는 TCP B와 윈도우 외부의 들어오는 세그먼트는
  다음에 어떤 시퀀스를 들을 것으로 예상하는지(ACK 100) 나타내는 acknowledgment으로
  응답합니다. TCP A는 이 세그먼트가 자신이 보낸 어떤 것도 승인하지 않는 것을 확인하고
  동기화되지 않은 상태에서 half-open 연결을 감지했기 때문에 reset(RST)을 보냅니다. TCP
  B는 5행에서 중단됩니다. TCP A는 계속해서 연결 설정을 시도합니다; 문제는 이제 그림 7의
  기본 3방향 핸드셰이크로 축소되었습니다.

  흥미로운 대안 사례는 TCP A가 충돌하고 TCP B가 동기화된 연결이라고 생각하는 데이터를
  보내려고 할 때 발생합니다. 이것은 그림 11에 설명되어 있습니다. 이 경우 TCP B에서 TCP A로
  도착하는 데이터(라인 2)는 그러한 연결이 존재하지 않기 때문에 허용되지 않으므로 TCP A는
  RST를 보냅니다. RST가 허용되므로 TCP B가 이를 처리하고 연결을 중단합니다.

  

        TCP A                                              TCP B

  1.  (CRASH)                                   (send 300,receive 100)

  2.  (??)    <-- <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED

  3.          --> <SEQ=100><CTL=RST>                   --> (ABORT!!)

                     Active 측에서 Half-Open 연결 검색 

                                  그림 11.

  그림 12에서 수동 연결이 SYN을 기다리는 두 개의 TCP A와 B를 볼 수 있습니다. TCP B(라인
  2)에 도착한 오래된 복제본은 B를 행동으로 몰아넣습니다. SYN-ACK가 반환되고(라인 3) TCP
  A가 RST를 생성하도록 합니다(라인 3의 ACK는 허용되지 않음). TCP B는 재설정을 수락하고
  Passive LISTEN 상태로 돌아갑니다.

  

      TCP A                                         TCP B

  1.  LISTEN                                        LISTEN

  2.       ... <SEQ=Z><CTL=SYN>                -->  SYN-RECEIVED

  3.  (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED

  4.       --> <SEQ=Z+1><CTL=RST>              -->  (return to LISTEN!)

  5.  LISTEN                                        LISTEN

              오래된 중복 SYN이 2개의 Passive 소켓에서 재설정을 시작함

                                 그림 12.

  다양한 다른 경우가 가능하며 모두 RST 생성 및 처리에 대한 다음 규칙에 의해 설명됩니다.

  Reset Generation (Reset 생성)

  일반적으로 재설정(RST)은 현재 연결을 위한 것이 아닌 것으로 보이는 세그먼트가 도착할 때마다
  전송되어야 합니다. 이것이 사실인지 확실하지 않은 경우 reset을 보내서는 안 됩니다.

  세 가지 상태 그룹이 있습니다:

    1.  연결이 존재하지 않는 경우(CLOSED) 다른 reset을 제외한 수신 세그먼트에 대한
    응답으로 reset이 전송됩니다. 특히, 존재하지 않는 연결로 주소 지정된 SYN은 이 방법으로
    거부됩니다.

    수신 세그먼트에 ACK 필드가 있는 경우 reset은 세그먼트의 ACK 필드에서 시퀀스 번호를
    가져오고, 그렇지 않으면 reset의 시퀀스 번호는 0이고 ACK 필드는 수신 세그먼트의 시퀀스
    번호와 세그먼트 길이의 합으로 설정됩니다. 연결은 CLOSED 상태로 유지됩니다.

    2.  연결이 동기화되지 않은 상태(LISTEN, SYN-SENT, SYN-RECEIVED)에 있고 수신
    세그먼트가 아직 전송되지 않은 것을 승인하거나(세그먼트가 허용할 수 없는 ACK를 전달함)
    수신 세그먼트에 보안 수준이 있거나 연결에 대해 요청된 구획 및 레벨과 정확히 일치하지 않는
    구획이 있는 경우 reset이 전송됩니다.

    SYN이 확인되지 않고 들어오는 세그먼트의 우선 순위 수준이 요청된 우선 순위 수준보다 높으면
    로컬 우선 순위 수준을 높이거나(사용자와 시스템에서 허용하는 경우) reset을 보냅니다. 또는
    들어오는 세그먼트의 우선 순위 수준이 요청된 우선 순위 수준보다 낮으면 우선 순위가 정확히
    일치하는 것처럼 계속합니다(원격 TCP가 우리와 일치하도록 우선 순위 수준을 올릴 수 없는
    경우 이것은 전송하는 다음 세그먼트에서 감지되고 그러면 연결이 종료됩니다.) SYN이 승인된
    경우(아마도 이 수신 세그먼트에서) 수신 세그먼트의 우선 순위 수준은 로컬 우선 순위 수준과
    정확히 일치해야 하며 그렇지 않은 경우 reset을 전송해야 합니다.

    수신 세그먼트에 ACK 필드가 있는 경우 reset은 세그먼트의 ACK 필드에서 시퀀스 번호를
    가져오고, 그렇지 않으면 reset의 시퀀스 번호는 0이고 ACK 필드는 수신 세그먼트의 시퀀스
    번호와 세그먼트 길이의 합으로 설정됩니다. 연결은 동일한 상태로 유지됩니다.

    3.  연결이 동기화된 상태(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT,
    CLOSING, LAST-ACK, TIME-WAIT)인 경우 허용되지 않는 세그먼트(윈도우 시퀀스 번호 밖
    또는 허용되지 않는 acknowledgment 번호)는 현재 전송 시퀀스 번호와 수신될 것으로
    예상되는 다음 시퀀스 번호를 나타내는 acknowledgment를 포함하는 빈 acknowledgment
    세그먼트만 이끌어내야 하며 연결은 동일한 상태로 유지됩니다.

    들어오는 세그먼트에 연결에 대해 요청된 수준, 구획 및 우선 순위와 정확히 일치하지 않는 보안
    수준, 구획 또는 우선 순위가 있는 경우 reset이 전송되고 연결이 CLOSED 상태로
    전환됩니다. reset은 들어오는 세그먼트의 ACK 필드에서 시퀀스 번호를 가져옵니다.

  Reset Processing (Reset 처리)

  SYN-SENT를 제외한 모든 상태에서 모든 reset(RST) 세그먼트는 SEQ 필드를 확인하여
  확인됩니다. 시퀀스 번호가 윈도우에 있으면 reset이 유효합니다. SYN-SENT 상태(초기
  SYN에 대한 응답으로 수신된 RST)에서 ACK 필드가 SYN을 승인하면 RST가 허용됩니다.

  RST의 수신자는 먼저 유효성을 검사한 다음 상태를 변경합니다. 수신자가 LISTEN 상태에 있으면
  무시합니다. 수신자가 SYN-RECEIVED 상태이고 이전에 LISTEN 상태였다면 수신자는 LISTEN
  상태로 돌아가고, 그렇지 않으면 수신자는 연결을 중단하고 CLOSED 상태로 이동합니다. 수신자가
  다른 상태에 있으면 연결을 중단하고 사용자에게 알리고 CLOSED 상태로 이동합니다.

3.5.  Closing a Connection (연결 종료)

  CLOSE는 "더 이상 보낼 데이터가 없습니다."라는 의미의 작업입니다. 물론 전이중 연결을
  닫는다는 개념은 연결의 수신측을 처리하는 방법이 명확하지 않을 수 있으므로 모호하게 해석될 수
  있습니다. 우리는 단순 방식으로 CLOSE를 처리하기로 선택했습니다. CLOSE하는 사용자는
  상대방도 CLOSED라는 말을 들을 때까지 계속 수신할 수 있습니다. 따라서 프로그램은 CLOSE에
  이어 여러 SEND를 시작한 다음 상대방이 CLOSED로 인해 RECEIVE가 실패했다는 신호를 받을
  때까지 RECEIVE를 계속할 수 있습니다. 우리는 TCP가 사용자에게 미결 RECEIVE가 없더라도
  다른 쪽이 닫혔다는 신호를 보내 사용자가 자신의 쪽을 정상적으로 종료할 수 있다고 가정합니다.
  TCP는 연결이 닫히기 전에 전송된 모든 버퍼를 안정적으로 전달할 것이므로 데이터가 반환되지 않을
  것으로 예상하는 사용자는 연결이 성공적으로 닫혔다는 소식을 듣고 대상 TCP에서 모든 데이터가
  수신되었음을 알기만 하면 됩니다. 사용자는 TCP가 더 이상 데이터가 없다고 말할 때까지 전송을
  위해 닫은 연결을 계속 읽어야 합니다.

  기보적으로 세 가지 경우가 있습니다:

    1) 사용자는 TCP에 연결을 닫으라고 지시하여 시작

    2) 원격 TCP는 FIN 제어 신호를 전송하여 시작

    3) 두 사용자가 동시에 CLOSE

  Case 1:  로컬 사용자가 닫기 시작

    이 경우 FIN 세그먼트를 생성하여 나가는 세그먼트 대기열에 배치할 수 있습니다. 사용자의 더
    이상의 SEND는 TCP에 의해 수락되지 않으며 FIN-WAIT-1 상태로 들어갑니다. 이 상태에서는
    RECEIVE가 허용됩니다. FIN 이전 및 FIN을 포함하는 모든 세그먼트는 확인될 때까지
    재전송됩니다. 다른 TCP가 FIN을 승인하고 자신의 FIN을 보낸 경우 첫 번째 TCP는 이
    FIN을 ACK할 수 있습니다. FIN을 수신하는 TCP는 ACK하지만 사용자가 연결을 닫을 때까지
    자신의 FIN을 보내지 않습니다.

  Case 2:  TCP는 네트워크에서 FIN 수신

    요청하지 않은 FIN이 네트워크에서 도착하면 수신 TCP는 이를 ACK하고 사용자에게 연결이
    닫히고 있음을 알릴 수 있습니다. 사용자는 TCP가 나머지 데이터를 보낸 후 다른 TCP에
    FIN을 보낼 수 있는 CLOSE로 응답합니다. 그런 다음 TCP는 자신의 FIN이 승인될 때까지
    기다렸다가 연결을 삭제합니다. ACK가 나오지 않으면 사용자 시간 초과 후 연결이 중단되고
    사용자에게 알립니다.

  Case 3:  두 사용자가 동시에 CLOSE

    연결의 양쪽 끝에서 사용자가 동시에 CLOSE하면 FIN 세그먼트가 교환됩니다. FIN 앞에 있는
    모든 세그먼트가 처리되고 확인되면 각 TCP는 수신한 FIN을 ACK할 수 있습니다. 둘 다 이러한
    ACK를 수신하면 연결을 삭제합니다.

      TCP A                                                TCP B

  1.  ESTABLISHED                                          ESTABLISHED

  2.  (Close)
      FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT

  3.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT

  4.                                                       (Close)
      TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK

  5.  TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED

  6.  (2 MSL)
      CLOSED                                                      

                            정상적인 닫기 시퀀스

                                 그림 13.

  

      TCP A                                                TCP B

  1.  ESTABLISHED                                          ESTABLISHED

  2.  (Close)                                              (Close)
      FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1
                  <-- <SEQ=300><ACK=100><CTL=FIN,ACK>  <--
                  ... <SEQ=100><ACK=300><CTL=FIN,ACK>  -->

  3.  CLOSING     --> <SEQ=101><ACK=301><CTL=ACK>      ... CLOSING
                  <-- <SEQ=301><ACK=101><CTL=ACK>      <--
                  ... <SEQ=101><ACK=301><CTL=ACK>      -->

  4.  TIME-WAIT                                            TIME-WAIT
      (2 MSL)                                              (2 MSL)
      CLOSED                                               CLOSED

                              동시 닫기 시퀀스

                                 그림 14.

3.6.  Precedence and Security (우선 순위 및 보안)

  의도는 정확히 동일한 보안 및 구획 값으로 작동하고 두 포트에서 요청한 우선 순위 수준보다 높은
  우선 순위 수준에서 작동하는 포트 간에만 연결이 허용되도록 하는 것입니다.

  TCP에서 사용되는 우선 순위 및 보안 매개변수는 인터넷 프로토콜(IP)[2]에 정의된 것과 정확히
  일치합니다. 이 TCP 사양 전체에서 "보안/구획"이라는 용어는 보안, 구획, 사용자 그룹 및 처리
  제한을 포함하여 IP에서 사용되는 보안 매개변수를 나타내기 위한 것입니다.

  보안/구획 값이 일치하지 않거나 우선 순위 값이 낮은 연결 시도는 재설정을 전송하여 거부해야
  합니다. 너무 낮은 우선 순위로 인한 연결 거부는 SYN 승인을 받은 후에만 발생합니다.

  우선 순위의 기본값에서만 작동하는 TCP 모듈은 들어오는 세그먼트의 우선 순위를 확인하고
  가능하면 연결에서 사용하는 우선 순위 수준을 높여야 합니다.

  보안 매개변수는 비보안 환경에서도 사용할 수 있으므로(값은 분류되지 않은 데이터를 나타냄)
  비보안 환경의 호스트는 보안 매개변수를 보낼 필요는 없지만 수신할 준비가 되어 있어야 합니다.

3.7.  Data Communication (데이터 통신)

  연결이 설정되면 세그먼트 교환을 통해 데이터가 전달됩니다. 오류(체크섬 테스트 실패) 또는
  네트워크 정체로 인해 세그먼트가 손실될 수 있으므로 TCP는 모든 세그먼트의 전달을 보장하기
  위해 재전송(시간 초과 후)을 사용합니다. 네트워크 또는 TCP 재전송으로 인해 중복 세그먼트가
  도착할 수 있습니다. 시퀀스 번호 섹션에서 설명한 것처럼 TCP는 세그먼트의 시퀀스 및 승인
  번호에 대한 특정 테스트를 수행하여 허용 여부를 확인합니다.

  데이터 송신자는 변수 SND.NXT에서 사용할 다음 시퀀스 번호를 추적합니다. 데이터 수신자는 변수
  RCV.NXT에서 예상할 다음 시퀀스 번호를 추적합니다. 데이터 송신자는 변수 SND.UNA에서
  승인되지 않은 가장 오래된 시퀀스 번호를 추적합니다. 데이터 흐름이 일시적으로 유휴 상태이고
  전송된 모든 데이터가 승인된 경우 세 변수는 동일합니다.

  송신자가 세그먼트를 생성하고 전송하면 송신자는 SND.NXT를 진행합니다. 수신기가 세그먼트를
  수락하면 RCV.NXT를 진행하고 acknowledgment를 보냅니다. 데이터 송신자가
  acknowledgment를 받으면 SND.UNA로 진행합니다. 이러한 변수의 값이 다른 정도는 통신
  지연의 척도입니다. 변수가 진행되는 양은 세그먼트의 데이터 길이입니다. 일단 ESTABLISHED
  상태가 되면 모든 세그먼트는 현재 acknowledgment 정보를 전달해야 합니다.

  CLOSE 사용자 호출은 들어오는 세그먼트의 FIN 제어 플래그와 마찬가지로 푸시 기능을 의미합니다.

  Retransmission Timeout 재전송 시간 초과

  인터네트워크 시스템을 구성하는 네트워크의 가변성과 TCP 연결의 광범위한 사용으로 인해 재전송
  제한 시간은 동적으로 결정되어야 합니다. 재전송 타임아웃을 결정하기 위한 한 가지 절차가 여기에
  예시로 제공됩니다.

    재전송 시간 초과 절차의 예

      특정 시퀀스 번호가 있는 데이터 옥텟 전송과 해당 시퀀스 번호를 포함하는
      acknowledgment 수신 사이의 경과 시간을 측정합니다(전송된 세그먼트가 수신된
      세그먼트와 일치할 필요는 없음). 이 측정된 경과 시간은 왕복 시간(Round Trip Time)
      입니다. 다음으로 SRTT(Smoothed Round Trip Time)를 다음과 같이 계산합니다:

        SRTT = ( ALPHA * SRTT ) + ((1-ALPHA) * RTT)

      이를 기반으로 다음과 같이 재전송 제한 시간(RTO)을 계산합니다:

        RTO = min[UBOUND,max[LBOUND,(BETA*SRTT)]]

      여기서 UBOUND는 타임아웃의 상한값(예: 1분), LBOUND는 타임아웃의 하한값(예: 1초),
      ALPHA는 스무딩 계수(예: .8 ~ .9), BETA는 지연 분산 계수(예: 1.3~2.0).

  긴급 정보 전달

  TCP 긴급 메커니즘의 목적은 송신 사용자가 수신 사용자가 일부 긴급 데이터를 수락하도록
  자극하고 수신 TCP가 현재 알려진 모든 긴급 데이터가 사용자에 의해 수신되었을 때 수신
  사용자에게 알리도록 허용하는 것입니다.

  이 메커니즘을 통해 데이터 스트림의 한 지점을 긴급 정보의 끝으로 지정할 수 있습니다. 이
  지점이 수신 TCP에서 수신 시퀀스 번호(RCV.NXT)보다 앞설 때마다 해당 TCP는 사용자에게
  "urgent mode"로 들어가라고 알려야 합니다. 수신 시퀀스 번호가 긴급 포인터를 따라잡을 때
  TCP는 사용자에게 "normal mode"로 들어가라고 알려야 합니다. 사용자가 "urgent mode"에
  있는 동안 긴급 포인터가 업데이트되면 업데이트가 사용자에게 표시되지 않습니다.

  이 방법은 전송된 모든 세그먼트에서 전달되는 긴급 필드를 사용합니다. URG 제어 플래그는 긴급
  필드가 의미가 있으며 긴급 포인터를 생성하기 위해 세그먼트 시퀀스 번호에 추가되어야 함을
  나타냅니다. 이 플래그가 없으면 미해결 긴급 데이터가 없음을 나타냅니다.

  긴급 표시를 보내려면 사용자는 최소한 하나의 데이터 옥텟도 보내야 합니다. 보내는 사용자도
  푸시를 표시하면 긴급한 정보를 대상 프로세스에 적시에 전달하는 기능이 향상됩니다.

  윈도우 관리

  각 세그먼트에서 전송된 윈도우는 윈도우를 보낸 사람(데이터 수신자)이 현재 수락할 준비가
  된 시퀀스 번호의 범위를 나타냅니다. 이것이 이 연결에 사용 가능한 현재 사용 가능한 데이터
  버퍼 공간과 관련이 있다는 가정이 있습니다.

  큰 윈도우를 표시하면 전송이 촉진됩니다. 허용할 수 있는 것보다 더 많은 데이터가 도착하면
  폐기됩니다. 이로 인해 과도한 재전송이 발생하여 네트워크 및 TCP에 불필요하게 부하가
  추가됩니다. 작은 윈도우를 표시하면 전송되는 각각의 새로운 세그먼트 사이에 왕복 지연을
  도입하는 지점까지 데이터 전송을 제한할 수 있습니다.

  제공되는 메커니즘을 통해 TCP는 큰 윈도우를 광고하고 이후에 많은 데이터를 수락하지 않고도
  훨씬 작은 윈도우를 광고할 수 있습니다. 소위 "shrinking the window"라고 하는 이
  작업은 권장되지 않습니다. 견고성 원칙에 따르면 TCP는 윈도우 자체를 축소하지 않지만 다른
  TCP의 일부에서 이러한 동작에 대비해야 합니다.

  송신 TCP는 송신 윈도우가 0인 경우에도 사용자로부터 수락하고 적어도 한 옥텟의 새 데이터를
  송신할 준비가 되어 있어야 합니다. 송신 TCP는 윈도우가 0인 경우에도 정기적으로 수신 TCP로
  재전송해야 합니다. 윈도우가 0일 때 재전송 간격은 2분이 권장됩니다. 이 재전송은 두 TCP 중
  하나에 윈도우가 없을 때 윈도우의 다시 열기가 다른 TCP에 안정적으로 보고되도록 보장하는 데
  필수적입니다.

  수신 TCP에 0 윈도우가 있고 세그먼트가 도착하면 여전히 다음 예상 시퀀스 번호와 현재
  윈도우(0)를 보여주는 승인을 보내야 합니다.

  송신 TCP는 전송할 데이터를 현재 윈도우에 맞는 세그먼트로 패키징하고 재전송 큐에 세그먼트를
  다시 패키징할 수 있습니다. 이러한 재포장은 필수는 아니지만 도움이 될 수 있습니다.

  단방향 데이터 흐름과 관련하여 윈도우 정보는 모두 동일한 시퀀스 번호를 갖는
  acknowledgment 세그먼트로 전달되므로 순서가 잘못되어 도착하면 다시 정렬할 방법이
  없습니다. 이는 심각한 문제는 아니지만 데이터 수신기의 이전 보고서를 기반으로 일시적으로
  윈도우 정보가 표시될 수 있습니다. 이 문제를 피하기 위한 개선은 가장 높은 acknowledgment
  번호를 전달하는 세그먼트(즉, 이전에 수신된 가장 높은 acknowledgment 번호보다 크거나 같은
  acknowledgment 번호를 가진 세그먼트)의 윈도우 정보에 따라 작동하는 것입니다.

  윈도우 관리 절차는 통신 성능에 상당한 영향을 미칩니다. 다음 의견은 구현자에 대한 제안입니다.

    윈도우 관리 제안

      매우 작은 윈도우를 할당하면 더 적은 수의 큰 세그먼트를 사용하여 더 나은 성능을 얻을 때
      데이터가 많은 작은 세그먼트로 전송됩니다.

      작은 윈도우를 피하는 한 가지 제안은 수신자가 추가 할당이 연결에 가능한 최대 할당의 X%
      이상이 될 때까지 윈도우 업데이트를 연기하는 것입니다(여기서 X는 20~40일 수 있음).

      또 다른 제안은 송신자가 데이터를 보내기 전에 윈도우가 충분히 커질 때까지 기다리면서 작은
      세그먼트를 보내는 것을 피하는 것입니다. 사용자가 푸시 기능 신호를 보내면 작은
      세그먼트라도 데이터를 보내야 합니다.

      acknowledgment가 지연되지 않으면 불필요한 재전송이 발생합니다. 한 가지 전략은 작은
      세그먼트가 도착하면(윈도우 정보를 업데이트하지 않고) acknowledgment를 보낸 다음
      윈도우가 더 크면 새 윈도우 정보와 함께 다른 acknowledgment를 보내는 것입니다.

      제로 윈도우를 조사하기 위해 전송된 세그먼트는 전송된 데이터를 점점 더 작은 세그먼트로
      분할하기 시작할 수도 있습니다. 제로 윈도우를 조사하기 위해 전송된 단일 데이터 옥텟을
      포함하는 세그먼트가 수락되면 현재 사용 가능한 윈도우의 한 옥텟을 소비합니다. 전송 TCP가
      윈도우가 0이 아닐 때마다 가능한 한 많이 전송하면 전송된 데이터가 번갈아 크고 작은
      세그먼트로 나뉩니다. 시간이 지남에 따라 윈도우 할당을 사용 가능하게 만드는 수신기에서
      가끔 일시 중지하면 큰 세그먼트가 작은 쌍과 그다지 크지 않은 쌍으로 나뉩니다. 그리고 잠시
      후 데이터 전송은 대부분 작은 세그먼트로 이루어집니다.

      여기에서 제안하는 것은 TCP 구현이 작은 윈도우 할당을 더 큰 윈도우로 결합하려고
      적극적으로 시도할 필요가 있다는 것입니다. 왜냐하면 윈도우를 관리하는 메커니즘은 가장
      간단한 구현에서 많은 작은 윈도우로 이어지는 경향이 있기 때문입니다.

3.8.  Interfaces (인터페이스)

  우려되는 두 가지 인터페이스가 있습니다: user/TCP 인터페이스 및 TCP/하위 수준 인터페이스.
  우리는 상당히 정교한 user/TCP 인터페이스 모델을 가지고 있지만, 하위 수준 프로토콜 모듈에
  대한 인터페이스는 하위 수준 프로토콜의 사양에 의해 자세히 지정될 것이기 때문에 여기서는
  지정하지 않습니다. 하위 수준이 IP인 경우 TCP가 사용할 수 있는 일부 매개 변수 값을
  기록합니다.

  User/TCP 인터페이스

    TCP에 대한 사용자 명령에 대한 다음 기능 설명은 모든 운영 체제가 서로 다른 기능을 갖기
    때문에 기껏해야 허구입니다. 결과적으로 우리는 다른 TCP 구현이 다른 사용자 인터페이스를
    가질 수 있음을 독자들에게 경고해야 합니다. 그러나 모든 TCP는 모든 TCP 구현이 동일한
    프로토콜 계층을 지원할 수 있도록 보장하기 위해 특정 최소 서비스 집합을 제공해야 합니다. 이
    섹션은 모든 TCP 구현에 필요한 기능적 인터페이스를 지정합니다.

    TCP 사용자 명령

      다음 섹션에서는 USER/TCP 인터페이스를 기능적으로 특성화합니다. 사용된 표기법은 고급
      언어에서 대부분의 프로시저 또는 함수 호출과 유사하지만 이 사용법이 트랩 유형 서비스
      호출(예: SVC, UUO, EMT)을 배제하기 위한 것은 아닙니다.

      아래에 설명된 사용자 명령은 프로세스 간 통신을 지원하기 위해 TCP가 수행해야 하는 기본
      기능을 지정합니다. 개별 구현은 고유한 정확한 형식을 정의해야 하며 단일 호출에서 기본
      기능의 조합 또는 하위 집합을 제공할 수 있습니다. 특히 일부 구현에서는 주어진 연결에
      대해 사용자가 발행한 첫 번째 SEND 또는 RECEIVE에서 연결을 자동으로 열기를 원할 수
      있습니다.

      프로세스 간 통신 기능을 제공할 때 TCP는 명령을 수락할 뿐만 아니라 서비스를 제공하는
      프로세스에 정보를 반환해야 합니다. 후자는 다음으로 구성됩니다:

        (a) 연결에 대한 일반 정보(예: 인터럽트, 원격 닫기, 지정되지 않은 외부 소켓
        바인딩).

        (b) 성공 또는 다양한 유형의 실패를 나타내는 특정 사용자 명령에 응답합니다.

      Open

        Format:  OPEN (local port, foreign socket, active/passive
        [, timeout] [, precedence] [, security/compartment] [, options])
        -> local connection name

        우리는 로컬 TCP가 서비스를 제공하는 프로세스의 ID를 알고 있고 지정된 연결을
        사용하기 위해 프로세스의 권한을 확인한다고 가정합니다. TCP 구현에 따라 소스 주소에
        대한 로컬 네트워크 및 TCP 식별자는 TCP 또는 하위 수준 프로토콜(예: IP)에서
        제공됩니다. 이러한 고려 사항은 어떤 TCP도 다른 TCP로 가장할 수 없는 정도까지
        보안에 대한 우려의 결과입니다. 마찬가지로 어떤 프로세스도 TCP의 공모 없이는 다른
        프로세스로 가장할 수 없습니다.

        Active/Passive 플래그가 수동으로 설정되어 있으면 들어오는 연결에 대한 LISTEN
        호출입니다. Passive open에는 특정 연결을 기다리는 완전히 지정된 외부 소켓 또는
        호출을 기다리는 지정되지 않은 외부 소켓이 있을 수 있습니다. 완전히 지정된 Passive
        호출은 SEND의 후속 실행에 의해 활성화될 수 있습니다.

        전송 제어 블록(TCB)이 생성되고 OPEN 명령 매개변수의 데이터로 부분적으로 채워집니다.

        Active OPEN 명령에서 TCP는 즉시 연결을 동기화(즉, establish)하는 절차를
        시작합니다.

        타임아웃이 있는 경우 호출자는 TCP에 제출된 모든 데이터에 대한 타임아웃을 설정할 수
        있습니다. 제한 시간 내에 데이터가 대상으로 성공적으로 전달되지 않으면 TCP는 연결을
        중단합니다. 현재 전역 기본값은 5분입니다.

        TCP 또는 운영 체제의 일부 구성 요소는 지정된 우선 순위 또는 보안/구획과의 연결을
        여는 사용자 권한을 확인합니다. OPEN 호출에서 우선 순위 또는 보안/구획 지정이 없으면
        기본값을 사용해야 함을 나타냅니다.

        TCP는 보안/구획 정보가 정확히 동일하고 우선 순위가 OPEN 호출에서 요청된 우선 순위와
        같거나 높은 경우에만 들어오는 요청을 일치하는 것으로 수락합니다.

        연결의 우선 순위는 OPEN 호출에서 요청되고 들어오는 요청에서 받은 값 중 더 높은
        값이며 연결 수명 동안 해당 값으로 고정됩니다. 구현자는 /Gridgames.png이 우선 순위
        협상에 대한 사용자 제어를 사용자에게 제공하기를 원할 수 있습니다. 예를 들어 사용자는
        우선 순위가 정확히 일치해야 하거나 우선 순위를 높이려는 모든 시도를 사용자가 확인하도록
        지정할 수 있습니다.

        로컬 연결 이름은 TCP에 의해 사용자에게 반환됩니다. 그러면 로컬 연결 이름을 <local
        socket, foreign socket> 쌍으로 정의된 연결에 대한 약칭으로 사용할 수 있습니다.

      Send

        Format:  SEND (local connection name, buffer address, byte
        count, PUSH flag, URGENT flag [,timeout])

        이 호출로 인해 표시된 사용자 버퍼에 포함된 데이터가 표시된 연결에서 전송됩니다. 연결이
        열리지 않은 경우 SEND는 오류로 간주됩니다. 일부 구현에서는 사용자가 먼저 SEND를
        허용할 수 있습니다; 이 경우 자동 OPEN이 수행됩니다. 호출 프로세스가 이 연결을 사용할
        권한이 없으면 오류가 반환됩니다.

        PUSH 플래그가 설정되면 데이터를 즉시 수신자에게 전송해야 하며 PUSH 비트는 버퍼에서
        생성된 마지막 TCP 세그먼트에 설정됩니다. PUSH 플래그가 설정되지 않은 경우 데이터는
        전송 효율성을 위해 후속 SEND의 데이터와 결합될 수 있습니다.

        URGENT 플래그가 설정되면 대상 TCP로 전송되는 세그먼트에 긴급 포인터가 설정됩니다.
        긴급 포인터가 긴급 포인터 이전의 데이터가 수신 프로세스에 의해 소비되지 않았음을
        나타내는 경우 수신 TCP는 수신 프로세스에 긴급 상태를 알립니다. 긴급의 목적은
        수신자가 긴급 데이터를 처리하도록 자극하고 현재 알려진 모든 긴급 데이터가 수신되면
        수신자에게 알리는 것입니다. 보내는 사용자의 TCP 신호가 긴급한 횟수는 받는
        사용자에게 긴급한 데이터가 있음을 알리는 횟수와 반드시 같지는 않습니다.

        OPEN에 외부 소켓이 지정되지 않았지만 연결이 설정되면(예: 로컬 소켓에 도착하는 외부
        세그먼트로 인해 LISTENing 연결이 특정화되었기 때문에) 지정된 버퍼가 묵시적 외부
        소켓으로 전송됩니다. 지정되지 않은 외부 소켓으로 OPEN을 사용하는 사용자는 외부 소켓
        주소를 명시적으로 알지 않고도 SEND를 사용할 수 있습니다.

        그러나 외부 소켓이 지정되기 전에 SEND를 시도하면 오류가 반환됩니다. 사용자는 STATUS
        호출을 사용하여 연결 상태를 확인할 수 있습니다. 일부 구현에서 TCP는 지정되지 않은
        소켓이 바인드될 때 사용자에게 알릴 수 있습니다.

        제한 시간이 지정되면 이 연결에 대한 현재 사용자 제한 시간이 새 것으로 변경됩니다.

        가장 간단한 구현에서 SEND는 전송이 완료되거나 제한 시간이 초과될 때까지 전송
        프로세스로 제어를 반환하지 않습니다. 그러나 이 간단한 방법은 교착 상태(예를 들어,
        연결의 양쪽에서 RECEIVE를 수행하기 전에 SEND를 시도할 수 있음)에 취약하고 성능이
        좋지 않으므로 권장되지 않습니다. 보다 정교한 구현은 프로세스가 네트워크 I/O와 동시에
        실행될 수 있도록 즉시 반환되고 더 나아가 여러 SEND가 진행될 수 있도록 합니다. 여러
        SEND는 선착순으로 처리되므로 TCP는 즉시 처리할 수 없는 항목을 대기열에 넣습니다.

        우리는 SEND가 나중에 제공받은 TCP에서 일종의 SIGNAL 또는 의사 인터럽트를
        이끌어내는 비동기 사용자 인터페이스를 암시적으로 가정했습니다. 대안은 응답을 즉시
        반환하는 것입니다. 예를 들어 SEND는 전송된 세그먼트가 멀리 있는 TCP에서 확인되지
        않은 경우에도 즉시 로컬 확인을 반환할 수 있습니다. 우리는 궁극적인 성공을 낙관적으로
        가정할 수 있습니다. 우리가 틀렸다면 시간 초과로 인해 연결이 종료됩니다. 이러한 종류
        (동기식)의 구현에는 여전히 일부 비동기 신호가 있지만 특정 세그먼트나 버퍼가 아닌 연결
        자체를 처리합니다.

        프로세스가 서로 다른 SEND에 대한 오류 또는 성공 표시를 구별하기 위해 버퍼 주소가
        SEND 요청에 대한 코딩된 응답과 함께 반환되는 것이 적절할 수 있습니다. 호출
        프로세스로 반환되어야 하는 정보를 나타내는 TCP-사용자 신호는 아래에서 설명합니다.

      Receive

        Format:  RECEIVE (local connection name, buffer address, byte
        count) -> byte count, urgent flag, push flag

        이 명령은 지정된 연결과 관련된 수신 버퍼를 할당합니다. 이 명령 앞에 OPEN이 없거나
        호출 프로세스가 이 연결을 사용할 권한이 없으면 오류가 반환됩니다.

        가장 간단한 구현에서 제어는 버퍼가 채워지거나 일부 오류가 발생할 때까지 호출
        프로그램으로 돌아가지 않지만 이 방식은 교착 상태에 매우 취약합니다. 보다 정교한
        구현을 통해 여러 RECEIVE가 한 번에 미해결 상태가 될 수 있습니다. 세그먼트가
        도착하면 채워집니다. 이 전략은 호출 프로그램에 PUSH가 표시되었거나 버퍼가 가득
        찼음을 알리기 위해 보다 정교한 체계(아마도 비동기식)의 비용으로 처리량 증가를
        허용합니다.

        PUSH가 표시되기 전에 버퍼를 채우기에 충분한 데이터가 도착하면 RECEIVE에 대한
        응답에서 PUSH 플래그가 설정되지 않습니다. 버퍼는 보유할 수 있는 만큼의 데이터로
        채워집니다. 버퍼가 채워지기 전에 PUSH가 표시되면 버퍼는 부분적으로 채워진 것으로
        반환되고 PUSH가 표시됩니다.

        긴급한 데이터가 있는 경우 TCP-사용자 신호를 통해 데이터가 도착하자마자 사용자에게
        알립니다. 따라서 받는 사용자는 "urgent mode"에 있어야 합니다. URGENT 플래그가
        켜져 있으면 추가 긴급 데이터가 남아 있습니다. URGENT 플래그가 꺼져 있으면
        RECEIVE에 대한 이 호출이 모든 긴급 데이터를 반환했으며 사용자는 이제 "urgent
        mode"를 종료할 수 있습니다. 긴급 포인터 다음의 데이터(비긴급 데이터)는 경계가
        사용자에게 명확하게 표시되지 않는 한 선행 긴급 데이터와 동일한 버퍼에서 사용자에게
        전달될 수 없습니다.

        여러 미해결 RECEIVE들을 구별하고 버퍼가 완전히 채워지지 않은 경우를 처리하기 위해
        반환 코드에는 버퍼 포인터와 수신된 데이터의 실제 길이를 나타내는 바이트 수가 함께
        제공됩니다.

        RECEIVE의 대체 구현에는 TCP 할당 버퍼 저장소가 있거나 TCP가 사용자와 링 버퍼를
        공유할 수 있습니다.

      Close

        Format:  CLOSE (local connection name)

        이 명령은 지정된 연결이 닫히도록 합니다. 연결이 열려 있지 않거나 호출 프로세스가 이
        연결을 사용할 권한이 없으면 오류가 반환됩니다. 연결 닫기는 흐름 제어가 허용하는 대로
        미해결 SEND가 모두 서비스될 때까지 전송(및 재전송)된다는 점에서 정상적인 작업을 위한
        것입니다. 따라서 여러 번 SEND 호출을 한 다음 CLOSE를 호출하고 모든 데이터가
        대상으로 전송될 것으로 예상하는 것이 허용되어야 합니다. 상대방이 데이터의 마지막
        전송을 시도할 수 있으므로 사용자가 CLOSING 연결에서 계속 수신해야 한다는 점도
        분명해야 합니다. 따라서 CLOSE는 "더 이상 보낼 것이 없다"는 의미이지 "더 이상 받지
        않겠다"는 의미는 아닙니다. 닫는 쪽이 시간 초과 전에 모든 데이터를 제거할 수 없는
        경우가 발생할 수 있습니다(사용자 수준 프로토콜이 잘 고려되지 않은 경우). 이 경우
        CLOSE는 ABORT로 바뀌고 TCP 닫기를 포기합니다.

        사용자는 자신의 주도로 또는 TCP의 다양한 프롬프트(예: 원격 닫기 실행, 전송 시간 초과
        초과, 대상 액세스 불가)에 대한 응답으로 언제든지 연결을 CLOSE 할 수 있습니다.

        연결을 닫으려면 외부 TCP와의 통신이 필요하기 때문에 연결이 잠시 동안 닫힘 상태로
        유지될 수 있습니다. TCP가 CLOSE 명령에 응답하기 전에 연결을 다시 열려고 하면 오류
        응답이 발생합니다.

        닫기는 또한 푸시 기능을 의미합니다.

      Status

        Format:  STATUS (local connection name) -> status data

        이것은 구현 종속 사용자 명령이며 역효과 없이 제외될 수 있습니다. 반환된 정보는
        일반적으로 연결과 관련된 TCB에서 가져옵니다.

        이 명령은 다음 정보가 포함된 데이터 블록을 반환합니다:

          local socket,
          foreign socket,
          local connection name,
          receive window,
          send window,
          connection state,
          number of buffers awaiting acknowledgment,
          number of buffers pending receipt,
          urgent state,
          precedence,
          security/compartment,
          and transmission timeout.

        연결 상태 또는 구현 자체에 따라 이 정보 중 일부를 사용할 수 없거나 의미가 없을 수
        있습니다. 호출 프로세스가 이 연결을 사용할 권한이 없으면 오류가 반환됩니다. 이렇게
        하면 승인되지 않은 프로세스가 연결에 대한 정보를 얻는 것을 방지할 수 있습니다.

      Abort

        Format:  ABORT (local connection name)

        이 명령은 보류 중인 모든 SEND 및 RECEIVES가 중단되고 TCB가 제거되며 특수 RESET
        메시지가 연결의 반대편에 있는 TCP로 전송되도록 합니다. 구현에 따라 사용자는 각 미해결
        SEND 또는 RECEIVE에 대한 중단 표시를 받거나 단순히 ABORT 승인을 받을 수
        있습니다.

    TCP-to-User Messages

      운영 체제 환경은 TCP가 사용자 프로그램에 비동기적으로 신호를 보낼 수 있는 수단을
      제공한다고 가정합니다. TCP가 사용자 프로그램에 신호를 보내면 특정 정보가 사용자에게
      전달됩니다. 종종 사양에서 정보는 오류 메시지가 됩니다. 다른 경우에는 SEND 또는
      RECEIVE 또는 다른 사용자 호출 처리 완료와 관련된 정보가 있습니다.

      다음 정보가 제공됩니다:

        Local Connection Name                    Always
        Response String                          Always
        Buffer Address                           Send & Receive
        Byte count (counts bytes received)       Receive
        Push flag                                Receive
        Urgent flag                              Receive

  TCP/Lower-Level Interface

    TCP는 하위 수준의 프로토콜 모듈을 호출하여 네트워크를 통해 실제로 정보를 보내고 받습니다.
    한 가지 사례는 하위 수준 모듈이 인터넷 프로토콜(IP)인 ARPA 인터네트워크 시스템의
    경우입니다[2].

    하위 수준 프로토콜이 IP인 경우 서비스 유형 및 수명에 대한 인수를 제공합니다. TCP는
    이러한 매개변수에 대해 다음 설정을 사용합니다:

      Type of Service = Precedence: routine, Delay: normal, Throughput:
      normal, Reliability: normal; or 00000000.

      Time to Live    = one minute, or 00111100.

        가정된 최대 세그먼트 수명은 2분입니다. 여기서 우리는 인터넷 시스템에서 1분 이내에
        세그먼트를 전달할 수 없는 경우 세그먼트를 파기하도록 명시적으로 요청합니다.

    하위 수준이 IP(또는 이 기능을 제공하는 다른 프로토콜)이고 소스 라우팅이 사용되는 경우
    인터페이스는 경로 정보가 전달되도록 허용해야 합니다. 이는 TCP 체크섬에 사용되는 소스 및
    대상 주소가 원래 소스 및 최종 대상이 되도록 특히 중요합니다. 연결 요청에 응답하기 위해
    반환 경로를 유지하는 것도 중요합니다.

    모든 하위 수준 프로토콜은 송신 주소, 대상 주소 및 프로토콜 필드와 "TCP 길이"를 결정하는
    방법을 제공해야 합니다. IP의 기능적 등가 서비스를 제공하고 TCP 체크섬에서 사용됩니다.

3.9.  Event Processing (이벤트 처리)

  이 섹션에 설명된 처리는 가능한 구현 중 하나의 예입니다. 다른 구현은 처리 순서가 약간 다를 수
  있지만 이 섹션의 내용과 세부 사항만 다를뿐 본질적으로는 같습니다.

  TCP의 활동은 이벤트에 대한 응답으로 특징지을 수 있습니다. 발생하는 이벤트는 사용자 호출, 도착
  세그먼트 및 시간 초과의 세 가지 범주로 캐스트될 수 있습니다. 이 섹션에서는 각 이벤트에 대한
  응답으로 TCP가 수행하는 처리를 설명합니다. 대부분의 경우 필요한 처리는 연결 상태에 따라
  다릅니다.

    발생하는 이벤트:

      User Calls

        OPEN
        SEND
        RECEIVE
        CLOSE
        ABORT
        STATUS

      Arriving Segments

        SEGMENT ARRIVES

      Timeouts

        USER TIMEOUT
        RETRANSMISSION TIMEOUT
        TIME-WAIT TIMEOUT

  TCP/사용자 인터페이스의 모델은 사용자 명령이 이벤트 또는 의사 인터럽트를 통해 즉각적인 반환과
  지연된 응답을 받는 것입니다. 다음 설명에서 "signal"이라는 용어는 지연된 응답을 유발하는
  것을 의미합니다.

  오류 응답은 문자열로 제공됩니다. 예를 들어 존재하지 않는 연결을 참조하는 사용자 명령은
  "error: connection not open"을 수신합니다.

  시퀀스 번호, acknowledgment 번호, 윈도우 등에 대한 모든 산술 연산은 모듈로 2**32
  시퀀스 번호 공간 크기입니다. 또한 "=<"는 (modulo 2**32)보다 작거나 같음을 의미합니다.

  수신 세그먼트 처리에 대해 생각하는 자연스러운 방법은 세그먼트가 먼저 적절한 시퀀스 번호(즉,
  해당 내용이 시퀀스 번호 공간에서 예상되는 "수신 윈도우" 범위에 있음)에 대해 테스트된 다음
  일반적으로 다음과 같다고 상상하는 것입니다. 시퀀스 번호 순서대로 대기 및 처리됩니다.

  세그먼트가 이미 수신된 다른 세그먼트와 겹치면 새 데이터만 포함하도록 세그먼트를 재구성하고
  헤더 필드를 일관되게 조정합니다.

  상태 변경이 언급되지 않으면 TCP는 동일한 상태를 유지합니다.

  OPEN Call

    CLOSED STATE (i.e., TCB does not exist)

      연결 상태 정보를 보관할 새 전송 제어 블록(TCB)을 만듭니다. 로컬 소켓 식별자, 외부
      소켓, 우선 순위, 보안/구획 및 사용자 제한 시간 정보를 입력합니다. 외부 소켓의 일부는
      Passive OPEN에서 지정되지 않을 수 있으며 들어오는 SYN 세그먼트의 매개변수로
      채워집니다. 요청된 보안 및 우선 순위가 이 사용자에 대해 허용되는지 확인하고 그렇지
      않은 경우 ""error: precedence not allowed" 또는 "error: security/
      compartment not allowed."을 반환합니다. Passive이면 LISTEN 상태로
      들어가고 돌아갑니다. Active 상태이고 외부 소켓이 지정되지 않은 경우 "error:
      foreign socket unspecified"을 반환합니다; Active 상태이고 외부 소켓이
      지정된 경우 SYN 세그먼트를 발행합니다. 초기 전송 시퀀스 번호(Initial Send
      Sequence number)가 선택됩니다. <SEQ=ISS><CTL=SYN> 형식의 SYN 세그먼트가
      전송됩니다. SND.UNA를 ISS로, SND.NXT를 ISS+1로 설정하고 SYN-SENT 상태로
      진입한 후 반환합니다.

      호출자가 지정된 로컬 소켓에 대한 액세스 권한이 없으면 "error: connection
      illegal for this process"를 반환합니다. 새 연결을 만들 공간이 없으면 "error:
      insufficient resources"을 반환합니다.

    LISTEN STATE

      Active 및 외부 소켓이 지정된 경우 연결을 Passive에서 Acitve으로 변경하고 ISS를
      선택하십시오. SYN 세그먼트를 보내고 SND.UNA를 ISS로, SND.NXT를 ISS+1로
      설정합니다. SYN-SENT 상태로 들어갑니다. SEND와 관련된 데이터는 SYN 세그먼트와 함께
      전송되거나 ESTABLISHED 상태에 들어간 후 전송을 위해 대기할 수 있습니다. 명령에서
      요청된 경우 긴급 비트는 이 명령의 결과로 전송된 데이터 세그먼트와 함께 전송되어야
      합니다. 요청을 대기할 공간이 없으면 "error: insufficient resources"으로
      응답합니다. 외부 소켓이 지정되지 않은 경우 "error: foreign socket
      unspecified"을 반환합니다.

    SYN-SENT STATE
    SYN-RECEIVED STATE
    ESTABLISHED STATE
    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE
    CLOSE-WAIT STATE
    CLOSING STATE
    LAST-ACK STATE
    TIME-WAIT STATE

      Return "error:  connection already exists".

  SEND Call

    CLOSED STATE (i.e., TCB does not exist)

      사용자가 이러한 연결에 액세스할 수 없으면 "error: connection illegal for
      this process"를 반환합니다.

      그렇지 않으면 "error:  connection does not exist"를 반환합니다.

    LISTEN STATE

      외부 소켓이 지정된 경우 Passive에서 Active으로 연결을 변경하고 ISS를 선택하십시오.
      SYN 세그먼트를 보내고 SND.UNA를 ISS로, SND.NXT를 ISS+1로 설정합니다.
      SYN-SENT 상태로 들어갑니다. SEND와 관련된 데이터는 SYN 세그먼트와 함께 전송되거나
      ESTABLISHED 상태에 들어간 후 전송을 위해 대기할 수 있습니다. 명령에서 요청된 경우
      긴급 비트는 이 명령의 결과로 전송된 데이터 세그먼트와 함께 전송되어야 합니다. 요청을
      대기할 공간이 없으면 "error: insufficient resources"으로 응답합니다. 외부
      소켓이 지정되지 않은 경우 "error:  foreign socket unspecified"을 반환합니다.

    SYN-SENT STATE
    SYN-RECEIVED STATE

      ESTABLISHED 상태에 진입한 후 전송을 위해 데이터를 대기시킵니다. 대기할 공간이 없으면
      "error: insufficient resources"으로 응답합니다.

    ESTABLISHED STATE
    CLOSE-WAIT STATE

      버퍼를 세그먼트화하고 피기백된 확인과 함께 보냅니다(acknowledgment 값 = RCV.NXT).
      이 버퍼를 기억할 공간이 충분하지 않으면 "error: insufficient resources"을
      반환합니다.

      긴급 플래그가 설정되면 SND.UP <- SND.NXT-1이고 나가는 세그먼트에 긴급 포인터를
      설정합니다.

    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE
    CLOSING STATE
    LAST-ACK STATE
    TIME-WAIT STATE

      "error:  connection closing"를 반환하고 요청을 서비스하지 않습니다.

  RECEIVE Call

    CLOSED STATE (i.e., TCB does not exist)

      사용자가 이러한 연결에 액세스할 수 없으면 "error: connection illegal for this
      process"를 반환합니다.

      그렇지 않으면 "error:  connection does not exist"를 반환합니다.

    LISTEN STATE
    SYN-SENT STATE
    SYN-RECEIVED STATE

      ESTABLISHED 상태에 진입한 후 처리를 위한 대기열입니다. 이 요청을 대기할 공간이 없으면
      "error: insufficient resources"으로 응답합니다.

    ESTABLISHED STATE
    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE

      들어오는 세그먼트가 충분하지 않아 요청을 충족할 수 없으면 요청을 대기열에 넣습니다.
      RECEIVE를 기억할 대기열 공간이 없으면 "error:  insufficient resources"으로
      응답합니다.

      대기 중인 수신 세그먼트를 수신 버퍼로 재조립하고 사용자에게 반환합니다. 이 경우 "push
      seen"(PUSH)을 표시합니다.

      RCV.UP이 현재 사용자에게 전달되는 데이터보다 앞서 있으면 긴급한 데이터가 있음을
      사용자에게 알립니다.

      TCP가 사용자에게 데이터를 전달하는 책임을 지는 경우 승인을 통해 발신자에게 그 사실을
      전달해야 합니다. 이러한 acknowledgment의 형성은 들어오는 세그먼트 처리에 대한
      논의에서 아래에 설명되어 있습니다.

    CLOSE-WAIT STATE

      원격 측에서 이미 FIN을 보냈기 때문에 RECEIVE는 이미 가지고 있지만 아직 사용자에게
      전달되지 않은 텍스트로 충족되어야 합니다. 전달을 기다리는 텍스트가 없으면 RECEIVE는
      "error: connection closing" 응답을 받습니다. 그렇지 않으면 나머지 텍스트를
      RECEIVE를 만족시키는 데 사용할 수 있습니다.

    CLOSING STATE
    LAST-ACK STATE
    TIME-WAIT STATE

      "error: connection closing"를 반환합니다.

  CLOSE Call

    CLOSED STATE (i.e., TCB does not exist)

      사용자가 이러한 연결에 액세스할 수 없으면 "error: connection illegal for this
      process"를 반환합니다.

      그렇지 않으면 "error: connection does not exist"를 반환합니다.

    LISTEN STATE

      모든 미해결 RECEIVE는 "error: closing" 응답과 함께 반환됩니다. TCB를 삭제하고
      CLOSED 상태로 진입한 후 복귀합니다.

    SYN-SENT STATE

      TCB를 삭제하고 대기 중인 모든 SEND 또는 RECEIVE에 대해 "error: closing"
      응답을 반환합니다.

    SYN-RECEIVED STATE

      SEND가 발행되지 않았고 보낼 대기 중인 데이터가 없으면 FIN 세그먼트를 형성하여 전송하고
      FIN-WAIT-1 상태로 들어갑니다; 그렇지 않으면 ESTABLISHED 상태에 들어간 후 처리를
      위해 대기합니다.

    ESTABLISHED STATE

      이전의 모든 SEND가 세그먼트화될 때까지 이것을 대기시킨 다음 FIN 세그먼트를 형성하고
      전송합니다. 어쨌든 FIN-WAIT-1 상태로 들어갑니다.

    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE

      엄밀히 말하면 이것은 오류이며 "error: connection closing" 응답을 받아야 합니다.
      두 번째 FIN이 방출되지 않는 한 "ok" 응답도 허용됩니다(첫 번째 FIN은 재전송될 수
      있음).

    CLOSE-WAIT STATE

      이전의 모든 SEND가 세그먼트화될 때까지 이 요청을 대기시킵니다; 그런 다음 FIN 세그먼트를
      보내고 CLOSING 상태로 들어갑니다.

    CLOSING STATE
    LAST-ACK STATE
    TIME-WAIT STATE

      "error: connection closing"로 응답합니다.

  ABORT Call

    CLOSED STATE (i.e., TCB does not exist)

      사용자가 이러한 연결에 액세스할 수 없어야 하는 경우 "error: connection illegal for
      this process"를 반환합니다.

      그렇지 않으면 "error: connection does not exist"를 반환합니다.

    LISTEN STATE

      모든 미해결 RECEIVE는 "error: connection reset" 응답과 함께 반환되어야 합니다.
      TCB를 삭제하고 CLOSED 상태로 진입한 후 복귀합니다.

    SYN-SENT STATE

      대기 중인 모든 SEND 및 RECEIVE는 "connection reset" 알림을 받고 TCB를 삭제하고
      CLOSED 상태로 들어가 반환해야 합니다.

    SYN-RECEIVED STATE
    ESTABLISHED STATE
    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE
    CLOSE-WAIT STATE

      재설정 세그먼트 보내기:

        <SEQ=SND.NXT><CTL=RST>

      대기 중인 모든 SEND 및 RECEIVE에는 "connection reset" 알림이 제공되어야 합니다.
      전송을 위해 대기 중인 모든 세그먼트(위에서 형성된 RST 제외) 또는 재전송을 플러시하고
      TCB를 삭제하고 CLOSED 상태로 들어가 반환해야 합니다.

    CLOSING STATE
    LAST-ACK STATE
    TIME-WAIT STATE

      "ok"라고 응답하고 TCB를 삭제하고 CLOSED 상태로 들어간 후 돌아갑니다.

  STATUS Call

    CLOSED STATE (i.e., TCB does not exist)

      사용자가 이러한 연결에 액세스할 수 없어야 하는 경우 "error: connection illegal
      for this process"를 반환합니다.

      그렇지 않으면 "error:  connection does not exist"를 반환합니다.

    LISTEN STATE

      "state = LISTEN" 및 TCB 포인터를 반환합니다.

    SYN-SENT STATE

      "state = SYN-SENT" 및 TCB 포인터를 반환합니다.

    SYN-RECEIVED STATE

      "state = SYN-RECEIVED" 및 TCB 포인터를 반환합니다.

    ESTABLISHED STATE

      "state = ESTABLISHED" 및 TCB 포인터를 반환합니다.

    FIN-WAIT-1 STATE

      "state = FIN-WAIT-1" 및 TCB 포인터를 반환합니다.

    FIN-WAIT-2 STATE

      "state = FIN-WAIT-2" 및 TCB 포인터를 반환합니다.

    CLOSE-WAIT STATE

      "state = CLOSE-WAIT" 및 TCB 포인터를 반환합니다.

    CLOSING STATE

      "state = CLOSING" 및 TCB 포인터를 반환합니다.

    LAST-ACK STATE

      "state = LAST-ACK" 및 TCB 포인터를 반환합니다.

    TIME-WAIT STATE

      "state = TIME-WAIT" 및 TCB 포인터를 반환합니다.

  SEGMENT ARRIVES

    만약 상태가 CLOSED(즉, TCB가 존재하지 않음)이라면

      들어오는 세그먼트의 모든 데이터는 삭제됩니다. RST를 포함하는 수신 세그먼트는 폐기됩니다.
      RST를 포함하지 않는 수신 세그먼트로 인해 응답으로 RST가 전송됩니다. 잘못된 세그먼트를
      보낸 TCP에서 재설정 시퀀스를 수락할 수 있도록 승인 및 시퀀스 필드 값이 선택됩니다.

      ACK 비트가 꺼져 있으면 시퀀스 번호 0이 사용되며,

        <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>

      ACK 비트가 켜져 있으면,

        <SEQ=SEG.ACK><CTL=RST>

      반환.

    상태가 LISTEN이면

      먼저 RST 확인

        들어오는 RST는 무시해야 합니다. 반환.

      두 번째로 ACK 확인

        아직 LISTEN 상태에 있는 연결에 도착한 acknowledgment은 잘못된 것입니다.
        도착하는 ACK 포함 세그먼트에 대해 허용 가능한 재설정 세그먼트가 형성되어야 합니다.
        RST는 다음과 같은 형식이어야 합니다:

          <SEQ=SEG.ACK><CTL=RST>

        반환.

      세 번째로 SYN 확인

        SYN 비트가 설정되어 있으면 보안을 확인하십시오. 들어오는 세그먼트의 보안/컴파트먼트가
        TCB의 보안/구획과 정확히 일치하지 않으면 재설정을 보내고 반환합니다.

          <SEQ=SEG.ACK><CTL=RST>

        SEG.PRC가 TCB.PRC보다 크면 사용자와 시스템이 허용하면 TCB.PRC<-SEG.PRC를
        설정하고, 허용되지 않으면 재설정을 보내고 반환합니다.

          <SEQ=SEG.ACK><CTL=RST>

        SEG.PRC가 TCB.PRC보다 작으면 계속합니다.

        RCV.NXT를 SEG.SEQ+1로 설정하고, IRS는 SEG.SEQ로 설정하고 다른 컨트롤이나
        텍스트는 나중에 처리하기 위해 대기해야 합니다. ISS를 선택하고 다음 형식의 SYN
        세그먼트를 전송해야 합니다:

          <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>
          
        SND.NXT는 ISS+1로, SND.UNA는 ISS로 설정됩니다. 연결 상태를
        SYN-RECEIVED로 변경해야 합니다. 들어오는 다른 제어 또는 데이터(SYN과 결합)는
        SYN-RECEIVED 상태에서 처리되지만 SYN 및 ACK 처리는 반복되어서는 안 됩니다.
        청취가 완전히 지정되지 않은 경우(즉, 외부 소켓이 완전히 지정되지 않은 경우) 지정되지
        않은 필드를 지금 채워야 합니다.

      네 번째로 다른 텍스트나 컨트롤

        다른 제어 또는 텍스트 포함 세그먼트(SYN을 포함하지 않음)에는 ACK가 있어야 하므로
        ACK 처리에 의해 폐기됩니다. 들어오는 RST 세그먼트는 이 연결 화신에 의해 전송된 어떤
        것에 대한 응답으로 전송될 수 없기 때문에 유효하지 않을 수 있습니다. 따라서 여기에
        도달할 가능성은 없지만 만약 도달한다면 세그먼트를 삭제하고 돌아오십시오.

    만약 상태가 SYN-SENT이면

      먼저 ACK 비트를 확인

        ACK 비트가 설정된 경우

          SEG.ACK =< ISS 또는 SEG.ACK > SND.NXT인 경우 재설정 전송(RST 비트가
          설정되지 않은 경우 세그먼트를 삭제하고 반환)

            <SEQ=SEG.ACK><CTL=RST>

          그리고 세그먼트를 버립니다. 반환.

          SND.UNA =< SEG.ACK =< SND.NXT이면 ACK가 허용됩니다.

      두 번째로 RST 비트 확인

        RST 비트가 설정되어 있는 경우

          ACK가 허용되면 사용자에게 "error: connection reset" 신호를 보내고
          세그먼트를 삭제하고 CLOSED 상태로 들어가 TCB를 삭제한 다음 반환합니다. 그렇지
          않으면(ACK 없음) 세그먼트를 삭제하고 반환합니다.

      세 번째로 보안 및 우선 순위 확인

        세그먼트의 보안/구획이 TCB의 보안/구획과 정확히 일치하지 않으면 재설정을 보냅니다.

          ACK가 있는 경우

            <SEQ=SEG.ACK><CTL=RST>

          그렇지 않으면

            <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>

        ACK가 있는 경우

          세그먼트의 우선 순위는 TCB의 우선 순위와 일치해야 하며 일치하지 않으면 재설정을
          보냅니다.

            <SEQ=SEG.ACK><CTL=RST>

        ACK가 없는 경우

          세그먼트의 우선 순위가 TCB의 우선 순위보다 높으면 사용자가 허용하고 시스템이 TCB의
          우선 순위를 세그먼트의 우선 순위로 올리고 prec를 올리는 것이 허용되지 않으면
          재설정을 보냅니다.

            <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>

          세그먼트의 우선 순위가 TCB의 우선 순위보다 낮으면 계속합니다.

        재설정이 전송된 경우 세그먼트를 버리고 반환합니다.

      네 번째로 SYN 비트 확인

        이 단계는 ACK가 정상이거나 ACK가 없고 세그먼트에 RST가 포함되지 않은 경우에만
        도달해야 합니다.

        SYN 비트가 켜져 있고 보안/구획 및 우선 순위가 허용되는 경우 RCV.NXT는
        SEG.SEQ+1로 설정되고 IRS는 SEG.SEQ로 설정됩니다. SND.UNA는 SEG.ACK(ACK가
        있는 경우)와 동일하게 진행되어야 하며 이에 의해 확인된 재전송 큐의 모든 세그먼트는
        제거되어야 합니다.

        SND.UNA > ISS(우리의 SYN이 ACK됨)이면 연결 상태를 ESTABLISHED로 변경하고
        ACK 세그먼트를 형성합니다

          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>

        그 후 이를 보냅니다. 전송 대기 중인 데이터 또는 컨트롤이 포함될 수 있습니다.
        세그먼트에 다른 컨트롤이나 텍스트가 있으면 URG 비트가 확인되는 아래 여섯 번째
        단계에서 처리를 계속하고 그렇지 않으면 반환합니다.

        그렇지 않으면 SYN-RECEIVED를 입력하고 SYN,ACK 세그먼트를 형성합니다.

          <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>

        그 후 이를 보냅니다. 세그먼트에 다른 컨트롤이나 텍스트가 있는 경우 ESTABLISHED
        상태에 도달한 후 처리를 위해 큐에 넣고 반환합니다.

      다섯 번째로, SYN 또는 RST 비트 중 어느 것도 설정되지 않은 경우 세그먼트를 삭제하고
      반환합니다.

    그렇지 않으면,

    첫 번째로 시퀀스 번호 확인

      SYN-RECEIVED STATE
      ESTABLISHED STATE
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE
      CLOSE-WAIT STATE
      CLOSING STATE
      LAST-ACK STATE
      TIME-WAIT STATE

        세그먼트는 순서대로 처리됩니다. 도착 시 초기 테스트는 이전 중복을 폐기하는 데
        사용되지만 추가 처리는 SEG.SEQ 순서로 수행됩니다. 세그먼트의 내용이 이전 부분과
        새 부분 사이의 경계에 걸쳐 있는 경우 새 부분만 처리해야 합니다.

        들어오는 세그먼트에 대한 적합성 테스트에는 네 가지 경우가 있습니다:

        Segment Receive  Test
        Length  Window
        ------- -------  -------------------------------------------

           0       0     SEG.SEQ = RCV.NXT

           0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

          >0       0     not acceptable

          >0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
                      or RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND

        RCV.WND가 0이면 어떤 세그먼트도 허용되지 않지만 유효한 ACK, URG 및 RST를
        수락하도록 특별히 허용해야 합니다.

        들어오는 세그먼트가 허용되지 않는 경우 acknowledgment를 응답으로 보내야
        합니다(RST 비트가 설정되지 않은 경우 세그먼트를 삭제하고 반환):

          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>

        acknowledgment를 보낸 후 허용되지 않는 세그먼트를 삭제하고 반환합니다.

        다음에서는 세그먼트가 RCV.NXT에서 시작하고 창을 초과하지 않는 이상적인 세그먼트라고
        가정합니다. 창 밖에 있는 부분(SYN 및 FIN 포함)을 잘라내고 세그먼트가
        RCV.NXT에서 시작하는 경우에만 추가 처리하여 이 가정에 맞게 실제 세그먼트를 조정할
        수 있습니다. 더 높은 시작 시퀀스 번호를 가진 세그먼트는 나중 처리를 위해 보류될 수
        있습니다.

    두 번째로 RST 비트를 확인,

      SYN-RECEIVED STATE

        RST 비트가 설정되어 있는 경우

          이 연결이 Passive OPEN으로 시작된 경우(즉, LISTEN 상태에서 온 경우) 연결을
          LISTEN 상태로 되돌리고 반홥합니다. 사용자에게 알릴 필요가 없습니다. 이 연결이
          Active OPEN으로 시작된 경우(즉, SYN-SENT 상태에서 온 경우) 연결이 거부되면
          사용자에게 "connection refused" 신호를 보냅니다. 두 경우 모두 재전송 
          대기열의 모든 세그먼트를 제거해야 합니다. 그리고 Active OPEN의 경우 CLOSED
          상태로 진입하여 TCB를 삭제하고 반환합니다.

      ESTABLISHED
      FIN-WAIT-1
      FIN-WAIT-2
      CLOSE-WAIT

        RST 비트가 설정되면 미해결 RECEIVE 및 SEND는 "reset" 응답을 수신해야 합니다.
        모든 세그먼트 대기열을 플러시해야 합니다. 사용자는 요청하지 않은 일반 "connection
        reset" 신호도 수신해야 합니다. CLOSED 상태로 들어가 TCB를 삭제하고 반환합니다.

      CLOSING STATE
      LAST-ACK STATE
      TIME-WAIT

        RST 비트가 설정되면 CLOSED 상태로 들어가고 TCB를 삭제하고 돌아갑니다.

    세 번째로 보안 및 우선 순위 확인

      SYN-RECEIVED

        세그먼트의 보안/구획 및 우선 순위가 TCB의 보안/구획 및 우선 순위와 정확히 일치하지
        않으면 재설정을 보내고 반환합니다.

      ESTABLISHED STATE

        세그먼트의 보안/구획 및 우선 순위가 TCB의 보안/구획 및 우선 순위와 정확히 일치하지
        않는 경우 재설정을 보내면 모든 미해결 RECEIVE 및 SEND가 "reset" 응답을
        수신해야 합니다. 모든 세그먼트 대기열을 플러시해야 합니다. 사용자는 요청하지 않은
        일반 "connection reset" 신호도 수신해야 합니다. CLOSED 상태로 들어가 TCB를
        삭제하고 반환합니다.

      이 검사는 보안 또는 우선 순위가 다른 이러한 포트 사이의 이전 연결의 세그먼트가 현재
      연결을 중단시키는 것을 방지하기 위해 시퀀스 검사 다음에 배치됩니다.

    네 번째로, SYN 비트 확인,


      SYN-RECEIVED
      ESTABLISHED STATE
      FIN-WAIT STATE-1
      FIN-WAIT STATE-2
      CLOSE-WAIT STATE
      CLOSING STATE
      LAST-ACK STATE
      TIME-WAIT STATE

        SYN가 윈도우에 있으면 오류이며 재설정을 보내고 미해결 RECEIVE 및 SEND는
        "reset" 응답을 수신하고 모든 세그먼트 대기열을 플러시해야 하며 사용자는 요청하지
        않은 일반 "connection reset" 신호도 수신해야 합니다. CLOSED 상태에서 TCB를
        삭제하고 돌아갑니다.

        SYN가 윈도우에 없으면 이 단계에 도달하지 못하고 첫 번째 단계(시퀀스 번호 확인)에서
        ack가 전송됩니다.

    다섯 번째로 ACK 필드 확인,

      ACK 비트가 꺼져 있으면 세그먼트를 삭제하고 반환

      ACK 비트가 켜져 있으면

        SYN-RECEIVED STATE

          SND.UNA =< SEG.ACK =< SND.NXT이면 ESTABLISHED 상태로 들어가 처리를
          계속합니다.

            세그먼트 확인이 허용되지 않으면 재설정 세그먼트를 형성하고,

              <SEQ=SEG.ACK><CTL=RST>

            이를 보냅니다.

        ESTABLISHED STATE

          SND.UNA < SEG.ACK =< SND.NXT이면 SND.UNA <- SEG.ACK를 설정합니다.
          이로써 완전히 확인된 재전송 대기열의 모든 세그먼트가 제거됩니다. 사용자는 전송되고
          완전히 승인된 버퍼에 대해 긍정적인 승인을 받아야 합니다(즉, SEND 버퍼는 "ok"
          응답과 함께 반환되어야 함). ACK가 중복되면(SEG.ACK < SND.UNA) 무시할 수
          있습니다. ACK가 아직 전송되지 않은 항목에 응답하면(SEG.ACK > SND.NXT)
          ACK를 전송하고 세그먼트를 삭제한 다음 반환합니다.

          SND.UNA < SEG.ACK =< SND.NXT인 경우 전송 윈도우를 업데이트해야 합니다.
          (SND.WL1 < SEG.SEQ 또는 (SND.WL1 = SEG.SEQ 및
          SND.WL2 =< SEG.ACK))인 경우 SND.WND <- SEG.WND 설정,
          SND.WL1 <- SEG.SEQ 설정, SND.WL2 <- SEG.ACK를 설정합니다.

          SND.WND는 SND.UNA의 오프셋이고, SND.WL1은 SND.WND를 업데이트하는 데 사용된
          마지막 세그먼트의 시퀀스 번호를 기록하고, SND.WL2는 SND.WND를 업데이트하는 데
          사용된 마지막 세그먼트의 acknowledgment 번호를 기록합니다. 여기를 확인하면
          오래된 세그먼트를 사용하여 윈도우를 업데이트하는 것을 방지합니다.

        FIN-WAIT-1 STATE

          ESTABLISHED 상태에 대한 처리 외에도 이제 FIN이 확인되면 FIN-WAIT-2를
          입력하고 해당 상태에서 처리를 계속합니다.

        FIN-WAIT-2 STATE

          ESTABLISHED 상태에 대한 처리 외에도 재전송 대기열이 비어 있으면 사용자의
          CLOSE가 승인("ok")될 수 있지만 TCB를 삭제하지는 않습니다.

        CLOSE-WAIT STATE

          ESTABLISHED 상태와 동일한 처리를 합니다.

        CLOSING STATE

          ESTABLISHED 상태에 대한 처리 외에도 ACK가 FIN을 확인하면 TIME-WAIT 상태로
          들어가고 그렇지 않으면 세그먼트를 무시합니다.

        LAST-ACK STATE

          이 상태에 도착할 수 있는 유일한 것은 FIN에 대한 acknowledgment입니다.
          FIN이 확인되지 않으면 TCB를 삭제하고 CLOSED 상태로 들어간 후 돌아갑니다.

        TIME-WAIT STATE

          이 상태로 도착할 수 있는 유일한 것은 원격 FIN의 재전송입니다. 확인하고 2 MSL
          시간 제한을 다시 시작합니다.

    여섯 번째로, URG 비트 확인,

      ESTABLISHED STATE
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE

        URG 비트가 설정되어 있으면 RCV.UP <- max(RCV.UP,SEG.UP)이고 긴급
        포인터(RCV.UP)가 데이터 소모보다 앞서 있으면 원격 측에 긴급 데이터가 있음을
        사용자에게 알립니다. 사용자가 이 연속적인 긴급 데이터 시퀀스에 대해 이미 신호를
        받은 경우(또는 여전히 "urgent mode"에 있는 경우) 사용자에게 다시 신호를
        보내지 마십시오.

      CLOSE-WAIT STATE
      CLOSING STATE
      LAST-ACK STATE
      TIME-WAIT

        FIN이 원격 측에서 수신되었으므로 이런 일이 발생하지 않아야 합니다. URG를
        무시하십시오.

    일곱 번째로, 세그먼트 텍스트 처리,

      ESTABLISHED STATE
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE

        ESTABLISHED 상태가 되면 사용자 RECEIVE 버퍼에 세그먼트 텍스트를 전달할 수
        있습니다. 세그먼트의 텍스트는 버퍼가 가득 차거나 세그먼트가 비어 있을 때까지 버퍼로
        이동할 수 있습니다. 세그먼트가 비어 있고 PUSH 플래그가 있으면 버퍼가 반환될 때
        PUSH가 수신되었음을 사용자에게 알립니다.

        TCP가 사용자에게 데이터 전달을 담당할 때 데이터 수신을 승인해야 합니다.

        일단 TCP가 데이터에 대한 책임을 지면 수락된 데이터보다 RCV.NXT를 진행하고
        RCV.WND를 현재 버퍼 가용성에 적절하게 조정합니다. RCV.NXT 및 RCV.WND의
        합계는 줄어들지 않아야 합니다.

        섹션 3.7의 윈도우 관리 제안를 참고하세요.

        다음 양식에 대한 acknowledgment를 보냅니다:

          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>

        이 acknowledgment는 가능한 경우 과도한 지연 없이 전송되는 세그먼트에
        피기백되어야 합니다.

      CLOSE-WAIT STATE
      CLOSING STATE
      LAST-ACK STATE
      TIME-WAIT STATE

        FIN이 원격 측에서 수신되었으므로 이런 일이 발생하지 않아야 합니다. 세그먼트
        텍스트를 무시하십시오.

    여덟 번째로, FIN 비트 확인,

      SEG.SEQ를 확인할 수 없으므로 상태가 CLOSED, LISTEN 또는 SYN-SENT인 경우
      FIN을 처리하지 마십시오. 세그먼트를 삭제하고 반환합니다.

      FIN 비트가 설정되면 사용자에게 "connection closing" 신호를 보내고 동일한
      메시지와 함께 보류 중인 RECEIVE를 반환하고 FIN을 통해 RCV.NXT를 진행하고
      FIN에 대한 acknowledgment를 보냅니다. FIN은 아직 사용자에게 전달되지 않은
      세그먼트 텍스트에 대해 PUSH를 의미합니다.

        SYN-RECEIVED STATE
        ESTABLISHED STATE

          CLOSE-WAIT 상태로 들어갑니다.

        FIN-WAIT-1 STATE

          FIN이 ACK된 경우(아마도 이 세그먼트에서) TIME-WAIT를 입력하고 시간 대기
          타이머를 시작하고 다른 타이머를 끕니다. 그렇지 않으면 CLOSING 상태로
          들어갑니다.

        FIN-WAIT-2 STATE

          TIME-WAIT 상태로 들어갑니다. 시간 대기 타이머를 시작하고 다른 타이머를
          끕니다.

        CLOSE-WAIT STATE

          CLOSE-WAIT 상태 유지.

        CLOSING STATE

          CLOSING 상태 유지.

        LAST-ACK STATE

          LAST-ACK 상태 유지.

        TIME-WAIT STATE

          TIME-WAIT 상태 유지. 2 MSL time-wait 타임아웃을 다시 시작합니다.

    그리고 반환합니다.

  USER TIMEOUT

    모든 상태에서 사용자 시간 초과가 만료되면 모든 대기열을 플러시하고 일반적으로 사용자에게
    "error: connection aborted due to user timeout" 신호를 보내고 미해결
    호출의 경우 TCB를 삭제하고 CLOSED 상태로 들어가 반환합니다.

  RETRANSMISSION TIMEOUT

    어떤 상태에서든 재전송 큐의 세그먼트에서 재전송 타임아웃이 만료되면 재전송 큐의 맨 앞에
    있는 세그먼트를 다시 보내고 재전송 타이머를 다시 초기화한 뒤 반환합니다.

  TIME-WAIT TIMEOUT

    연결에서 시간 대기 제한 시간이 만료되면 TCB를 삭제하고 CLOSED 상태로 들어가
    반환합니다.

                                 용어 사전

번역자(dbadoy) 주석: 용어는 원문을 남겨놓음.

1822
          BBN Report 1822, "The Specification of the Interconnection of
          a Host and an IMP".  The specification of interface between a
          host and the ARPANET.

          BBN 보고서 1822, The Specification of the Interconnection of a
          Host and an IMP". 호스트와 ARPANET 간의 인터페이스 사양입니다.

ACK
          A control bit (acknowledge) occupying no sequence space, which
          indicates that the acknowledgment field of this segment
          specifies the next sequence number the sender of this segment
          is expecting to receive, hence acknowledging receipt of all
          previous sequence numbers.

          시퀀스 공간을 차지하지 않는 제어 비트(승인). 이 세그먼트의 acknowledgment
          필드는 이 세그먼트의 송신자가 받을 것으로 예상하는 다음 시퀀스 번호를 지정하므로
          모든 이전 시퀀스 번호의 수신을 확인합니다.

ARPANET message
          The unit of transmission between a host and an IMP in the
          ARPANET.  The maximum size is about 1012 octets (8096 bits).

          ARPANET에서 호스트와 IMP 사이의 전송 단위. 최대 크기는 약
          1012옥텟(8096비트)입니다.

ARPANET packet
          A unit of transmission used internally in the ARPANET between
          IMPs.  The maximum size is about 126 octets (1008 bits).

          IMP 사이의 ARPANET에서 내부적으로 사용되는 전송 단위. 최대 크기는 약
          126옥텟(1008비트)입니다.

connection
          A logical communication path identified by a pair of sockets.

          한 쌍의 소켓으로 식별되는 논리적 통신 경로입니다.

datagram
          A message sent in a packet switched computer communications
          network.

          패킷 교환 컴퓨터 통신 네트워크에서 전송되는 메시지입니다.

Destination Address
          The destination address, usually the network and host
          identifiers.

          수신 주소, 일반적으로 네트워크 및 호스트 식별자입니다.

FIN
          A control bit (finis) occupying one sequence number, which
          indicates that the sender will send no more data or control
          occupying sequence space.

          하나의 시퀀스 번호를 차지하는 제어 비트(finis)는 송신자가 더 이상 데이터를
          보내지 않거나 차지하는 시퀀스 공간을 제어하지 않음을 나타냅니다.

fragment
          A portion of a logical unit of data, in particular an internet
          fragment is a portion of an internet datagram.

          데이터의 논리적 단위, 특히 인터넷 조각의 일부는 인터넷 데이터그램의 일부입니다.

FTP
          A file transfer protocol.

          File Transfer Protocol.

header
          Control information at the beginning of a message, segment,
          fragment, packet or block of data.

          메시지, 세그먼트, 조각, 패킷 또는 데이터 블록의 시작 부분에 있는 제어 정보.

host
          A computer.  In particular a source or destination of messages
          from the point of view of the communication network.

          컴퓨터. 특히 통신 네트워크의 관점에서 메시지의 송신자 또는 수신자입니다.

Identification
          An Internet Protocol field.  This identifying value assigned
          by the sender aids in assembling the fragments of a datagram.

          인터넷 프로토콜 필드. 발신자가 할당한 이 식별 값은 데이터그램 조각을 조립하는 데
          도움이 됩니다.

IMP
          The Interface Message Processor, the packet switch of the
          ARPANET.

          ARPANET의 패킷 스위치인 Interface Message Processor.

internet address
          A source or destination address specific to the host level.

          호스트 수준에 특정한 송신자 또는 수신자 주소입니다.

internet datagram
          The unit of data exchanged between an internet module and the
          higher level protocol together with the internet header.

          인터넷 헤더와 함께 인터넷 모듈과 상위 프로토콜 사이에서 교환되는 데이터의 단위.

internet fragment
          A portion of the data of an internet datagram with an internet
          header.
          인터넷 헤더가 있는 인터넷 데이터그램의 데이터 일부입니다.

IP
          Internet Protocol.

          Internet Protocol.

IRS
          The Initial Receive Sequence number.  The first sequence
          number used by the sender on a connection.

          Initial Receive Sequence number. 연결에서 송신자가 사용하는 첫 번째 시퀀스
          번호입니다.

ISN
          The Initial Sequence Number.  The first sequence number used
          on a connection, (either ISS or IRS).  Selected on a clock
          based procedure.

          Initial Sequence Number. 연결에 사용된 첫 번째 시퀀스 번호(ISS 또는
          IRS). 시계 기반 절차에서 선택되었습니다.

ISS
          The Initial Send Sequence number.  The first sequence number
          used by the sender on a connection.

          Initial Send Sequence number. 연결에서 송신자가 사용하는 첫 번째 시퀀스
          번호입니다.

leader
          Control information at the beginning of a message or block of
          data.  In particular, in the ARPANET, the control information
          on an ARPANET message at the host-IMP interface.

          메시지 또는 데이터 블록의 시작 부분에 있는 정보를 제어합니다. 특히, ARPANET에서
          호스트-IMP 인터페이스에서 ARPANET 메시지에 대한 제어 정보.

left sequence
          This is the next sequence number to be acknowledged by the
          data receiving TCP (or the lowest currently unacknowledged
          sequence number) and is sometimes referred to as the left edge
          of the send window.

          이것은 데이터 수신 TCP(또는 현재 승인되지 않은 가장 낮은 시퀀스 번호)에 의해
          승인될 다음 시퀀스 번호이며 때때로 송신 윈도우의 왼쪽 가장자리.

local packet
          The unit of transmission within a local network.

          로컬 네트워크 내의 전송 단위.

module
          An implementation, usually in software, of a protocol or other
          procedure.

          일반적으로 소프트웨어에서 프로토콜 또는 기타 절차 구현.

MSL
          Maximum Segment Lifetime, the time a TCP segment can exist in
          the internetwork system.  Arbitrarily defined to be 2 minutes.

          Maximum Segment Lifetime, TCP 세그먼트가 인터네트워크 시스템에 존재할 수
          있는 시간. 임의로 2분으로 정의됩니다.

octet
          An eight bit byte.

          8비트, 바이트.

Options
          An Option field may contain several options, and each option
          may be several octets in length.  The options are used
          primarily in testing situations; for example, to carry
          timestamps.  Both the Internet Protocol and TCP provide for
          options fields.

          옵션 필드에는 여러 옵션이 포함될 수 있으며 각 옵션의 길이는 여러 옥텟일 수
          있습니다. 옵션은 주로 테스트 상황에서 사용됩니다. 예를 들어 타임스탬프를
          전달합니다. 인터넷 프로토콜과 TCP 모두 옵션 필드를 제공합니다.

packet
          A package of data with a header which may or may not be
          logically complete.  More often a physical packaging than a
          logical packaging of data.

          논리적으로 완전하거나 완전하지 않을 수 있는 헤더가 있는 데이터 패키지입니다.
          데이터의 논리적 패키징보다 물리적 패키징이 더 자주 사용됩니다.

port
          The portion of a socket that specifies which logical input or
          output channel of a process is associated with the data.

          데이터와 관련된 프로세스의 논리적 입력 또는 출력 채널을 지정하는 소켓 부분입니다.

process
          A program in execution.  A source or destination of data from
          the point of view of the TCP or other host-to-host protocol.

          실행 중인 프로그램. TCP 또는 기타 호스트 간 프로토콜의 관점에서 본 데이터의
          송신자 또는 수신자입니다.

PUSH
          A control bit occupying no sequence space, indicating that
          this segment contains data that must be pushed through to the
          receiving user.

          시퀀스 공간을 차지하지 않는 제어 비트로, 수신 사용자에게 푸시해야 하는 데이터가
          이 세그먼트에 포함되어 있음을 나타냅니다.

RCV.NXT
          receive next sequence number

          다음 시퀀스 번호 수신

RCV.UP
          receive urgent pointer

          긴급 포인터 수신

RCV.WND
          receive window

          윈도우 수신

receive next sequence number
          This is the next sequence number the local TCP is expecting to
          receive.

          로컬 TCP가 받을 것으로 예상되는 다음 시퀀스 번호입니다.

receive window
          This represents the sequence numbers the local (receiving) TCP
          is willing to receive.  Thus, the local TCP considers that
          segments overlapping the range RCV.NXT to
          RCV.NXT + RCV.WND - 1 carry acceptable data or control.
          Segments containing sequence numbers entirely outside of this
          range are considered duplicates and discarded.

          로컬(수신) TCP가 수신하려는 시퀀스 번호를 나타냅니다. 따라서 로컬 TCP는
          범위 RCV.NXT에서 RCV.NXT + RCV.WND - 1까지 겹치는 세그먼트가 허용 가능한
          데이터 또는 제어를 전달하는 것으로 간주합니다. 이 범위를 완전히 벗어난 시퀀스
          번호를 포함하는 세그먼트는 중복으로 간주되어 폐기됩니다.

RST
          A control bit (reset), occupying no sequence space, indicating
          that the receiver should delete the connection without further
          interaction.  The receiver can determine, based on the
          sequence number and acknowledgment fields of the incoming
          segment, whether it should honor the reset command or ignore
          it.  In no case does receipt of a segment containing RST give
          rise to a RST in response.

          시퀀스 공간을 차지하지 않는 제어 비트(재설정)는 수신기가 추가 상호 작용 없이 연결을
          삭제해야 함을 나타냅니다. 수신기는 들어오는 세그먼트의 시퀀스 번호와 승인 필드를
          기반으로 재설정 명령을 존중할지 무시할지 여부를 결정할 수 있습니다. 어떤 경우에도
          RST가 포함된 세그먼트를 수신하면 응답으로 RST가 발생하지 않습니다.

RTP
          Real Time Protocol:  A host-to-host protocol for communication
          of time critical information.

          Real Time Protocol: 시간이 중요한 정보의 통신을 위한 호스트 간 프로토콜.

SEG.ACK
          segment acknowledgment

SEG.LEN
          segment length

SEG.PRC
          segment precedence value

SEG.SEQ
          segment sequence

SEG.UP
          segment urgent pointer field

SEG.WND
          segment window field

segment
          A logical unit of data, in particular a TCP segment is the
          unit of data transfered between a pair of TCP modules.

          데이터의 논리적 단위, 특히 TCP 세그먼트는 한 쌍의 TCP 모듈 간에 전송되는
          데이터 단위.

segment acknowledgment
          The sequence number in the acknowledgment field of the
          arriving segment.

          도착 세그먼트의 acknowledgment 필드에 있는 시퀀스 번호.

segment length
          The amount of sequence number space occupied by a segment,
          including any controls which occupy sequence space.

          시퀀스 공간을 차지하는 컨트롤을 포함하여 세그먼트가 차지하는 시퀀스 번호 공간의
          양.

segment sequence
          The number in the sequence field of the arriving segment.

          도착 세그먼트의 시퀀스 필드에 있는 번호.

send sequence
          This is the next sequence number the local (sending) TCP will
          use on the connection.  It is initially selected from an
          initial sequence number curve (ISN) and is incremented for
          each octet of data or sequenced control transmitted.

          로컬(보내는) TCP가 연결에 사용할 다음 시퀀스 번호입니다. 처음에는 ISN(Initial
          Sequence Number Curve)에서 선택되며 데이터의 각 옥텟 또는 전송된 시퀀스
          컨트롤에 대해 증가합니다.

send window
          This represents the sequence numbers which the remote
          (receiving) TCP is willing to receive.  It is the value of the
          window field specified in segments from the remote (data
          receiving) TCP.  The range of new sequence numbers which may
          be emitted by a TCP lies between SND.NXT and
          SND.UNA + SND.WND - 1. (Retransmissions of sequence numbers
          between SND.UNA and SND.NXT are expected, of course.)

          이것은 원격(수신) TCP가 수신하려는 시퀀스 번호를 나타냅니다. 원격(데이터 수신)
          TCP에서 세그먼트에 지정된 윈도우 필드의 값입니다. TCP에 의해 방출될 수 있는
          새로운 시퀀스 번호의 범위는 SND.NXT와 SND.UNA + SND.WND - 1 사이에
          있습니다. (물론 SND.UNA와 SND.NXT 사이의 시퀀스 번호 재전송이 예상됩니다.)

SND.NXT
          send sequence

SND.UNA
          left sequence

SND.UP
          send urgent pointer

SND.WL1
          segment sequence number at last window update

SND.WL2
          segment acknowledgment number at last window update

SND.WND
          send window

socket
          An address which specifically includes a port identifier, that
          is, the concatenation of an Internet Address with a TCP port.

          특정 포트 식별자를 포함하는 주소, 즉 인터넷 주소와 TCP 포트의 연결입니다.

Source Address
          The source address, usually the network and host identifiers.

          송신자 주소, 일반적으로 네트워크 및 호스트 식별자.

SYN
          A control bit in the incoming segment, occupying one sequence
          number, used at the initiation of a connection, to indicate
          where the sequence numbering will start.

          시퀀스 번호 지정이 시작되는 위치를 나타내기 위해 연결 시작 시 사용되는 하나의
          시퀀스 번호를 차지하는 수신 세그먼트의 제어 비트입니다.

TCB
          Transmission control block, the data structure that records
          the state of a connection.

          연결 상태를 기록하는 데이터 구조인 전송 제어 블록.

TCB.PRC
          The precedence of the connection.

          연결의 우선 순위.

TCP
          Transmission Control Protocol:  A host-to-host protocol for
          reliable communication in internetwork environments.

          Transmission Control Protocol: 인터네트워크 환경에서 안정적인 통신을
          위한 호스트 간 프로토콜.
TOS
          Type of Service, an Internet Protocol field.

          Type of Service, 인터넷 프로토콜 필드.

Type of Service
          An Internet Protocol field which indicates the type of service
          for this internet fragment.

          인터넷 조각에 대한 서비스 유형을 나타내는 인터넷 프로토콜 필드.

URG
          A control bit (urgent), occupying no sequence space, used to
          indicate that the receiving user should be notified to do
          urgent processing as long as there is data to be consumed with
          sequence numbers less than the value indicated in the urgent
          pointer.

          긴급 포인터에 표시된 값보다 작은 시퀀스 번호로 소비할 데이터가 있는 한 긴급 처리를
          수행하도록 수신 사용자에게 통지해야 함을 나타내는 데 사용되는 시퀀스 공간을 차지하지
          않는 제어 비트(urgent).

urgent pointer
          A control field meaningful only when the URG bit is on.  This
          field communicates the value of the urgent pointer which
          indicates the data octet associated with the sending user's
          urgent call.

          URG 비트가 켜져 있을 때만 의미가 있는 제어 필드. 이 필드는 발신 사용자의 긴급
          호출과 관련된 데이터 옥텟을 나타내는 긴급 포인터의 값을 전달합니다.

                                  참조



[1]  Cerf, V., and R. Kahn, "A Protocol for Packet Network
     Intercommunication", IEEE Transactions on Communications,
     Vol. COM-22, No. 5, pp 637-648, May 1974.

[2]  Postel, J. (ed.), "Internet Protocol - DARPA Internet Program
     Protocol Specification", RFC 791, USC/Information Sciences
     Institute, September 1981.

[3]  Dalal, Y. and C. Sunshine, "Connection Management in Transport
     Protocols", Computer Networks, Vol. 2, No. 6, pp. 454-473,
     December 1978.

[4]  Postel, J., "Assigned Numbers", RFC 790, USC/Information Sciences
     Institute, September 1981.
